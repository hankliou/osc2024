
build/kernel8.elf:     file format elf64-littleaarch64


Disassembly of section .text:

0000000000080000 <_start>:
   80000:	9400000e 	bl	80038 <from_el2_to_el1>
   80004:	1002bfe1 	adr	x1, 85800 <exception_vector_table>
   80008:	d518c001 	msr	vbar_el1, x1

000000000008000c <setup_stack>:
   8000c:	58000261 	ldr	x1, 80058 <from_el2_to_el1+0x20>
   80010:	9100003f 	mov	sp, x1

0000000000080014 <setup_bss>:
   80014:	58000261 	ldr	x1, 80060 <from_el2_to_el1+0x28>
   80018:	180001c2 	ldr	w2, 80050 <from_el2_to_el1+0x18>

000000000008001c <init_bss>:
   8001c:	34000082 	cbz	w2, 8002c <run_main>
   80020:	f800843f 	str	xzr, [x1], #8
   80024:	51000442 	sub	w2, w2, #0x1
   80028:	35ffffa2 	cbnz	w2, 8001c <init_bss>

000000000008002c <run_main>:
   8002c:	940003ce 	bl	80f64 <main>

0000000000080030 <proc_hang>:
   80030:	d503205f 	wfe
   80034:	17ffffff 	b	80030 <proc_hang>

0000000000080038 <from_el2_to_el1>:
   80038:	d2b00001 	mov	x1, #0x80000000            	// #2147483648
   8003c:	d51c1101 	msr	hcr_el2, x1
   80040:	d28068a1 	mov	x1, #0x345                 	// #837
   80044:	d51c4001 	msr	spsr_el2, x1
   80048:	d51c403e 	msr	elr_el2, x30
   8004c:	d69f03e0 	eret
   80050:	0009f98b 	.word	0x0009f98b
   80054:	00000000 	udf	#0
   80058:	00d85288 	.word	0x00d85288
   8005c:	00000000 	.word	0x00000000
   80060:	00088630 	.word	0x00088630
   80064:	00000000 	.word	0x00000000

0000000000080068 <parse_hex_str>:
#include "cpio.h"
#include "u_string.h"

/* Parse an ASCII hex string into an integer. (big endian)*/
static unsigned int parse_hex_str(char *s, unsigned int max_len) {
   80068:	d10083ff 	sub	sp, sp, #0x20
   8006c:	f90007e0 	str	x0, [sp, #8]
   80070:	b90007e1 	str	w1, [sp, #4]
    unsigned int r = 0;
   80074:	b9001fff 	str	wzr, [sp, #28]

    for (unsigned int i = 0; i < max_len; i++) {
   80078:	b9001bff 	str	wzr, [sp, #24]
   8007c:	1400004b 	b	801a8 <parse_hex_str+0x140>
        r *= 16;
   80080:	b9401fe0 	ldr	w0, [sp, #28]
   80084:	531c6c00 	lsl	w0, w0, #4
   80088:	b9001fe0 	str	w0, [sp, #28]
        if (s[i] >= '0' && s[i] <= '9') {
   8008c:	b9401be0 	ldr	w0, [sp, #24]
   80090:	f94007e1 	ldr	x1, [sp, #8]
   80094:	8b000020 	add	x0, x1, x0
   80098:	39400000 	ldrb	w0, [x0]
   8009c:	7100bc1f 	cmp	w0, #0x2f
   800a0:	54000229 	b.ls	800e4 <parse_hex_str+0x7c>  // b.plast
   800a4:	b9401be0 	ldr	w0, [sp, #24]
   800a8:	f94007e1 	ldr	x1, [sp, #8]
   800ac:	8b000020 	add	x0, x1, x0
   800b0:	39400000 	ldrb	w0, [x0]
   800b4:	7100e41f 	cmp	w0, #0x39
   800b8:	54000168 	b.hi	800e4 <parse_hex_str+0x7c>  // b.pmore
            r += s[i] - '0';
   800bc:	b9401be0 	ldr	w0, [sp, #24]
   800c0:	f94007e1 	ldr	x1, [sp, #8]
   800c4:	8b000020 	add	x0, x1, x0
   800c8:	39400000 	ldrb	w0, [x0]
   800cc:	2a0003e1 	mov	w1, w0
   800d0:	b9401fe0 	ldr	w0, [sp, #28]
   800d4:	0b000020 	add	w0, w1, w0
   800d8:	5100c000 	sub	w0, w0, #0x30
   800dc:	b9001fe0 	str	w0, [sp, #28]
   800e0:	1400002f 	b	8019c <parse_hex_str+0x134>
        } else if (s[i] >= 'a' && s[i] <= 'f') {
   800e4:	b9401be0 	ldr	w0, [sp, #24]
   800e8:	f94007e1 	ldr	x1, [sp, #8]
   800ec:	8b000020 	add	x0, x1, x0
   800f0:	39400000 	ldrb	w0, [x0]
   800f4:	7101801f 	cmp	w0, #0x60
   800f8:	54000229 	b.ls	8013c <parse_hex_str+0xd4>  // b.plast
   800fc:	b9401be0 	ldr	w0, [sp, #24]
   80100:	f94007e1 	ldr	x1, [sp, #8]
   80104:	8b000020 	add	x0, x1, x0
   80108:	39400000 	ldrb	w0, [x0]
   8010c:	7101981f 	cmp	w0, #0x66
   80110:	54000168 	b.hi	8013c <parse_hex_str+0xd4>  // b.pmore
            r += s[i] - 'a' + 10;
   80114:	b9401be0 	ldr	w0, [sp, #24]
   80118:	f94007e1 	ldr	x1, [sp, #8]
   8011c:	8b000020 	add	x0, x1, x0
   80120:	39400000 	ldrb	w0, [x0]
   80124:	2a0003e1 	mov	w1, w0
   80128:	b9401fe0 	ldr	w0, [sp, #28]
   8012c:	0b000020 	add	w0, w1, w0
   80130:	51015c00 	sub	w0, w0, #0x57
   80134:	b9001fe0 	str	w0, [sp, #28]
   80138:	14000019 	b	8019c <parse_hex_str+0x134>
        } else if (s[i] >= 'A' && s[i] <= 'F') {
   8013c:	b9401be0 	ldr	w0, [sp, #24]
   80140:	f94007e1 	ldr	x1, [sp, #8]
   80144:	8b000020 	add	x0, x1, x0
   80148:	39400000 	ldrb	w0, [x0]
   8014c:	7101001f 	cmp	w0, #0x40
   80150:	54000229 	b.ls	80194 <parse_hex_str+0x12c>  // b.plast
   80154:	b9401be0 	ldr	w0, [sp, #24]
   80158:	f94007e1 	ldr	x1, [sp, #8]
   8015c:	8b000020 	add	x0, x1, x0
   80160:	39400000 	ldrb	w0, [x0]
   80164:	7101181f 	cmp	w0, #0x46
   80168:	54000168 	b.hi	80194 <parse_hex_str+0x12c>  // b.pmore
            r += s[i] - 'A' + 10;
   8016c:	b9401be0 	ldr	w0, [sp, #24]
   80170:	f94007e1 	ldr	x1, [sp, #8]
   80174:	8b000020 	add	x0, x1, x0
   80178:	39400000 	ldrb	w0, [x0]
   8017c:	2a0003e1 	mov	w1, w0
   80180:	b9401fe0 	ldr	w0, [sp, #28]
   80184:	0b000020 	add	w0, w1, w0
   80188:	5100dc00 	sub	w0, w0, #0x37
   8018c:	b9001fe0 	str	w0, [sp, #28]
   80190:	14000003 	b	8019c <parse_hex_str+0x134>
        } else {
            return r;
   80194:	b9401fe0 	ldr	w0, [sp, #28]
   80198:	14000009 	b	801bc <parse_hex_str+0x154>
    for (unsigned int i = 0; i < max_len; i++) {
   8019c:	b9401be0 	ldr	w0, [sp, #24]
   801a0:	11000400 	add	w0, w0, #0x1
   801a4:	b9001be0 	str	w0, [sp, #24]
   801a8:	b9401be1 	ldr	w1, [sp, #24]
   801ac:	b94007e0 	ldr	w0, [sp, #4]
   801b0:	6b00003f 	cmp	w1, w0
   801b4:	54fff663 	b.cc	80080 <parse_hex_str+0x18>  // b.lo, b.ul, b.last
        }
    }
    return r;
   801b8:	b9401fe0 	ldr	w0, [sp, #28]
}
   801bc:	910083ff 	add	sp, sp, #0x20
   801c0:	d65f03c0 	ret

00000000000801c4 <cpio_newc_parse_header>:

//
int cpio_newc_parse_header(struct cpio_newc_header *this_header_pointer,
                           char **pathname, unsigned int *filesize, char **data,
                           struct cpio_newc_header **next_header_pointer) {
   801c4:	a9bb7bfd 	stp	x29, x30, [sp, #-80]!
   801c8:	910003fd 	mov	x29, sp
   801cc:	f9001fe0 	str	x0, [sp, #56]
   801d0:	f9001be1 	str	x1, [sp, #48]
   801d4:	f90017e2 	str	x2, [sp, #40]
   801d8:	f90013e3 	str	x3, [sp, #32]
   801dc:	f9000fe4 	str	x4, [sp, #24]
    // this_header_pointer: ptr point to newc format header
    // pathname: double ptr point to "ptr point to 'this_header_pointer'"
    /* Ensure magic header exists. */
    if (strncmp(this_header_pointer->c_magic, CPIO_NEWC_HEADER_MAGIC,
   801e0:	f9401fe3 	ldr	x3, [sp, #56]
   801e4:	d28000c2 	mov	x2, #0x6                   	// #6
   801e8:	d0000020 	adrp	x0, 86000 <el1t_irq_invalid+0x78>
   801ec:	910a8001 	add	x1, x0, #0x2a0
   801f0:	aa0303e0 	mov	x0, x3
   801f4:	9400119f 	bl	84870 <strncmp>
   801f8:	7100001f 	cmp	w0, #0x0
   801fc:	54000060 	b.eq	80208 <cpio_newc_parse_header+0x44>  // b.none
                sizeof(this_header_pointer->c_magic)) != 0)
        return -1;
   80200:	12800000 	mov	w0, #0xffffffff            	// #-1
   80204:	1400004a 	b	8032c <cpio_newc_parse_header+0x168>

    // transfer big endian 8 byte hex string to unsigned int and store into
    // *filesize 8 is the size of type "long"
    *filesize = parse_hex_str(this_header_pointer->c_filesize, 8);
   80208:	f9401fe0 	ldr	x0, [sp, #56]
   8020c:	9100d800 	add	x0, x0, #0x36
   80210:	52800101 	mov	w1, #0x8                   	// #8
   80214:	97ffff95 	bl	80068 <parse_hex_str>
   80218:	2a0003e1 	mov	w1, w0
   8021c:	f94017e0 	ldr	x0, [sp, #40]
   80220:	b9000001 	str	w1, [x0]

    // file path start at the bit after header
    *pathname = ((char *)this_header_pointer) +
   80224:	f9401fe0 	ldr	x0, [sp, #56]
   80228:	9101b801 	add	x1, x0, #0x6e
   8022c:	f9401be0 	ldr	x0, [sp, #48]
   80230:	f9000001 	str	x1, [x0]
                sizeof(struct cpio_newc_header); // pointer + offset

    // data start at the bit after file path
    unsigned int pathname_length =
        parse_hex_str(this_header_pointer->c_namesize, 8);
   80234:	f9401fe0 	ldr	x0, [sp, #56]
   80238:	91017800 	add	x0, x0, #0x5e
   8023c:	52800101 	mov	w1, #0x8                   	// #8
   80240:	97ffff8a 	bl	80068 <parse_hex_str>
   80244:	b9004fe0 	str	w0, [sp, #76]
    unsigned int offset = pathname_length + sizeof(struct cpio_newc_header);
   80248:	b9404fe0 	ldr	w0, [sp, #76]
   8024c:	1101b800 	add	w0, w0, #0x6e
   80250:	b9004be0 	str	w0, [sp, #72]

    // pad data to align 4-byte
    offset = offset % 4 == 0 ? offset : (offset + 4 - offset % 4);
   80254:	b9404be0 	ldr	w0, [sp, #72]
   80258:	12000400 	and	w0, w0, #0x3
   8025c:	7100001f 	cmp	w0, #0x0
   80260:	540000a0 	b.eq	80274 <cpio_newc_parse_header+0xb0>  // b.none
   80264:	b9404be0 	ldr	w0, [sp, #72]
   80268:	121e7400 	and	w0, w0, #0xfffffffc
   8026c:	11001000 	add	w0, w0, #0x4
   80270:	14000002 	b	80278 <cpio_newc_parse_header+0xb4>
   80274:	b9404be0 	ldr	w0, [sp, #72]
   80278:	b9004be0 	str	w0, [sp, #72]
    *data = (char *)this_header_pointer + offset; // header + pathname len
   8027c:	b9404be0 	ldr	w0, [sp, #72]
   80280:	f9401fe1 	ldr	x1, [sp, #56]
   80284:	8b000021 	add	x1, x1, x0
   80288:	f94013e0 	ldr	x0, [sp, #32]
   8028c:	f9000001 	str	x1, [x0]

    // get next header
    // if is last file, point to end position, else point to next file header
    if (*filesize == 0) {
   80290:	f94017e0 	ldr	x0, [sp, #40]
   80294:	b9400000 	ldr	w0, [x0]
   80298:	7100001f 	cmp	w0, #0x0
   8029c:	540000c1 	b.ne	802b4 <cpio_newc_parse_header+0xf0>  // b.any
        *next_header_pointer = (struct cpio_newc_header *)*data;
   802a0:	f94013e0 	ldr	x0, [sp, #32]
   802a4:	f9400001 	ldr	x1, [x0]
   802a8:	f9400fe0 	ldr	x0, [sp, #24]
   802ac:	f9000001 	str	x1, [x0]
   802b0:	14000013 	b	802fc <cpio_newc_parse_header+0x138>
    } else {
        offset = *filesize;
   802b4:	f94017e0 	ldr	x0, [sp, #40]
   802b8:	b9400000 	ldr	w0, [x0]
   802bc:	b9004be0 	str	w0, [sp, #72]
        *next_header_pointer =
            (struct cpio_newc_header *)(*data +
   802c0:	f94013e0 	ldr	x0, [sp, #32]
   802c4:	f9400001 	ldr	x1, [x0]
                                        (offset % 4 == 0
   802c8:	b9404be0 	ldr	w0, [sp, #72]
   802cc:	12000400 	and	w0, w0, #0x3
                                             ? offset
                                             : (offset + 4 - offset % 4)));
   802d0:	7100001f 	cmp	w0, #0x0
   802d4:	54000061 	b.ne	802e0 <cpio_newc_parse_header+0x11c>  // b.any
   802d8:	b9404be0 	ldr	w0, [sp, #72]
   802dc:	14000005 	b	802f0 <cpio_newc_parse_header+0x12c>
   802e0:	b9404be0 	ldr	w0, [sp, #72]
   802e4:	121e7400 	and	w0, w0, #0xfffffffc
   802e8:	11001000 	add	w0, w0, #0x4
   802ec:	2a0003e0 	mov	w0, w0
            (struct cpio_newc_header *)(*data +
   802f0:	8b000021 	add	x1, x1, x0
        *next_header_pointer =
   802f4:	f9400fe0 	ldr	x0, [sp, #24]
   802f8:	f9000001 	str	x1, [x0]
    }

    // if file path == TRAILER!!! mean there's no more file behind
    if (strncmp(*pathname, "TRAILER!!!", sizeof("TRAILER!!!")) == 0) {
   802fc:	f9401be0 	ldr	x0, [sp, #48]
   80300:	f9400003 	ldr	x3, [x0]
   80304:	d2800162 	mov	x2, #0xb                   	// #11
   80308:	d0000020 	adrp	x0, 86000 <el1t_irq_invalid+0x78>
   8030c:	910aa001 	add	x1, x0, #0x2a8
   80310:	aa0303e0 	mov	x0, x3
   80314:	94001157 	bl	84870 <strncmp>
   80318:	7100001f 	cmp	w0, #0x0
   8031c:	54000061 	b.ne	80328 <cpio_newc_parse_header+0x164>  // b.any
        *next_header_pointer = 0;
   80320:	f9400fe0 	ldr	x0, [sp, #24]
   80324:	f900001f 	str	xzr, [x0]
    }
    return 0;
   80328:	52800000 	mov	w0, #0x0                   	// #0
   8032c:	a8c57bfd 	ldp	x29, x30, [sp], #80
   80330:	d65f03c0 	ret

0000000000080334 <uint32_endian_big2little>:
struct fdt_reserve_entry {
    uint64_t address;
    uint64_t size;
};

uint32_t uint32_endian_big2little(uint32_t data) {
   80334:	d10083ff 	sub	sp, sp, #0x20
   80338:	b9000fe0 	str	w0, [sp, #12]
    char *r = (char *)&data;
   8033c:	910033e0 	add	x0, sp, #0xc
   80340:	f9000fe0 	str	x0, [sp, #24]
    return (r[3] << 0) | (r[2] << 8) | (r[1] << 16) | (r[0] << 24);
   80344:	f9400fe0 	ldr	x0, [sp, #24]
   80348:	91000c00 	add	x0, x0, #0x3
   8034c:	39400000 	ldrb	w0, [x0]
   80350:	2a0003e1 	mov	w1, w0
   80354:	f9400fe0 	ldr	x0, [sp, #24]
   80358:	91000800 	add	x0, x0, #0x2
   8035c:	39400000 	ldrb	w0, [x0]
   80360:	53185c00 	lsl	w0, w0, #8
   80364:	2a000021 	orr	w1, w1, w0
   80368:	f9400fe0 	ldr	x0, [sp, #24]
   8036c:	91000400 	add	x0, x0, #0x1
   80370:	39400000 	ldrb	w0, [x0]
   80374:	53103c00 	lsl	w0, w0, #16
   80378:	2a000021 	orr	w1, w1, w0
   8037c:	f9400fe0 	ldr	x0, [sp, #24]
   80380:	39400000 	ldrb	w0, [x0]
   80384:	53081c00 	lsl	w0, w0, #24
   80388:	2a000020 	orr	w0, w1, w0
}
   8038c:	910083ff 	add	sp, sp, #0x20
   80390:	d65f03c0 	ret

0000000000080394 <uint64_endian_big2little>:

uint64_t uint64_endian_big2little(uint64_t data) {
   80394:	d10083ff 	sub	sp, sp, #0x20
   80398:	f90007e0 	str	x0, [sp, #8]
    char *r = (char *)&data;
   8039c:	910023e0 	add	x0, sp, #0x8
   803a0:	f9000fe0 	str	x0, [sp, #24]
    return ((unsigned long long)r[7] << 0) | (unsigned long long)(r[6] << 8) | ((unsigned long long)r[5] << 16) | ((unsigned long long)r[4] << 24) |
   803a4:	f9400fe0 	ldr	x0, [sp, #24]
   803a8:	91001c00 	add	x0, x0, #0x7
   803ac:	39400000 	ldrb	w0, [x0]
   803b0:	92401c01 	and	x1, x0, #0xff
   803b4:	f9400fe0 	ldr	x0, [sp, #24]
   803b8:	91001800 	add	x0, x0, #0x6
   803bc:	39400000 	ldrb	w0, [x0]
   803c0:	53185c00 	lsl	w0, w0, #8
   803c4:	93407c00 	sxtw	x0, w0
   803c8:	aa000021 	orr	x1, x1, x0
   803cc:	f9400fe0 	ldr	x0, [sp, #24]
   803d0:	91001400 	add	x0, x0, #0x5
   803d4:	39400000 	ldrb	w0, [x0]
   803d8:	92401c00 	and	x0, x0, #0xff
   803dc:	d370bc00 	lsl	x0, x0, #16
   803e0:	aa000021 	orr	x1, x1, x0
   803e4:	f9400fe0 	ldr	x0, [sp, #24]
   803e8:	91001000 	add	x0, x0, #0x4
   803ec:	39400000 	ldrb	w0, [x0]
   803f0:	92401c00 	and	x0, x0, #0xff
   803f4:	d3689c00 	lsl	x0, x0, #24
   803f8:	aa000021 	orr	x1, x1, x0
           ((unsigned long long)r[3] << 32) | ((unsigned long long)r[2] << 40) | ((unsigned long long)r[1] << 48) | ((unsigned long long)r[0] << 56);
   803fc:	f9400fe0 	ldr	x0, [sp, #24]
   80400:	91000c00 	add	x0, x0, #0x3
   80404:	39400000 	ldrb	w0, [x0]
   80408:	92401c00 	and	x0, x0, #0xff
   8040c:	d3607c00 	lsl	x0, x0, #32
    return ((unsigned long long)r[7] << 0) | (unsigned long long)(r[6] << 8) | ((unsigned long long)r[5] << 16) | ((unsigned long long)r[4] << 24) |
   80410:	aa000021 	orr	x1, x1, x0
           ((unsigned long long)r[3] << 32) | ((unsigned long long)r[2] << 40) | ((unsigned long long)r[1] << 48) | ((unsigned long long)r[0] << 56);
   80414:	f9400fe0 	ldr	x0, [sp, #24]
   80418:	91000800 	add	x0, x0, #0x2
   8041c:	39400000 	ldrb	w0, [x0]
   80420:	92401c00 	and	x0, x0, #0xff
   80424:	d3585c00 	lsl	x0, x0, #40
   80428:	aa000021 	orr	x1, x1, x0
   8042c:	f9400fe0 	ldr	x0, [sp, #24]
   80430:	91000400 	add	x0, x0, #0x1
   80434:	39400000 	ldrb	w0, [x0]
   80438:	92401c00 	and	x0, x0, #0xff
   8043c:	d3503c00 	lsl	x0, x0, #48
   80440:	aa000021 	orr	x1, x1, x0
   80444:	f9400fe0 	ldr	x0, [sp, #24]
   80448:	39400000 	ldrb	w0, [x0]
   8044c:	92401c00 	and	x0, x0, #0xff
   80450:	d3481c00 	lsl	x0, x0, #56
   80454:	aa000020 	orr	x0, x1, x0
}
   80458:	910083ff 	add	sp, sp, #0x20
   8045c:	d65f03c0 	ret

0000000000080460 <traverse_device_tree>:

void traverse_device_tree(void *dtb_ptr, dtb_callback callback) {
   80460:	a9ba7bfd 	stp	x29, x30, [sp, #-96]!
   80464:	910003fd 	mov	x29, sp
   80468:	f9000fe0 	str	x0, [sp, #24]
   8046c:	f9000be1 	str	x1, [sp, #16]
    struct fdt_header *header = dtb_ptr;
   80470:	f9400fe0 	ldr	x0, [sp, #24]
   80474:	f9002be0 	str	x0, [sp, #80]
    if (uint32_endian_big2little(header->magic) != 0xD00DFEED) {
   80478:	f9402be0 	ldr	x0, [sp, #80]
   8047c:	b9400000 	ldr	w0, [x0]
   80480:	97ffffad 	bl	80334 <uint32_endian_big2little>
   80484:	2a0003e1 	mov	w1, w0
   80488:	529fdda0 	mov	w0, #0xfeed                	// #65261
   8048c:	72ba01a0 	movk	w0, #0xd00d, lsl #16
   80490:	6b00003f 	cmp	w1, w0
   80494:	540000a0 	b.eq	804a8 <traverse_device_tree+0x48>  // b.none
        uart_sendline("Traverse_device_tree : wrong magic in traverse_device_tree");
   80498:	d0000020 	adrp	x0, 86000 <el1t_irq_invalid+0x78>
   8049c:	910ae000 	add	x0, x0, #0x2b8
   804a0:	94001292 	bl	84ee8 <uart_sendline>
        return;
   804a4:	14000089 	b	806c8 <traverse_device_tree+0x268>
    }

    // get device tree size
    uint32_t struct_size = uint32_endian_big2little(header->size_dt_struct);
   804a8:	f9402be0 	ldr	x0, [sp, #80]
   804ac:	b9402400 	ldr	w0, [x0, #36]
   804b0:	97ffffa1 	bl	80334 <uint32_endian_big2little>
   804b4:	b9004fe0 	str	w0, [sp, #76]

    char *dt_struct_ptr = (char *)((char *)header + uint32_endian_big2little(header->off_dt_struct));
   804b8:	f9402be0 	ldr	x0, [sp, #80]
   804bc:	b9400800 	ldr	w0, [x0, #8]
   804c0:	97ffff9d 	bl	80334 <uint32_endian_big2little>
   804c4:	2a0003e0 	mov	w0, w0
   804c8:	f9402be1 	ldr	x1, [sp, #80]
   804cc:	8b000020 	add	x0, x1, x0
   804d0:	f90023e0 	str	x0, [sp, #64]
    char *dt_strings_ptr = (char *)((char *)header + uint32_endian_big2little(header->off_dt_strings));
   804d4:	f9402be0 	ldr	x0, [sp, #80]
   804d8:	b9400c00 	ldr	w0, [x0, #12]
   804dc:	97ffff96 	bl	80334 <uint32_endian_big2little>
   804e0:	2a0003e0 	mov	w0, w0
   804e4:	f9402be1 	ldr	x1, [sp, #80]
   804e8:	8b000020 	add	x0, x1, x0
   804ec:	f9001fe0 	str	x0, [sp, #56]
    char *end = (char *)dt_struct_ptr + struct_size;
   804f0:	b9404fe0 	ldr	w0, [sp, #76]
   804f4:	f94023e1 	ldr	x1, [sp, #64]
   804f8:	8b000020 	add	x0, x1, x0
   804fc:	f9001be0 	str	x0, [sp, #48]
    char *pointer = dt_struct_ptr;
   80500:	f94023e0 	ldr	x0, [sp, #64]
   80504:	f9002fe0 	str	x0, [sp, #88]

    // traverse device tree's structure
    while (pointer < end) {
   80508:	1400006c 	b	806b8 <traverse_device_tree+0x258>
        // get type of node (pass the address into 'big2little' func)
        // cause the address stores the type of dt_struct, only need trans
        // endian
        uint32_t token_type = uint32_endian_big2little(*(uint32_t *)pointer);
   8050c:	f9402fe0 	ldr	x0, [sp, #88]
   80510:	b9400000 	ldr	w0, [x0]
   80514:	97ffff88 	bl	80334 <uint32_endian_big2little>
   80518:	b9002fe0 	str	w0, [sp, #44]

        pointer += 4; // pointer is a char pointer
   8051c:	f9402fe0 	ldr	x0, [sp, #88]
   80520:	91001000 	add	x0, x0, #0x4
   80524:	f9002fe0 	str	x0, [sp, #88]

        // if current node is beginning node
        if (token_type == FDT_BEGIN_NODE) {
   80528:	b9402fe0 	ldr	w0, [sp, #44]
   8052c:	7100041f 	cmp	w0, #0x1
   80530:	540002a1 	b.ne	80584 <traverse_device_tree+0x124>  // b.any
            callback(token_type, pointer, 0,
   80534:	f9400be4 	ldr	x4, [sp, #16]
   80538:	52800003 	mov	w3, #0x0                   	// #0
   8053c:	d2800002 	mov	x2, #0x0                   	// #0
   80540:	f9402fe1 	ldr	x1, [sp, #88]
   80544:	b9402fe0 	ldr	w0, [sp, #44]
   80548:	d63f0080 	blr	x4
                     0);                                    // pass 'node type' & 'ptr to node'
            pointer += strlen(pointer);                     // mov pointer to the end of node
   8054c:	f9402fe0 	ldr	x0, [sp, #88]
   80550:	94001097 	bl	847ac <strlen>
   80554:	aa0003e1 	mov	x1, x0
   80558:	f9402fe0 	ldr	x0, [sp, #88]
   8055c:	8b010000 	add	x0, x0, x1
   80560:	f9002fe0 	str	x0, [sp, #88]
            pointer += 4 - (unsigned long long)pointer % 4; // align to 4-byte
   80564:	f9402fe0 	ldr	x0, [sp, #88]
   80568:	92400400 	and	x0, x0, #0x3
   8056c:	d2800081 	mov	x1, #0x4                   	// #4
   80570:	cb000020 	sub	x0, x1, x0
   80574:	f9402fe1 	ldr	x1, [sp, #88]
   80578:	8b000020 	add	x0, x1, x0
   8057c:	f9002fe0 	str	x0, [sp, #88]
   80580:	1400004e 	b	806b8 <traverse_device_tree+0x258>
        }

        // if current node is endding node
        else if (token_type == FDT_END_NODE) {
   80584:	b9402fe0 	ldr	w0, [sp, #44]
   80588:	7100081f 	cmp	w0, #0x2
   8058c:	54000101 	b.ne	805ac <traverse_device_tree+0x14c>  // b.any
            callback(token_type, 0, 0, 0);
   80590:	f9400be4 	ldr	x4, [sp, #16]
   80594:	52800003 	mov	w3, #0x0                   	// #0
   80598:	d2800002 	mov	x2, #0x0                   	// #0
   8059c:	d2800001 	mov	x1, #0x0                   	// #0
   805a0:	b9402fe0 	ldr	w0, [sp, #44]
   805a4:	d63f0080 	blr	x4
   805a8:	14000044 	b	806b8 <traverse_device_tree+0x258>
        }

        // if current node is property node
        else if (token_type == FDT_PROP) {
   805ac:	b9402fe0 	ldr	w0, [sp, #44]
   805b0:	71000c1f 	cmp	w0, #0x3
   805b4:	54000501 	b.ne	80654 <traverse_device_tree+0x1f4>  // b.any
            uint32_t len = uint32_endian_big2little(*(uint32_t *)pointer);                        // get len
   805b8:	f9402fe0 	ldr	x0, [sp, #88]
   805bc:	b9400000 	ldr	w0, [x0]
   805c0:	97ffff5d 	bl	80334 <uint32_endian_big2little>
   805c4:	b9002be0 	str	w0, [sp, #40]
            pointer += 4;                                                                         // mov to begining
   805c8:	f9402fe0 	ldr	x0, [sp, #88]
   805cc:	91001000 	add	x0, x0, #0x4
   805d0:	f9002fe0 	str	x0, [sp, #88]
            char *name = (char *)dt_strings_ptr + uint32_endian_big2little(*(uint32_t *)pointer); // get ptr to name
   805d4:	f9402fe0 	ldr	x0, [sp, #88]
   805d8:	b9400000 	ldr	w0, [x0]
   805dc:	97ffff56 	bl	80334 <uint32_endian_big2little>
   805e0:	2a0003e0 	mov	w0, w0
   805e4:	f9401fe1 	ldr	x1, [sp, #56]
   805e8:	8b000020 	add	x0, x1, x0
   805ec:	f90013e0 	str	x0, [sp, #32]
            pointer += 4;
   805f0:	f9402fe0 	ldr	x0, [sp, #88]
   805f4:	91001000 	add	x0, x0, #0x4
   805f8:	f9002fe0 	str	x0, [sp, #88]
            callback(token_type, name, pointer, len);
   805fc:	f9400be4 	ldr	x4, [sp, #16]
   80600:	b9402be3 	ldr	w3, [sp, #40]
   80604:	f9402fe2 	ldr	x2, [sp, #88]
   80608:	f94013e1 	ldr	x1, [sp, #32]
   8060c:	b9402fe0 	ldr	w0, [sp, #44]
   80610:	d63f0080 	blr	x4
            pointer += len;
   80614:	b9402be0 	ldr	w0, [sp, #40]
   80618:	f9402fe1 	ldr	x1, [sp, #88]
   8061c:	8b000020 	add	x0, x1, x0
   80620:	f9002fe0 	str	x0, [sp, #88]

            // since len might not be multiple of 4, check align
            if ((unsigned long long)pointer % 4 != 0) {
   80624:	f9402fe0 	ldr	x0, [sp, #88]
   80628:	92400400 	and	x0, x0, #0x3
   8062c:	f100001f 	cmp	x0, #0x0
   80630:	54000440 	b.eq	806b8 <traverse_device_tree+0x258>  // b.none
                pointer += 4 - (unsigned long long)pointer % 4;
   80634:	f9402fe0 	ldr	x0, [sp, #88]
   80638:	92400400 	and	x0, x0, #0x3
   8063c:	d2800081 	mov	x1, #0x4                   	// #4
   80640:	cb000020 	sub	x0, x1, x0
   80644:	f9402fe1 	ldr	x1, [sp, #88]
   80648:	8b000020 	add	x0, x1, x0
   8064c:	f9002fe0 	str	x0, [sp, #88]
   80650:	1400001a 	b	806b8 <traverse_device_tree+0x258>
            }
        }

        // if current node is NOP
        else if (token_type == FDT_NOP) {
   80654:	b9402fe0 	ldr	w0, [sp, #44]
   80658:	7100101f 	cmp	w0, #0x4
   8065c:	54000101 	b.ne	8067c <traverse_device_tree+0x21c>  // b.any
            callback(token_type, 0, 0, 0);
   80660:	f9400be4 	ldr	x4, [sp, #16]
   80664:	52800003 	mov	w3, #0x0                   	// #0
   80668:	d2800002 	mov	x2, #0x0                   	// #0
   8066c:	d2800001 	mov	x1, #0x0                   	// #0
   80670:	b9402fe0 	ldr	w0, [sp, #44]
   80674:	d63f0080 	blr	x4
   80678:	14000010 	b	806b8 <traverse_device_tree+0x258>
        }

        // if current node is END
        else if (token_type == FDT_END) {
   8067c:	b9402fe0 	ldr	w0, [sp, #44]
   80680:	7100241f 	cmp	w0, #0x9
   80684:	54000101 	b.ne	806a4 <traverse_device_tree+0x244>  // b.any
            callback(token_type, 0, 0, 0);
   80688:	f9400be4 	ldr	x4, [sp, #16]
   8068c:	52800003 	mov	w3, #0x0                   	// #0
   80690:	d2800002 	mov	x2, #0x0                   	// #0
   80694:	d2800001 	mov	x1, #0x0                   	// #0
   80698:	b9402fe0 	ldr	w0, [sp, #44]
   8069c:	d63f0080 	blr	x4
   806a0:	14000006 	b	806b8 <traverse_device_tree+0x258>
        }

        // if current node undefinded
        else {
            uart_sendline("error type: %x\n", token_type);
   806a4:	b9402fe1 	ldr	w1, [sp, #44]
   806a8:	d0000020 	adrp	x0, 86000 <el1t_irq_invalid+0x78>
   806ac:	910be000 	add	x0, x0, #0x2f8
   806b0:	9400120e 	bl	84ee8 <uart_sendline>
            return;
   806b4:	14000005 	b	806c8 <traverse_device_tree+0x268>
    while (pointer < end) {
   806b8:	f9402fe1 	ldr	x1, [sp, #88]
   806bc:	f9401be0 	ldr	x0, [sp, #48]
   806c0:	eb00003f 	cmp	x1, x0
   806c4:	54fff243 	b.cc	8050c <traverse_device_tree+0xac>  // b.lo, b.ul, b.last
        }
    }
}
   806c8:	a8c67bfd 	ldp	x29, x30, [sp], #96
   806cc:	d65f03c0 	ret

00000000000806d0 <dtb_callback_show_tree>:

void dtb_callback_show_tree(uint32_t node_type, char *name, void *value, uint32_t name_size) {
   806d0:	a9bc7bfd 	stp	x29, x30, [sp, #-64]!
   806d4:	910003fd 	mov	x29, sp
   806d8:	b9002fe0 	str	w0, [sp, #44]
   806dc:	f90013e1 	str	x1, [sp, #32]
   806e0:	f9000fe2 	str	x2, [sp, #24]
   806e4:	b9002be3 	str	w3, [sp, #40]
    static int level = 0; // tabs depth
    if (node_type == FDT_BEGIN_NODE) {
   806e8:	b9402fe0 	ldr	w0, [sp, #44]
   806ec:	7100041f 	cmp	w0, #0x1
   806f0:	54000361 	b.ne	8075c <dtb_callback_show_tree+0x8c>  // b.any
        for (int i = 0; i < level; i++) { // print tabs
   806f4:	b9003fff 	str	wzr, [sp, #60]
   806f8:	14000007 	b	80714 <dtb_callback_show_tree+0x44>
            uart_sendline("  ");
   806fc:	d0000020 	adrp	x0, 86000 <el1t_irq_invalid+0x78>
   80700:	910c2000 	add	x0, x0, #0x308
   80704:	940011f9 	bl	84ee8 <uart_sendline>
        for (int i = 0; i < level; i++) { // print tabs
   80708:	b9403fe0 	ldr	w0, [sp, #60]
   8070c:	11000400 	add	w0, w0, #0x1
   80710:	b9003fe0 	str	w0, [sp, #60]
   80714:	90000040 	adrp	x0, 88000 <cmd_list+0x980>
   80718:	9118e000 	add	x0, x0, #0x638
   8071c:	b9400000 	ldr	w0, [x0]
   80720:	b9403fe1 	ldr	w1, [sp, #60]
   80724:	6b00003f 	cmp	w1, w0
   80728:	54fffeab 	b.lt	806fc <dtb_callback_show_tree+0x2c>  // b.tstop
        }
        uart_sendline("%s{\n", name);
   8072c:	f94013e1 	ldr	x1, [sp, #32]
   80730:	d0000020 	adrp	x0, 86000 <el1t_irq_invalid+0x78>
   80734:	910c4000 	add	x0, x0, #0x310
   80738:	940011ec 	bl	84ee8 <uart_sendline>
        level++;
   8073c:	90000040 	adrp	x0, 88000 <cmd_list+0x980>
   80740:	9118e000 	add	x0, x0, #0x638
   80744:	b9400000 	ldr	w0, [x0]
   80748:	11000401 	add	w1, w0, #0x1
   8074c:	90000040 	adrp	x0, 88000 <cmd_list+0x980>
   80750:	9118e000 	add	x0, x0, #0x638
   80754:	b9000001 	str	w1, [x0]
        for (int i = 0; i < level; i++) {
            uart_sendline("  ");
        }
        uart_sendline("%s\n", name);
    }
}
   80758:	14000032 	b	80820 <dtb_callback_show_tree+0x150>
    } else if (node_type == FDT_END_NODE) {
   8075c:	b9402fe0 	ldr	w0, [sp, #44]
   80760:	7100081f 	cmp	w0, #0x2
   80764:	54000341 	b.ne	807cc <dtb_callback_show_tree+0xfc>  // b.any
        level--;
   80768:	90000040 	adrp	x0, 88000 <cmd_list+0x980>
   8076c:	9118e000 	add	x0, x0, #0x638
   80770:	b9400000 	ldr	w0, [x0]
   80774:	51000401 	sub	w1, w0, #0x1
   80778:	90000040 	adrp	x0, 88000 <cmd_list+0x980>
   8077c:	9118e000 	add	x0, x0, #0x638
   80780:	b9000001 	str	w1, [x0]
        for (int i = 0; i < level; i++) {
   80784:	b9003bff 	str	wzr, [sp, #56]
   80788:	14000007 	b	807a4 <dtb_callback_show_tree+0xd4>
            uart_sendline("  ");
   8078c:	d0000020 	adrp	x0, 86000 <el1t_irq_invalid+0x78>
   80790:	910c2000 	add	x0, x0, #0x308
   80794:	940011d5 	bl	84ee8 <uart_sendline>
        for (int i = 0; i < level; i++) {
   80798:	b9403be0 	ldr	w0, [sp, #56]
   8079c:	11000400 	add	w0, w0, #0x1
   807a0:	b9003be0 	str	w0, [sp, #56]
   807a4:	90000040 	adrp	x0, 88000 <cmd_list+0x980>
   807a8:	9118e000 	add	x0, x0, #0x638
   807ac:	b9400000 	ldr	w0, [x0]
   807b0:	b9403be1 	ldr	w1, [sp, #56]
   807b4:	6b00003f 	cmp	w1, w0
   807b8:	54fffeab 	b.lt	8078c <dtb_callback_show_tree+0xbc>  // b.tstop
        uart_sendline("}\n");
   807bc:	d0000020 	adrp	x0, 86000 <el1t_irq_invalid+0x78>
   807c0:	910c6000 	add	x0, x0, #0x318
   807c4:	940011c9 	bl	84ee8 <uart_sendline>
}
   807c8:	14000016 	b	80820 <dtb_callback_show_tree+0x150>
    } else if (node_type == FDT_PROP) {
   807cc:	b9402fe0 	ldr	w0, [sp, #44]
   807d0:	71000c1f 	cmp	w0, #0x3
   807d4:	54000261 	b.ne	80820 <dtb_callback_show_tree+0x150>  // b.any
        for (int i = 0; i < level; i++) {
   807d8:	b90037ff 	str	wzr, [sp, #52]
   807dc:	14000007 	b	807f8 <dtb_callback_show_tree+0x128>
            uart_sendline("  ");
   807e0:	d0000020 	adrp	x0, 86000 <el1t_irq_invalid+0x78>
   807e4:	910c2000 	add	x0, x0, #0x308
   807e8:	940011c0 	bl	84ee8 <uart_sendline>
        for (int i = 0; i < level; i++) {
   807ec:	b94037e0 	ldr	w0, [sp, #52]
   807f0:	11000400 	add	w0, w0, #0x1
   807f4:	b90037e0 	str	w0, [sp, #52]
   807f8:	90000040 	adrp	x0, 88000 <cmd_list+0x980>
   807fc:	9118e000 	add	x0, x0, #0x638
   80800:	b9400000 	ldr	w0, [x0]
   80804:	b94037e1 	ldr	w1, [sp, #52]
   80808:	6b00003f 	cmp	w1, w0
   8080c:	54fffeab 	b.lt	807e0 <dtb_callback_show_tree+0x110>  // b.tstop
        uart_sendline("%s\n", name);
   80810:	f94013e1 	ldr	x1, [sp, #32]
   80814:	d0000020 	adrp	x0, 86000 <el1t_irq_invalid+0x78>
   80818:	910c8000 	add	x0, x0, #0x320
   8081c:	940011b3 	bl	84ee8 <uart_sendline>
}
   80820:	d503201f 	nop
   80824:	a8c47bfd 	ldp	x29, x30, [sp], #64
   80828:	d65f03c0 	ret

000000000008082c <dtb_callback_initramfs>:

void dtb_callback_initramfs(uint32_t node_type, char *name, void *value, uint32_t name_size) {
   8082c:	a9bd7bfd 	stp	x29, x30, [sp, #-48]!
   80830:	910003fd 	mov	x29, sp
   80834:	b9002fe0 	str	w0, [sp, #44]
   80838:	f90013e1 	str	x1, [sp, #32]
   8083c:	f9000fe2 	str	x2, [sp, #24]
   80840:	b9002be3 	str	w3, [sp, #40]
    // https://github.com/stweil/raspberrypi-documentation/blob/master/configuration/device-tree.md
    // linux,initrd-start will be assigned by start.elf based on config.txt
    if (node_type == FDT_PROP && strcmp(name, "linux,initrd-start") == 0) {
   80844:	b9402fe0 	ldr	w0, [sp, #44]
   80848:	71000c1f 	cmp	w0, #0x3
   8084c:	540001e1 	b.ne	80888 <dtb_callback_initramfs+0x5c>  // b.any
   80850:	d0000020 	adrp	x0, 86000 <el1t_irq_invalid+0x78>
   80854:	910ca001 	add	x1, x0, #0x328
   80858:	f94013e0 	ldr	x0, [sp, #32]
   8085c:	94000fe4 	bl	847ec <strcmp>
   80860:	7100001f 	cmp	w0, #0x0
   80864:	54000121 	b.ne	80888 <dtb_callback_initramfs+0x5c>  // b.any
        // get initramfs's address, then store it into CPIO_DEFAULT_START
        CPIO_DEFAULT_START = (void *)(unsigned long long)uint32_endian_big2little(*(uint32_t *)value);
   80868:	f9400fe0 	ldr	x0, [sp, #24]
   8086c:	b9400000 	ldr	w0, [x0]
   80870:	97fffeb1 	bl	80334 <uint32_endian_big2little>
   80874:	2a0003e0 	mov	w0, w0
   80878:	aa0003e1 	mov	x1, x0
   8087c:	90000040 	adrp	x0, 88000 <cmd_list+0x980>
   80880:	f942f800 	ldr	x0, [x0, #1520]
   80884:	f9000001 	str	x1, [x0]
    }
    if (node_type == FDT_PROP && strcmp(name, "linux,initrd-end") == 0) {
   80888:	b9402fe0 	ldr	w0, [sp, #44]
   8088c:	71000c1f 	cmp	w0, #0x3
   80890:	540001e1 	b.ne	808cc <dtb_callback_initramfs+0xa0>  // b.any
   80894:	d0000020 	adrp	x0, 86000 <el1t_irq_invalid+0x78>
   80898:	910d0001 	add	x1, x0, #0x340
   8089c:	f94013e0 	ldr	x0, [sp, #32]
   808a0:	94000fd3 	bl	847ec <strcmp>
   808a4:	7100001f 	cmp	w0, #0x0
   808a8:	54000121 	b.ne	808cc <dtb_callback_initramfs+0xa0>  // b.any
        CPIO_DEFAULT_END = (void *)(unsigned long long)uint32_endian_big2little(*(uint32_t *)value);
   808ac:	f9400fe0 	ldr	x0, [sp, #24]
   808b0:	b9400000 	ldr	w0, [x0]
   808b4:	97fffea0 	bl	80334 <uint32_endian_big2little>
   808b8:	2a0003e0 	mov	w0, w0
   808bc:	aa0003e1 	mov	x1, x0
   808c0:	90000040 	adrp	x0, 88000 <cmd_list+0x980>
   808c4:	f942e800 	ldr	x0, [x0, #1488]
   808c8:	f9000001 	str	x1, [x0]
    }
}
   808cc:	d503201f 	nop
   808d0:	a8c37bfd 	ldp	x29, x30, [sp], #48
   808d4:	d65f03c0 	ret

00000000000808d8 <dtb_get_reserved_memory>:

void dtb_get_reserved_memory() {
   808d8:	a9bb7bfd 	stp	x29, x30, [sp, #-80]!
   808dc:	910003fd 	mov	x29, sp
   808e0:	a90153f3 	stp	x19, x20, [sp, #16]
    struct fdt_header *ptr = (struct fdt_header *)dtb_ptr;
   808e4:	90000040 	adrp	x0, 88000 <cmd_list+0x980>
   808e8:	9118c000 	add	x0, x0, #0x630
   808ec:	f9400000 	ldr	x0, [x0]
   808f0:	f90023e0 	str	x0, [sp, #64]

    if (uint32_endian_big2little(ptr->magic) != 0xD00DFEED) {
   808f4:	f94023e0 	ldr	x0, [sp, #64]
   808f8:	b9400000 	ldr	w0, [x0]
   808fc:	97fffe8e 	bl	80334 <uint32_endian_big2little>
   80900:	2a0003e1 	mov	w1, w0
   80904:	529fdda0 	mov	w0, #0xfeed                	// #65261
   80908:	72ba01a0 	movk	w0, #0xd00d, lsl #16
   8090c:	6b00003f 	cmp	w1, w0
   80910:	540000a0 	b.eq	80924 <dtb_get_reserved_memory+0x4c>  // b.none
        uart_sendline("Bad Magic.\n");
   80914:	d0000020 	adrp	x0, 86000 <el1t_irq_invalid+0x78>
   80918:	910d6000 	add	x0, x0, #0x358
   8091c:	94001173 	bl	84ee8 <uart_sendline>
        return;
   80920:	14000033 	b	809ec <dtb_get_reserved_memory+0x114>
    }

    // jump to 'reserve memory' section
    char *reserve_entry_ptr = ((char *)ptr + uint32_endian_big2little(ptr->off_mem_rsvmap));
   80924:	f94023e0 	ldr	x0, [sp, #64]
   80928:	b9401000 	ldr	w0, [x0, #16]
   8092c:	97fffe82 	bl	80334 <uint32_endian_big2little>
   80930:	2a0003e0 	mov	w0, w0
   80934:	f94023e1 	ldr	x1, [sp, #64]
   80938:	8b000020 	add	x0, x1, x0
   8093c:	f9001fe0 	str	x0, [sp, #56]
    struct fdt_reserve_entry *addr_ptr = (struct fdt_reserve_entry *)reserve_entry_ptr;
   80940:	f9401fe0 	ldr	x0, [sp, #56]
   80944:	f90027e0 	str	x0, [sp, #72]

    // reserve dtb-defined memory segment
    while (addr_ptr->address != 0 || addr_ptr->size != 0) {
   80948:	14000012 	b	80990 <dtb_get_reserved_memory+0xb8>
        unsigned long long start = uint64_endian_big2little(addr_ptr->address);
   8094c:	f94027e0 	ldr	x0, [sp, #72]
   80950:	f9400000 	ldr	x0, [x0]
   80954:	97fffe90 	bl	80394 <uint64_endian_big2little>
   80958:	f9001be0 	str	x0, [sp, #48]
        unsigned long long end = uint64_endian_big2little(addr_ptr->address + addr_ptr->size);
   8095c:	f94027e0 	ldr	x0, [sp, #72]
   80960:	f9400001 	ldr	x1, [x0]
   80964:	f94027e0 	ldr	x0, [sp, #72]
   80968:	f9400400 	ldr	x0, [x0, #8]
   8096c:	8b000020 	add	x0, x1, x0
   80970:	97fffe89 	bl	80394 <uint64_endian_big2little>
   80974:	f90017e0 	str	x0, [sp, #40]
        memory_reserve(start, end);
   80978:	f94017e1 	ldr	x1, [sp, #40]
   8097c:	f9401be0 	ldr	x0, [sp, #48]
   80980:	940004f7 	bl	81d5c <memory_reserve>
        addr_ptr++;
   80984:	f94027e0 	ldr	x0, [sp, #72]
   80988:	91004000 	add	x0, x0, #0x10
   8098c:	f90027e0 	str	x0, [sp, #72]
    while (addr_ptr->address != 0 || addr_ptr->size != 0) {
   80990:	f94027e0 	ldr	x0, [sp, #72]
   80994:	f9400000 	ldr	x0, [x0]
   80998:	f100001f 	cmp	x0, #0x0
   8099c:	54fffd81 	b.ne	8094c <dtb_get_reserved_memory+0x74>  // b.any
   809a0:	f94027e0 	ldr	x0, [sp, #72]
   809a4:	f9400400 	ldr	x0, [x0, #8]
   809a8:	f100001f 	cmp	x0, #0x0
   809ac:	54fffd01 	b.ne	8094c <dtb_get_reserved_memory+0x74>  // b.any
    }

    // reserve dtb itself
    memory_reserve((unsigned long long)dtb_ptr, (unsigned long long)(dtb_ptr + uint32_endian_big2little(ptr->total_size)));
   809b0:	90000040 	adrp	x0, 88000 <cmd_list+0x980>
   809b4:	9118c000 	add	x0, x0, #0x630
   809b8:	f9400000 	ldr	x0, [x0]
   809bc:	aa0003f4 	mov	x20, x0
   809c0:	90000040 	adrp	x0, 88000 <cmd_list+0x980>
   809c4:	9118c000 	add	x0, x0, #0x630
   809c8:	f9400013 	ldr	x19, [x0]
   809cc:	f94023e0 	ldr	x0, [sp, #64]
   809d0:	b9400400 	ldr	w0, [x0, #4]
   809d4:	97fffe58 	bl	80334 <uint32_endian_big2little>
   809d8:	2a0003e0 	mov	w0, w0
   809dc:	8b000260 	add	x0, x19, x0
   809e0:	aa0003e1 	mov	x1, x0
   809e4:	aa1403e0 	mov	x0, x20
   809e8:	940004dd 	bl	81d5c <memory_reserve>
   809ec:	a94153f3 	ldp	x19, x20, [sp, #16]
   809f0:	a8c57bfd 	ldp	x29, x30, [sp], #80
   809f4:	d65f03c0 	ret

00000000000809f8 <lock>:
#include "uart1.h"

irq_node *irq_head; // head is empty, every node come after head
extern thread *run_queue;

void lock() {
   809f8:	a9bf7bfd 	stp	x29, x30, [sp, #-16]!
   809fc:	910003fd 	mov	x29, sp
    el1_interrupt_disable();
   80a00:	940000e7 	bl	80d9c <el1_interrupt_disable>
}
   80a04:	d503201f 	nop
   80a08:	a8c17bfd 	ldp	x29, x30, [sp], #16
   80a0c:	d65f03c0 	ret

0000000000080a10 <unlock>:

void unlock() {
   80a10:	a9bf7bfd 	stp	x29, x30, [sp, #-16]!
   80a14:	910003fd 	mov	x29, sp
    el1_interrupt_enable();
   80a18:	940000de 	bl	80d90 <el1_interrupt_enable>
}
   80a1c:	d503201f 	nop
   80a20:	a8c17bfd 	ldp	x29, x30, [sp], #16
   80a24:	d65f03c0 	ret

0000000000080a28 <el0_sync_router>:

void el0_sync_router(trap_frame *tpf) {
   80a28:	a9bd7bfd 	stp	x29, x30, [sp, #-48]!
   80a2c:	910003fd 	mov	x29, sp
   80a30:	f9000fe0 	str	x0, [sp, #24]
    // unsigned long long esrel1;
    // asm volatile("mrs %0, esr_el1" : "=r"(esrel1));
    // uart_sendline("spsr_el1: %x, elr_el1: %x, esr_el1: %x\n", spsrel1, elrel1, esrel1);
    // return;

    el1_interrupt_enable();
   80a34:	940000d7 	bl	80d90 <el1_interrupt_enable>
    int syscall_no = tpf->x8;
   80a38:	f9400fe0 	ldr	x0, [sp, #24]
   80a3c:	f9402000 	ldr	x0, [x0, #64]
   80a40:	b9002fe0 	str	w0, [sp, #44]
    // uart_sendline("syscall: %d\n", syscall_no);
    switch (syscall_no) {
   80a44:	b9402fe0 	ldr	w0, [sp, #44]
   80a48:	71001c1f 	cmp	w0, #0x7
   80a4c:	54000b20 	b.eq	80bb0 <el0_sync_router+0x188>  // b.none
   80a50:	b9402fe0 	ldr	w0, [sp, #44]
   80a54:	71001c1f 	cmp	w0, #0x7
   80a58:	54000b8c 	b.gt	80bc8 <el0_sync_router+0x1a0>
   80a5c:	b9402fe0 	ldr	w0, [sp, #44]
   80a60:	7100181f 	cmp	w0, #0x6
   80a64:	54000940 	b.eq	80b8c <el0_sync_router+0x164>  // b.none
   80a68:	b9402fe0 	ldr	w0, [sp, #44]
   80a6c:	7100181f 	cmp	w0, #0x6
   80a70:	54000acc 	b.gt	80bc8 <el0_sync_router+0x1a0>
   80a74:	b9402fe0 	ldr	w0, [sp, #44]
   80a78:	7100141f 	cmp	w0, #0x5
   80a7c:	540007c0 	b.eq	80b74 <el0_sync_router+0x14c>  // b.none
   80a80:	b9402fe0 	ldr	w0, [sp, #44]
   80a84:	7100141f 	cmp	w0, #0x5
   80a88:	54000a0c 	b.gt	80bc8 <el0_sync_router+0x1a0>
   80a8c:	b9402fe0 	ldr	w0, [sp, #44]
   80a90:	7100101f 	cmp	w0, #0x4
   80a94:	540006a0 	b.eq	80b68 <el0_sync_router+0x140>  // b.none
   80a98:	b9402fe0 	ldr	w0, [sp, #44]
   80a9c:	7100101f 	cmp	w0, #0x4
   80aa0:	5400094c 	b.gt	80bc8 <el0_sync_router+0x1a0>
   80aa4:	b9402fe0 	ldr	w0, [sp, #44]
   80aa8:	71000c1f 	cmp	w0, #0x3
   80aac:	540004c0 	b.eq	80b44 <el0_sync_router+0x11c>  // b.none
   80ab0:	b9402fe0 	ldr	w0, [sp, #44]
   80ab4:	71000c1f 	cmp	w0, #0x3
   80ab8:	5400088c 	b.gt	80bc8 <el0_sync_router+0x1a0>
   80abc:	b9402fe0 	ldr	w0, [sp, #44]
   80ac0:	7100081f 	cmp	w0, #0x2
   80ac4:	540002e0 	b.eq	80b20 <el0_sync_router+0xf8>  // b.none
   80ac8:	b9402fe0 	ldr	w0, [sp, #44]
   80acc:	7100081f 	cmp	w0, #0x2
   80ad0:	540007cc 	b.gt	80bc8 <el0_sync_router+0x1a0>
   80ad4:	b9402fe0 	ldr	w0, [sp, #44]
   80ad8:	7100001f 	cmp	w0, #0x0
   80adc:	540000a0 	b.eq	80af0 <el0_sync_router+0xc8>  // b.none
   80ae0:	b9402fe0 	ldr	w0, [sp, #44]
   80ae4:	7100041f 	cmp	w0, #0x1
   80ae8:	540000a0 	b.eq	80afc <el0_sync_router+0xd4>  // b.none
   80aec:	14000037 	b	80bc8 <el0_sync_router+0x1a0>
    case 0:
        getpid(tpf);
   80af0:	f9400fe0 	ldr	x0, [sp, #24]
   80af4:	94000969 	bl	83098 <getpid>
        break;
   80af8:	14000038 	b	80bd8 <el0_sync_router+0x1b0>
    case 1:
        // user have to allocate spaces to x0(buf) theirself
        uart_read(tpf, (char *)tpf->x0, tpf->x1);
   80afc:	f9400fe0 	ldr	x0, [sp, #24]
   80b00:	f9400000 	ldr	x0, [x0]
   80b04:	aa0003e1 	mov	x1, x0
   80b08:	f9400fe0 	ldr	x0, [sp, #24]
   80b0c:	f9400400 	ldr	x0, [x0, #8]
   80b10:	aa0003e2 	mov	x2, x0
   80b14:	f9400fe0 	ldr	x0, [sp, #24]
   80b18:	9400096f 	bl	830d4 <uart_read>
        break;
   80b1c:	1400002f 	b	80bd8 <el0_sync_router+0x1b0>
    case 2:
        uart_write(tpf, (char *)tpf->x0, tpf->x1);
   80b20:	f9400fe0 	ldr	x0, [sp, #24]
   80b24:	f9400000 	ldr	x0, [x0]
   80b28:	aa0003e1 	mov	x1, x0
   80b2c:	f9400fe0 	ldr	x0, [sp, #24]
   80b30:	f9400400 	ldr	x0, [x0, #8]
   80b34:	aa0003e2 	mov	x2, x0
   80b38:	f9400fe0 	ldr	x0, [sp, #24]
   80b3c:	94000982 	bl	83144 <uart_write>
        break;
   80b40:	14000026 	b	80bd8 <el0_sync_router+0x1b0>
    case 3:
        exec(tpf, (char *)tpf->x0, (char **)tpf->x1);
   80b44:	f9400fe0 	ldr	x0, [sp, #24]
   80b48:	f9400000 	ldr	x0, [x0]
   80b4c:	aa0003e1 	mov	x1, x0
   80b50:	f9400fe0 	ldr	x0, [sp, #24]
   80b54:	f9400400 	ldr	x0, [x0, #8]
   80b58:	aa0003e2 	mov	x2, x0
   80b5c:	f9400fe0 	ldr	x0, [sp, #24]
   80b60:	94000992 	bl	831a8 <exec>
        break;
   80b64:	1400001d 	b	80bd8 <el0_sync_router+0x1b0>
    case 4:
        fork(tpf);
   80b68:	f9400fe0 	ldr	x0, [sp, #24]
   80b6c:	940009be 	bl	83264 <fork>
        break;
   80b70:	1400001a 	b	80bd8 <el0_sync_router+0x1b0>
    case 5:
        exit(tpf, tpf->x0);
   80b74:	f9400fe0 	ldr	x0, [sp, #24]
   80b78:	f9400000 	ldr	x0, [x0]
   80b7c:	2a0003e1 	mov	w1, w0
   80b80:	f9400fe0 	ldr	x0, [sp, #24]
   80b84:	94000a32 	bl	8344c <exit>
        break;
   80b88:	14000014 	b	80bd8 <el0_sync_router+0x1b0>
    case 6:
        mbox_call(tpf, (unsigned char)tpf->x0, (unsigned int *)tpf->x1);
   80b8c:	f9400fe0 	ldr	x0, [sp, #24]
   80b90:	f9400000 	ldr	x0, [x0]
   80b94:	12001c01 	and	w1, w0, #0xff
   80b98:	f9400fe0 	ldr	x0, [sp, #24]
   80b9c:	f9400400 	ldr	x0, [x0, #8]
   80ba0:	aa0003e2 	mov	x2, x0
   80ba4:	f9400fe0 	ldr	x0, [sp, #24]
   80ba8:	94000a31 	bl	8346c <mbox_call>
        break;
   80bac:	1400000b 	b	80bd8 <el0_sync_router+0x1b0>
    case 7:
        kill(tpf, tpf->x0);
   80bb0:	f9400fe0 	ldr	x0, [sp, #24]
   80bb4:	f9400000 	ldr	x0, [x0]
   80bb8:	2a0003e1 	mov	w1, w0
   80bbc:	f9400fe0 	ldr	x0, [sp, #24]
   80bc0:	94000a60 	bl	83540 <kill>
        break;
   80bc4:	14000005 	b	80bd8 <el0_sync_router+0x1b0>
    default:
        uart_sendline("Invalid System Call Number\n");
   80bc8:	d0000020 	adrp	x0, 86000 <el1t_irq_invalid+0x78>
   80bcc:	910da000 	add	x0, x0, #0x368
   80bd0:	940010c6 	bl	84ee8 <uart_sendline>
    }
    // uart_sendline("syscall end\n");
}
   80bd4:	d503201f 	nop
   80bd8:	d503201f 	nop
   80bdc:	a8c37bfd 	ldp	x29, x30, [sp], #48
   80be0:	d65f03c0 	ret

0000000000080be4 <el1h_irq_router>:

void el1h_irq_router() {
   80be4:	a9bf7bfd 	stp	x29, x30, [sp, #-16]!
   80be8:	910003fd 	mov	x29, sp
    // uart
    if (*IRQ_PENDING_1 & (1 << 29)) {
   80bec:	d2964080 	mov	x0, #0xb204                	// #45572
   80bf0:	f2a7e000 	movk	x0, #0x3f00, lsl #16
   80bf4:	b9400000 	ldr	w0, [x0]
   80bf8:	12030000 	and	w0, w0, #0x20000000
   80bfc:	7100001f 	cmp	w0, #0x0
   80c00:	540002c0 	b.eq	80c58 <el1h_irq_router+0x74>  // b.none
        switch (*AUX_MU_IIR_REG & 0x6) {
   80c04:	d28a0900 	mov	x0, #0x5048                	// #20552
   80c08:	f2a7e420 	movk	x0, #0x3f21, lsl #16
   80c0c:	b9400000 	ldr	w0, [x0]
   80c10:	121f0400 	and	w0, w0, #0x6
   80c14:	7100081f 	cmp	w0, #0x2
   80c18:	54000080 	b.eq	80c28 <el1h_irq_router+0x44>  // b.none
   80c1c:	7100101f 	cmp	w0, #0x4
   80c20:	54000100 	b.eq	80c40 <el1h_irq_router+0x5c>  // b.none
        timer_enable_interrupt();
        // at least two thread running -> schedule for any timer irq
        if (run_queue->next->next != run_queue)
            schedule();
    }
}
   80c24:	14000025 	b	80cb8 <el1h_irq_router+0xd4>
            uart_tx_irq_disable();
   80c28:	940011a7 	bl	852c4 <uart_tx_irq_disable>
            add_irq_task(uart_tx_irq_handler, UART_IRQ_PRIORITY);
   80c2c:	52800021 	mov	w1, #0x1                   	// #1
   80c30:	90000040 	adrp	x0, 88000 <cmd_list+0x980>
   80c34:	f942d800 	ldr	x0, [x0, #1456]
   80c38:	9400005c 	bl	80da8 <add_irq_task>
            break;
   80c3c:	1400001f 	b	80cb8 <el1h_irq_router+0xd4>
            uart_rx_irq_disable();
   80c40:	9400118f 	bl	8527c <uart_rx_irq_disable>
            add_irq_task(uart_rx_irq_handler, UART_IRQ_PRIORITY);
   80c44:	52800021 	mov	w1, #0x1                   	// #1
   80c48:	90000040 	adrp	x0, 88000 <cmd_list+0x980>
   80c4c:	f942dc00 	ldr	x0, [x0, #1464]
   80c50:	94000056 	bl	80da8 <add_irq_task>
            break;
   80c54:	14000019 	b	80cb8 <el1h_irq_router+0xd4>
    else if (*CORE0_INTERRUPT_SOURCE & 0x2) {
   80c58:	d2800c00 	mov	x0, #0x60                  	// #96
   80c5c:	f2a80000 	movk	x0, #0x4000, lsl #16
   80c60:	b9400000 	ldr	w0, [x0]
   80c64:	121f0000 	and	w0, w0, #0x2
   80c68:	7100001f 	cmp	w0, #0x0
   80c6c:	54000260 	b.eq	80cb8 <el1h_irq_router+0xd4>  // b.none
        timer_disable_interrupt();
   80c70:	94000c7e 	bl	83e68 <timer_disable_interrupt>
        add_irq_task(timer_handler, TIMER_IRQ_PRIORITY);
   80c74:	52800001 	mov	w1, #0x0                   	// #0
   80c78:	90000040 	adrp	x0, 88000 <cmd_list+0x980>
   80c7c:	f942d400 	ldr	x0, [x0, #1448]
   80c80:	9400004a 	bl	80da8 <add_irq_task>
        timer_enable_interrupt();
   80c84:	94000c75 	bl	83e58 <timer_enable_interrupt>
        if (run_queue->next->next != run_queue)
   80c88:	90000040 	adrp	x0, 88000 <cmd_list+0x980>
   80c8c:	f942c800 	ldr	x0, [x0, #1424]
   80c90:	f9400000 	ldr	x0, [x0]
   80c94:	f9400000 	ldr	x0, [x0]
   80c98:	f9400001 	ldr	x1, [x0]
   80c9c:	90000040 	adrp	x0, 88000 <cmd_list+0x980>
   80ca0:	f942c800 	ldr	x0, [x0, #1424]
   80ca4:	f9400000 	ldr	x0, [x0]
   80ca8:	eb00003f 	cmp	x1, x0
   80cac:	54000060 	b.eq	80cb8 <el1h_irq_router+0xd4>  // b.none
            schedule();
   80cb0:	94000b5d 	bl	83a24 <schedule>
}
   80cb4:	14000001 	b	80cb8 <el1h_irq_router+0xd4>
   80cb8:	d503201f 	nop
   80cbc:	a8c17bfd 	ldp	x29, x30, [sp], #16
   80cc0:	d65f03c0 	ret

0000000000080cc4 <invalid_exception_router>:

void invalid_exception_router() {
   80cc4:	a9bf7bfd 	stp	x29, x30, [sp, #-16]!
   80cc8:	910003fd 	mov	x29, sp
    uart_sendline("invalid exception !\n");
   80ccc:	d0000020 	adrp	x0, 86000 <el1t_irq_invalid+0x78>
   80cd0:	910e2000 	add	x0, x0, #0x388
   80cd4:	94001085 	bl	84ee8 <uart_sendline>
    while (1) {};
   80cd8:	14000000 	b	80cd8 <invalid_exception_router+0x14>

0000000000080cdc <irqtask_list_init>:
}

/* implement preemption */
void irqtask_list_init() {
   80cdc:	a9bf7bfd 	stp	x29, x30, [sp, #-16]!
   80ce0:	910003fd 	mov	x29, sp
    irq_head = simple_malloc(sizeof(irq_node));
   80ce4:	52800400 	mov	w0, #0x20                  	// #32
   80ce8:	940000f1 	bl	810ac <simple_malloc>
   80cec:	aa0003e1 	mov	x1, x0
   80cf0:	90000040 	adrp	x0, 88000 <cmd_list+0x980>
   80cf4:	91190000 	add	x0, x0, #0x640
   80cf8:	f9000001 	str	x1, [x0]
    irq_head->next = irq_head;
   80cfc:	90000040 	adrp	x0, 88000 <cmd_list+0x980>
   80d00:	91190000 	add	x0, x0, #0x640
   80d04:	f9400000 	ldr	x0, [x0]
   80d08:	90000041 	adrp	x1, 88000 <cmd_list+0x980>
   80d0c:	91190021 	add	x1, x1, #0x640
   80d10:	f9400021 	ldr	x1, [x1]
   80d14:	f9000401 	str	x1, [x0, #8]
    irq_head->prev = irq_head;
   80d18:	90000040 	adrp	x0, 88000 <cmd_list+0x980>
   80d1c:	91190000 	add	x0, x0, #0x640
   80d20:	f9400000 	ldr	x0, [x0]
   80d24:	90000041 	adrp	x1, 88000 <cmd_list+0x980>
   80d28:	91190021 	add	x1, x1, #0x640
   80d2c:	f9400021 	ldr	x1, [x1]
   80d30:	f9000001 	str	x1, [x0]
}
   80d34:	d503201f 	nop
   80d38:	a8c17bfd 	ldp	x29, x30, [sp], #16
   80d3c:	d65f03c0 	ret

0000000000080d40 <irq_list_insert_front>:

void irq_list_insert_front(irq_node *node, irq_node *it) {
   80d40:	d10043ff 	sub	sp, sp, #0x10
   80d44:	f90007e0 	str	x0, [sp, #8]
   80d48:	f90003e1 	str	x1, [sp]
    node->prev = it->prev;
   80d4c:	f94003e0 	ldr	x0, [sp]
   80d50:	f9400001 	ldr	x1, [x0]
   80d54:	f94007e0 	ldr	x0, [sp, #8]
   80d58:	f9000001 	str	x1, [x0]
    node->next = it;
   80d5c:	f94007e0 	ldr	x0, [sp, #8]
   80d60:	f94003e1 	ldr	x1, [sp]
   80d64:	f9000401 	str	x1, [x0, #8]
    it->prev->next = node;
   80d68:	f94003e0 	ldr	x0, [sp]
   80d6c:	f9400000 	ldr	x0, [x0]
   80d70:	f94007e1 	ldr	x1, [sp, #8]
   80d74:	f9000401 	str	x1, [x0, #8]
    it->prev = node;
   80d78:	f94003e0 	ldr	x0, [sp]
   80d7c:	f94007e1 	ldr	x1, [sp, #8]
   80d80:	f9000001 	str	x1, [x0]
}
   80d84:	d503201f 	nop
   80d88:	910043ff 	add	sp, sp, #0x10
   80d8c:	d65f03c0 	ret

0000000000080d90 <el1_interrupt_enable>:

void el1_interrupt_enable() {
    asm volatile("msr daifclr, 0xf"); // enable all interrupt, 0 is default enable
   80d90:	d5034fff 	msr	daifclr, #0xf
}
   80d94:	d503201f 	nop
   80d98:	d65f03c0 	ret

0000000000080d9c <el1_interrupt_disable>:

void el1_interrupt_disable() {
    asm volatile("msr daifset, 0xf"); // disable all interrupt, 1 is disable
   80d9c:	d5034fdf 	msr	daifset, #0xf
}
   80da0:	d503201f 	nop
   80da4:	d65f03c0 	ret

0000000000080da8 <add_irq_task>:

void add_irq_task(void *callback, unsigned priority) {
   80da8:	a9bc7bfd 	stp	x29, x30, [sp, #-64]!
   80dac:	910003fd 	mov	x29, sp
   80db0:	f9000fe0 	str	x0, [sp, #24]
   80db4:	b90017e1 	str	w1, [sp, #20]
    // init node
    irq_node *node = simple_malloc(sizeof(irq_node));
   80db8:	52800400 	mov	w0, #0x20                  	// #32
   80dbc:	940000bc 	bl	810ac <simple_malloc>
   80dc0:	f9001be0 	str	x0, [sp, #48]
    node->priority = priority;
   80dc4:	b94017e1 	ldr	w1, [sp, #20]
   80dc8:	f9401be0 	ldr	x0, [sp, #48]
   80dcc:	f9000801 	str	x1, [x0, #16]
    node->task_function = callback;
   80dd0:	f9401be0 	ldr	x0, [sp, #48]
   80dd4:	f9400fe1 	ldr	x1, [sp, #24]
   80dd8:	f9000c01 	str	x1, [x0, #24]

    // mask interrupt line
    el1_interrupt_disable();
   80ddc:	97fffff0 	bl	80d9c <el1_interrupt_disable>

    // insert node into list
    irq_node *it = irq_head->next;
   80de0:	90000040 	adrp	x0, 88000 <cmd_list+0x980>
   80de4:	91190000 	add	x0, x0, #0x640
   80de8:	f9400000 	ldr	x0, [x0]
   80dec:	f9400400 	ldr	x0, [x0, #8]
   80df0:	f9001fe0 	str	x0, [sp, #56]
    for (; it != irq_head; it = it->next) {
   80df4:	1400000e 	b	80e2c <add_irq_task+0x84>
        if (node->priority < it->priority) {
   80df8:	f9401be0 	ldr	x0, [sp, #48]
   80dfc:	f9400801 	ldr	x1, [x0, #16]
   80e00:	f9401fe0 	ldr	x0, [sp, #56]
   80e04:	f9400800 	ldr	x0, [x0, #16]
   80e08:	eb00003f 	cmp	x1, x0
   80e0c:	540000a2 	b.cs	80e20 <add_irq_task+0x78>  // b.hs, b.nlast
            irq_list_insert_front(node, it);
   80e10:	f9401fe1 	ldr	x1, [sp, #56]
   80e14:	f9401be0 	ldr	x0, [sp, #48]
   80e18:	97ffffca 	bl	80d40 <irq_list_insert_front>
            break;
   80e1c:	1400000a 	b	80e44 <add_irq_task+0x9c>
    for (; it != irq_head; it = it->next) {
   80e20:	f9401fe0 	ldr	x0, [sp, #56]
   80e24:	f9400400 	ldr	x0, [x0, #8]
   80e28:	f9001fe0 	str	x0, [sp, #56]
   80e2c:	90000040 	adrp	x0, 88000 <cmd_list+0x980>
   80e30:	91190000 	add	x0, x0, #0x640
   80e34:	f9400000 	ldr	x0, [x0]
   80e38:	f9401fe1 	ldr	x1, [sp, #56]
   80e3c:	eb00003f 	cmp	x1, x0
   80e40:	54fffdc1 	b.ne	80df8 <add_irq_task+0x50>  // b.any
        }
    }
    // if not inserted, add at last pos
    if (it == irq_head)
   80e44:	90000040 	adrp	x0, 88000 <cmd_list+0x980>
   80e48:	91190000 	add	x0, x0, #0x640
   80e4c:	f9400000 	ldr	x0, [x0]
   80e50:	f9401fe1 	ldr	x1, [sp, #56]
   80e54:	eb00003f 	cmp	x1, x0
   80e58:	54000081 	b.ne	80e68 <add_irq_task+0xc0>  // b.any
        irq_list_insert_front(node, it);
   80e5c:	f9401fe1 	ldr	x1, [sp, #56]
   80e60:	f9401be0 	ldr	x0, [sp, #48]
   80e64:	97ffffb7 	bl	80d40 <irq_list_insert_front>

    // unmask interrupt line
    el1_interrupt_enable();
   80e68:	97ffffca 	bl	80d90 <el1_interrupt_enable>

    // do the task
    while (irq_head->next != irq_head) {
   80e6c:	1400001e 	b	80ee4 <add_irq_task+0x13c>
            cause it may be compile into more then one line of asm
            if interrupt occur, boom
            !!!!! be careful using pointer !!!!!
        */

        el1_interrupt_disable();                    // disable interrupt
   80e70:	97ffffcb 	bl	80d9c <el1_interrupt_disable>
        void *task = irq_head->next->task_function; // copy task function
   80e74:	90000040 	adrp	x0, 88000 <cmd_list+0x980>
   80e78:	91190000 	add	x0, x0, #0x640
   80e7c:	f9400000 	ldr	x0, [x0]
   80e80:	f9400400 	ldr	x0, [x0, #8]
   80e84:	f9400c00 	ldr	x0, [x0, #24]
   80e88:	f90017e0 	str	x0, [sp, #40]
        // remove node
        irq_node *n = irq_head->next;
   80e8c:	90000040 	adrp	x0, 88000 <cmd_list+0x980>
   80e90:	91190000 	add	x0, x0, #0x640
   80e94:	f9400000 	ldr	x0, [x0]
   80e98:	f9400400 	ldr	x0, [x0, #8]
   80e9c:	f90013e0 	str	x0, [sp, #32]
        irq_head->next = n->next;
   80ea0:	90000040 	adrp	x0, 88000 <cmd_list+0x980>
   80ea4:	91190000 	add	x0, x0, #0x640
   80ea8:	f9400000 	ldr	x0, [x0]
   80eac:	f94013e1 	ldr	x1, [sp, #32]
   80eb0:	f9400421 	ldr	x1, [x1, #8]
   80eb4:	f9000401 	str	x1, [x0, #8]
        n->next->prev = irq_head;
   80eb8:	f94013e0 	ldr	x0, [sp, #32]
   80ebc:	f9400400 	ldr	x0, [x0, #8]
   80ec0:	90000041 	adrp	x1, 88000 <cmd_list+0x980>
   80ec4:	91190021 	add	x1, x1, #0x640
   80ec8:	f9400021 	ldr	x1, [x1]
   80ecc:	f9000001 	str	x1, [x0]
        free(n);
   80ed0:	f94013e0 	ldr	x0, [sp, #32]
   80ed4:	94000090 	bl	81114 <free>
        el1_interrupt_enable(); // enable interrupt
   80ed8:	97ffffae 	bl	80d90 <el1_interrupt_enable>

        // execute event with interrupt enabled
        ((void (*)())task)();
   80edc:	f94017e0 	ldr	x0, [sp, #40]
   80ee0:	d63f0000 	blr	x0
    while (irq_head->next != irq_head) {
   80ee4:	90000040 	adrp	x0, 88000 <cmd_list+0x980>
   80ee8:	91190000 	add	x0, x0, #0x640
   80eec:	f9400000 	ldr	x0, [x0]
   80ef0:	f9400401 	ldr	x1, [x0, #8]
   80ef4:	90000040 	adrp	x0, 88000 <cmd_list+0x980>
   80ef8:	91190000 	add	x0, x0, #0x640
   80efc:	f9400000 	ldr	x0, [x0]
   80f00:	eb00003f 	cmp	x1, x0
   80f04:	54fffb61 	b.ne	80e70 <add_irq_task+0xc8>  // b.any
    }
}
   80f08:	d503201f 	nop
   80f0c:	d503201f 	nop
   80f10:	a8c47bfd 	ldp	x29, x30, [sp], #64
   80f14:	d65f03c0 	ret

0000000000080f18 <getCurrentEL>:

int getCurrentEL() {
   80f18:	a9be7bfd 	stp	x29, x30, [sp, #-32]!
   80f1c:	910003fd 	mov	x29, sp
    // debug: check EL(exception level) by watch reg
    unsigned long el;
    asm volatile("mrs %0, CurrentEL" : "=r"(el));
   80f20:	d5384240 	mrs	x0, currentel
   80f24:	f9000fe0 	str	x0, [sp, #24]
    uart_sendline("Current EL is: ");
   80f28:	d0000020 	adrp	x0, 86000 <el1t_irq_invalid+0x78>
   80f2c:	910e8000 	add	x0, x0, #0x3a0
   80f30:	94000fee 	bl	84ee8 <uart_sendline>
    uart_2hex((el >> 2) & 3);
   80f34:	f9400fe0 	ldr	x0, [sp, #24]
   80f38:	d342fc00 	lsr	x0, x0, #2
   80f3c:	12000400 	and	w0, w0, #0x3
   80f40:	94000fc9 	bl	84e64 <uart_2hex>
    uart_sendline("\n");
   80f44:	d0000020 	adrp	x0, 86000 <el1t_irq_invalid+0x78>
   80f48:	910ec000 	add	x0, x0, #0x3b0
   80f4c:	94000fe7 	bl	84ee8 <uart_sendline>
    return ((el >> 2) & 3);
   80f50:	f9400fe0 	ldr	x0, [sp, #24]
   80f54:	d342fc00 	lsr	x0, x0, #2
   80f58:	12000400 	and	w0, w0, #0x3
   80f5c:	a8c27bfd 	ldp	x29, x30, [sp], #32
   80f60:	d65f03c0 	ret

0000000000080f64 <main>:
#include "uart1.h"

extern char *dtb_ptr;
char input_buffer[CMD_MAX_LEN];

void main(char *arg) {
   80f64:	a9be7bfd 	stp	x29, x30, [sp, #-32]!
   80f68:	910003fd 	mov	x29, sp
   80f6c:	f9000fe0 	str	x0, [sp, #24]
    // debug: check EL(exception level) by watch reg
    getCurrentEL();
   80f70:	97ffffea 	bl	80f18 <getCurrentEL>

    dtb_ptr = arg;
   80f74:	90000040 	adrp	x0, 88000 <cmd_list+0x980>
   80f78:	f942ec00 	ldr	x0, [x0, #1496]
   80f7c:	f9400fe1 	ldr	x1, [sp, #24]
   80f80:	f9000001 	str	x1, [x0]
    traverse_device_tree(dtb_ptr, dtb_callback_initramfs);
   80f84:	90000040 	adrp	x0, 88000 <cmd_list+0x980>
   80f88:	f942ec00 	ldr	x0, [x0, #1496]
   80f8c:	f9400002 	ldr	x2, [x0]
   80f90:	90000040 	adrp	x0, 88000 <cmd_list+0x980>
   80f94:	f942f401 	ldr	x1, [x0, #1512]
   80f98:	aa0203e0 	mov	x0, x2
   80f9c:	97fffd31 	bl	80460 <traverse_device_tree>

    timer_init_interrupt(); // basic 2, core timer interrupt
   80fa0:	94000b9b 	bl	83e0c <timer_init_interrupt>
    timer_list_init();      // advanced 1, timer multiplexing
   80fa4:	94000b6d 	bl	83d58 <timer_list_init>
    irqtask_list_init();    // advanced 2, concurrent IO handling
   80fa8:	97ffff4d 	bl	80cdc <irqtask_list_init>

    uart_init();
   80fac:	94000f21 	bl	84c30 <uart_init>
    uart_sendline("Loading dtb from: 0x%x\n", arg);
   80fb0:	f9400fe1 	ldr	x1, [sp, #24]
   80fb4:	d0000020 	adrp	x0, 86000 <el1t_irq_invalid+0x78>
   80fb8:	910ee000 	add	x0, x0, #0x3b8
   80fbc:	94000fcb 	bl	84ee8 <uart_sendline>
    cli_print_banner();
   80fc0:	9400057a 	bl	825a8 <cli_print_banner>

    allocator_init();
   80fc4:	9400006e 	bl	8117c <allocator_init>
    init_thread();
   80fc8:	940009da 	bl	83730 <init_thread>

    while (1) {
        cli_cmd_clear(input_buffer, CMD_MAX_LEN);
   80fcc:	52801001 	mov	w1, #0x80                  	// #128
   80fd0:	90000040 	adrp	x0, 88000 <cmd_list+0x980>
   80fd4:	91192000 	add	x0, x0, #0x648
   80fd8:	9400044e 	bl	82110 <cli_cmd_clear>
        uart_sendline("# ");
   80fdc:	d0000020 	adrp	x0, 86000 <el1t_irq_invalid+0x78>
   80fe0:	910f4000 	add	x0, x0, #0x3d0
   80fe4:	94000fc1 	bl	84ee8 <uart_sendline>
        cli_cmd_read(input_buffer);
   80fe8:	90000040 	adrp	x0, 88000 <cmd_list+0x980>
   80fec:	91192000 	add	x0, x0, #0x648
   80ff0:	9400045c 	bl	82160 <cli_cmd_read>
        cli_cmd_exec(input_buffer);
   80ff4:	90000040 	adrp	x0, 88000 <cmd_list+0x980>
   80ff8:	91192000 	add	x0, x0, #0x648
   80ffc:	9400048f 	bl	82238 <cli_cmd_exec>
        cli_cmd_clear(input_buffer, CMD_MAX_LEN);
   81000:	17fffff3 	b	80fcc <main+0x68>

0000000000081004 <k_mbox_call>:
#include "bcm2837/rpi_mbox.h"

/* Aligned to 16-byte boundary while we have 28-bits for VC */
volatile unsigned int __attribute__((aligned(16))) pt[64];

int k_mbox_call(mbox_channel_type channel, unsigned int value) {
   81004:	d10043ff 	sub	sp, sp, #0x10
   81008:	b9000fe0 	str	w0, [sp, #12]
   8100c:	b9000be1 	str	w1, [sp, #8]
    // add channel to lower 4 bit
    value &= ~(0xF);  // get front 28 bits
   81010:	b9400be0 	ldr	w0, [sp, #8]
   81014:	121c6c00 	and	w0, w0, #0xfffffff0
   81018:	b9000be0 	str	w0, [sp, #8]
    value |= channel; // combine with channel
   8101c:	b9400be1 	ldr	w1, [sp, #8]
   81020:	b9400fe0 	ldr	w0, [sp, #12]
   81024:	2a000020 	orr	w0, w1, w0
   81028:	b9000be0 	str	w0, [sp, #8]

    while ((*MBOX_STATUS & BCM_ARM_VC_MS_FULL) != 0) {} // wait until mail box not full
   8102c:	d503201f 	nop
   81030:	d2971300 	mov	x0, #0xb898                	// #47256
   81034:	f2a7e000 	movk	x0, #0x3f00, lsl #16
   81038:	b9400000 	ldr	w0, [x0]
   8103c:	7100001f 	cmp	w0, #0x0
   81040:	54ffff8b 	b.lt	81030 <k_mbox_call+0x2c>  // b.tstop
    *MBOX_WRITE = value;                                // write to reg
   81044:	d2971400 	mov	x0, #0xb8a0                	// #47264
   81048:	f2a7e000 	movk	x0, #0x3f00, lsl #16
   8104c:	b9400be1 	ldr	w1, [sp, #8]
   81050:	b9000001 	str	w1, [x0]

    // read content, check if is equal to the content just wrote
    while (1) {
        while (*MBOX_STATUS & BCM_ARM_VC_MS_EMPTY) {} // wait until mail box not empty
   81054:	d503201f 	nop
   81058:	d2971300 	mov	x0, #0xb898                	// #47256
   8105c:	f2a7e000 	movk	x0, #0x3f00, lsl #16
   81060:	b9400000 	ldr	w0, [x0]
   81064:	12020000 	and	w0, w0, #0x40000000
   81068:	7100001f 	cmp	w0, #0x0
   8106c:	54ffff61 	b.ne	81058 <k_mbox_call+0x54>  // b.any
        if (value == *MBOX_READ)                      // read from reg
   81070:	d2971000 	mov	x0, #0xb880                	// #47232
   81074:	f2a7e000 	movk	x0, #0x3f00, lsl #16
   81078:	b9400000 	ldr	w0, [x0]
   8107c:	b9400be1 	ldr	w1, [sp, #8]
   81080:	6b00003f 	cmp	w1, w0
   81084:	54fffe81 	b.ne	81054 <k_mbox_call+0x50>  // b.any
            return pt[1] == MBOX_REQUEST_SUCCEED;
   81088:	f0000020 	adrp	x0, 88000 <cmd_list+0x980>
   8108c:	911b4000 	add	x0, x0, #0x6d0
   81090:	b9400401 	ldr	w1, [x0, #4]
   81094:	52b00000 	mov	w0, #0x80000000            	// #-2147483648
   81098:	6b00003f 	cmp	w1, w0
   8109c:	1a9f17e0 	cset	w0, eq  // eq = none
   810a0:	12001c00 	and	w0, w0, #0xff
    }
    return 0;
   810a4:	910043ff 	add	sp, sp, #0x10
   810a8:	d65f03c0 	ret

00000000000810ac <simple_malloc>:

extern char _heap_top;
static char *htop_ptr = &_heap_top; // declare it "static" so it'll always
                                    // remember the last position

void *simple_malloc(unsigned int size) {
   810ac:	d10083ff 	sub	sp, sp, #0x20
   810b0:	b9000fe0 	str	w0, [sp, #12]
    // heap top ptr + 0x10 ~ heap top ptr + 0x10 * k:
    //              { heap_block }
    // -> heap top ptr

    // header
    char *r = htop_ptr + 0x10;
   810b4:	f0000020 	adrp	x0, 88000 <cmd_list+0x980>
   810b8:	91188000 	add	x0, x0, #0x620
   810bc:	f9400000 	ldr	x0, [x0]
   810c0:	91004000 	add	x0, x0, #0x10
   810c4:	f9000fe0 	str	x0, [sp, #24]

    // size padding align to heap_block header
    size = 0x10 + size - size % 0x10;
   810c8:	b9400fe0 	ldr	w0, [sp, #12]
   810cc:	121c6c00 	and	w0, w0, #0xfffffff0
   810d0:	11004000 	add	w0, w0, #0x10
   810d4:	b9000fe0 	str	w0, [sp, #12]
    // recode the size of space allocated at 0x8 byte before content(heap_block)
    *(unsigned int *)(r - 0x8) = size;
   810d8:	f9400fe0 	ldr	x0, [sp, #24]
   810dc:	d1002000 	sub	x0, x0, #0x8
   810e0:	b9400fe1 	ldr	w1, [sp, #12]
   810e4:	b9000001 	str	w1, [x0]
    // mov heap top
    htop_ptr += size;
   810e8:	f0000020 	adrp	x0, 88000 <cmd_list+0x980>
   810ec:	91188000 	add	x0, x0, #0x620
   810f0:	f9400001 	ldr	x1, [x0]
   810f4:	b9400fe0 	ldr	w0, [sp, #12]
   810f8:	8b000021 	add	x1, x1, x0
   810fc:	f0000020 	adrp	x0, 88000 <cmd_list+0x980>
   81100:	91188000 	add	x0, x0, #0x620
   81104:	f9000001 	str	x1, [x0]

    return r;
   81108:	f9400fe0 	ldr	x0, [sp, #24]
}
   8110c:	910083ff 	add	sp, sp, #0x20
   81110:	d65f03c0 	ret

0000000000081114 <free>:

void free(void *ptr) {
   81114:	d10043ff 	sub	sp, sp, #0x10
   81118:	f90007e0 	str	x0, [sp, #8]
}
   8111c:	d503201f 	nop
   81120:	910043ff 	add	sp, sp, #0x10
   81124:	d65f03c0 	ret

0000000000081128 <insert_frame_node>:

static frame *frame_array;     // store all "frame" status
static frame *free_frame_list; // store continuous free frame info
static frame_slot *free_slot_list;

void insert_frame_node(frame *node, frame *it) {
   81128:	d10043ff 	sub	sp, sp, #0x10
   8112c:	f90007e0 	str	x0, [sp, #8]
   81130:	f90003e1 	str	x1, [sp]
    node->next = it->next;
   81134:	f94003e0 	ldr	x0, [sp]
   81138:	f9400001 	ldr	x1, [x0]
   8113c:	f94007e0 	ldr	x0, [sp, #8]
   81140:	f9000001 	str	x1, [x0]
    node->prev = it;
   81144:	f94007e0 	ldr	x0, [sp, #8]
   81148:	f94003e1 	ldr	x1, [sp]
   8114c:	f9000401 	str	x1, [x0, #8]
    node->prev->next = node;
   81150:	f94007e0 	ldr	x0, [sp, #8]
   81154:	f9400400 	ldr	x0, [x0, #8]
   81158:	f94007e1 	ldr	x1, [sp, #8]
   8115c:	f9000001 	str	x1, [x0]
    node->next->prev = node;
   81160:	f94007e0 	ldr	x0, [sp, #8]
   81164:	f9400000 	ldr	x0, [x0]
   81168:	f94007e1 	ldr	x1, [sp, #8]
   8116c:	f9000401 	str	x1, [x0, #8]
}
   81170:	d503201f 	nop
   81174:	910043ff 	add	sp, sp, #0x10
   81178:	d65f03c0 	ret

000000000008117c <allocator_init>:

// Should be called after CPIO being traverse
void allocator_init() {
   8117c:	a9be7bfd 	stp	x29, x30, [sp, #-32]!
   81180:	910003fd 	mov	x29, sp
    // init frame array
    frame_array = (frame *)simple_malloc(MAX_PAGE * sizeof(frame));
   81184:	52a00f00 	mov	w0, #0x780000              	// #7864320
   81188:	97ffffc9 	bl	810ac <simple_malloc>
   8118c:	aa0003e1 	mov	x1, x0
   81190:	f0000020 	adrp	x0, 88000 <cmd_list+0x980>
   81194:	911f4000 	add	x0, x0, #0x7d0
   81198:	f9000001 	str	x1, [x0]
    for (int i = 0; i < MAX_PAGE; i++) {
   8119c:	b9001fff 	str	wzr, [sp, #28]
   811a0:	1400003d 	b	81294 <allocator_init+0x118>
        frame_array[i].next = &frame_array[i];
   811a4:	f0000020 	adrp	x0, 88000 <cmd_list+0x980>
   811a8:	911f4000 	add	x0, x0, #0x7d0
   811ac:	f9400002 	ldr	x2, [x0]
   811b0:	b9801fe0 	ldrsw	x0, [sp, #28]
   811b4:	d37be801 	lsl	x1, x0, #5
   811b8:	f0000020 	adrp	x0, 88000 <cmd_list+0x980>
   811bc:	911f4000 	add	x0, x0, #0x7d0
   811c0:	f9400003 	ldr	x3, [x0]
   811c4:	b9801fe0 	ldrsw	x0, [sp, #28]
   811c8:	d37be800 	lsl	x0, x0, #5
   811cc:	8b000060 	add	x0, x3, x0
   811d0:	8b010041 	add	x1, x2, x1
   811d4:	f9000001 	str	x1, [x0]
        frame_array[i].prev = &frame_array[i];
   811d8:	f0000020 	adrp	x0, 88000 <cmd_list+0x980>
   811dc:	911f4000 	add	x0, x0, #0x7d0
   811e0:	f9400002 	ldr	x2, [x0]
   811e4:	b9801fe0 	ldrsw	x0, [sp, #28]
   811e8:	d37be801 	lsl	x1, x0, #5
   811ec:	f0000020 	adrp	x0, 88000 <cmd_list+0x980>
   811f0:	911f4000 	add	x0, x0, #0x7d0
   811f4:	f9400003 	ldr	x3, [x0]
   811f8:	b9801fe0 	ldrsw	x0, [sp, #28]
   811fc:	d37be800 	lsl	x0, x0, #5
   81200:	8b000060 	add	x0, x3, x0
   81204:	8b010041 	add	x1, x2, x1
   81208:	f9000401 	str	x1, [x0, #8]
        frame_array[i].val = 0;
   8120c:	f0000020 	adrp	x0, 88000 <cmd_list+0x980>
   81210:	911f4000 	add	x0, x0, #0x7d0
   81214:	f9400001 	ldr	x1, [x0]
   81218:	b9801fe0 	ldrsw	x0, [sp, #28]
   8121c:	d37be800 	lsl	x0, x0, #5
   81220:	8b000020 	add	x0, x1, x0
   81224:	b900181f 	str	wzr, [x0, #24]
        frame_array[i].idx = i;
   81228:	f0000020 	adrp	x0, 88000 <cmd_list+0x980>
   8122c:	911f4000 	add	x0, x0, #0x7d0
   81230:	f9400001 	ldr	x1, [x0]
   81234:	b9801fe0 	ldrsw	x0, [sp, #28]
   81238:	d37be800 	lsl	x0, x0, #5
   8123c:	8b000020 	add	x0, x1, x0
   81240:	b9401fe1 	ldr	w1, [sp, #28]
   81244:	b9001001 	str	w1, [x0, #16]
        frame_array[i].used = FRAME_FREE_FLAG;
   81248:	f0000020 	adrp	x0, 88000 <cmd_list+0x980>
   8124c:	911f4000 	add	x0, x0, #0x7d0
   81250:	f9400001 	ldr	x1, [x0]
   81254:	b9801fe0 	ldrsw	x0, [sp, #28]
   81258:	d37be800 	lsl	x0, x0, #5
   8125c:	8b000020 	add	x0, x1, x0
   81260:	12800001 	mov	w1, #0xffffffff            	// #-1
   81264:	b9001401 	str	w1, [x0, #20]
        frame_array[i].slot_level = NOT_A_SLOT;
   81268:	f0000020 	adrp	x0, 88000 <cmd_list+0x980>
   8126c:	911f4000 	add	x0, x0, #0x7d0
   81270:	f9400001 	ldr	x1, [x0]
   81274:	b9801fe0 	ldrsw	x0, [sp, #28]
   81278:	d37be800 	lsl	x0, x0, #5
   8127c:	8b000020 	add	x0, x1, x0
   81280:	12800001 	mov	w1, #0xffffffff            	// #-1
   81284:	b9001c01 	str	w1, [x0, #28]
    for (int i = 0; i < MAX_PAGE; i++) {
   81288:	b9401fe0 	ldr	w0, [sp, #28]
   8128c:	11000400 	add	w0, w0, #0x1
   81290:	b9001fe0 	str	w0, [sp, #28]
   81294:	b9401fe0 	ldr	w0, [sp, #28]
   81298:	7140f01f 	cmp	w0, #0x3c, lsl #12
   8129c:	54fff84b 	b.lt	811a4 <allocator_init+0x28>  // b.tstop
    }

    // init frame freelist, heads are empty
    free_frame_list = (frame *)simple_malloc((MAX_PAGE_EXP + 1) * sizeof(frame));
   812a0:	52802c00 	mov	w0, #0x160                 	// #352
   812a4:	97ffff82 	bl	810ac <simple_malloc>
   812a8:	aa0003e1 	mov	x1, x0
   812ac:	f0000020 	adrp	x0, 88000 <cmd_list+0x980>
   812b0:	911f6000 	add	x0, x0, #0x7d8
   812b4:	f9000001 	str	x1, [x0]
    for (int i = 0; i < MAX_PAGE_EXP + 1; i++) {
   812b8:	b9001bff 	str	wzr, [sp, #24]
   812bc:	14000026 	b	81354 <allocator_init+0x1d8>
        free_frame_list[i].idx = -1; // debug usage
   812c0:	f0000020 	adrp	x0, 88000 <cmd_list+0x980>
   812c4:	911f6000 	add	x0, x0, #0x7d8
   812c8:	f9400001 	ldr	x1, [x0]
   812cc:	b9801be0 	ldrsw	x0, [sp, #24]
   812d0:	d37be800 	lsl	x0, x0, #5
   812d4:	8b000020 	add	x0, x1, x0
   812d8:	12800001 	mov	w1, #0xffffffff            	// #-1
   812dc:	b9001001 	str	w1, [x0, #16]
        free_frame_list[i].next = &free_frame_list[i];
   812e0:	f0000020 	adrp	x0, 88000 <cmd_list+0x980>
   812e4:	911f6000 	add	x0, x0, #0x7d8
   812e8:	f9400002 	ldr	x2, [x0]
   812ec:	b9801be0 	ldrsw	x0, [sp, #24]
   812f0:	d37be801 	lsl	x1, x0, #5
   812f4:	f0000020 	adrp	x0, 88000 <cmd_list+0x980>
   812f8:	911f6000 	add	x0, x0, #0x7d8
   812fc:	f9400003 	ldr	x3, [x0]
   81300:	b9801be0 	ldrsw	x0, [sp, #24]
   81304:	d37be800 	lsl	x0, x0, #5
   81308:	8b000060 	add	x0, x3, x0
   8130c:	8b010041 	add	x1, x2, x1
   81310:	f9000001 	str	x1, [x0]
        free_frame_list[i].prev = &free_frame_list[i];
   81314:	f0000020 	adrp	x0, 88000 <cmd_list+0x980>
   81318:	911f6000 	add	x0, x0, #0x7d8
   8131c:	f9400002 	ldr	x2, [x0]
   81320:	b9801be0 	ldrsw	x0, [sp, #24]
   81324:	d37be801 	lsl	x1, x0, #5
   81328:	f0000020 	adrp	x0, 88000 <cmd_list+0x980>
   8132c:	911f6000 	add	x0, x0, #0x7d8
   81330:	f9400003 	ldr	x3, [x0]
   81334:	b9801be0 	ldrsw	x0, [sp, #24]
   81338:	d37be800 	lsl	x0, x0, #5
   8133c:	8b000060 	add	x0, x3, x0
   81340:	8b010041 	add	x1, x2, x1
   81344:	f9000401 	str	x1, [x0, #8]
    for (int i = 0; i < MAX_PAGE_EXP + 1; i++) {
   81348:	b9401be0 	ldr	w0, [sp, #24]
   8134c:	11000400 	add	w0, w0, #0x1
   81350:	b9001be0 	str	w0, [sp, #24]
   81354:	b9401be0 	ldr	w0, [sp, #24]
   81358:	7100281f 	cmp	w0, #0xa
   8135c:	54fffb2d 	b.le	812c0 <allocator_init+0x144>
    }
    // insert every biggest chunk of mem into list
    for (int i = 0; i < MAX_PAGE; i += (1 << MAX_PAGE_EXP)) {
   81360:	b90017ff 	str	wzr, [sp, #20]
   81364:	14000019 	b	813c8 <allocator_init+0x24c>
        frame_array[i].val = MAX_PAGE_EXP;
   81368:	f0000020 	adrp	x0, 88000 <cmd_list+0x980>
   8136c:	911f4000 	add	x0, x0, #0x7d0
   81370:	f9400001 	ldr	x1, [x0]
   81374:	b98017e0 	ldrsw	x0, [sp, #20]
   81378:	d37be800 	lsl	x0, x0, #5
   8137c:	8b000020 	add	x0, x1, x0
   81380:	52800141 	mov	w1, #0xa                   	// #10
   81384:	b9001801 	str	w1, [x0, #24]
        insert_frame_node(&frame_array[i], &free_frame_list[MAX_PAGE_EXP]);
   81388:	f0000020 	adrp	x0, 88000 <cmd_list+0x980>
   8138c:	911f4000 	add	x0, x0, #0x7d0
   81390:	f9400001 	ldr	x1, [x0]
   81394:	b98017e0 	ldrsw	x0, [sp, #20]
   81398:	d37be800 	lsl	x0, x0, #5
   8139c:	8b000022 	add	x2, x1, x0
   813a0:	f0000020 	adrp	x0, 88000 <cmd_list+0x980>
   813a4:	911f6000 	add	x0, x0, #0x7d8
   813a8:	f9400000 	ldr	x0, [x0]
   813ac:	91050000 	add	x0, x0, #0x140
   813b0:	aa0003e1 	mov	x1, x0
   813b4:	aa0203e0 	mov	x0, x2
   813b8:	97ffff5c 	bl	81128 <insert_frame_node>
    for (int i = 0; i < MAX_PAGE; i += (1 << MAX_PAGE_EXP)) {
   813bc:	b94017e0 	ldr	w0, [sp, #20]
   813c0:	11100000 	add	w0, w0, #0x400
   813c4:	b90017e0 	str	w0, [sp, #20]
   813c8:	b94017e0 	ldr	w0, [sp, #20]
   813cc:	7140f01f 	cmp	w0, #0x3c, lsl #12
   813d0:	54fffccb 	b.lt	81368 <allocator_init+0x1ec>  // b.tstop
    }

    // init dynamic mem allocator head (head is empty)
    free_slot_list = simple_malloc((MAX_SLOT_EXP + 1) * sizeof(frame_slot));
   813d4:	52801000 	mov	w0, #0x80                  	// #128
   813d8:	97ffff35 	bl	810ac <simple_malloc>
   813dc:	aa0003e1 	mov	x1, x0
   813e0:	f0000020 	adrp	x0, 88000 <cmd_list+0x980>
   813e4:	911f8000 	add	x0, x0, #0x7e0
   813e8:	f9000001 	str	x1, [x0]
    for (int i = 0; i < MAX_SLOT_EXP + 1; i++) {
   813ec:	b90013ff 	str	wzr, [sp, #16]
   813f0:	1400001e 	b	81468 <allocator_init+0x2ec>
        free_slot_list[i].next = &free_slot_list[i];
   813f4:	f0000020 	adrp	x0, 88000 <cmd_list+0x980>
   813f8:	911f8000 	add	x0, x0, #0x7e0
   813fc:	f9400002 	ldr	x2, [x0]
   81400:	b98013e0 	ldrsw	x0, [sp, #16]
   81404:	d37cec01 	lsl	x1, x0, #4
   81408:	f0000020 	adrp	x0, 88000 <cmd_list+0x980>
   8140c:	911f8000 	add	x0, x0, #0x7e0
   81410:	f9400003 	ldr	x3, [x0]
   81414:	b98013e0 	ldrsw	x0, [sp, #16]
   81418:	d37cec00 	lsl	x0, x0, #4
   8141c:	8b000060 	add	x0, x3, x0
   81420:	8b010041 	add	x1, x2, x1
   81424:	f9000001 	str	x1, [x0]
        free_slot_list[i].prev = &free_slot_list[i];
   81428:	f0000020 	adrp	x0, 88000 <cmd_list+0x980>
   8142c:	911f8000 	add	x0, x0, #0x7e0
   81430:	f9400002 	ldr	x2, [x0]
   81434:	b98013e0 	ldrsw	x0, [sp, #16]
   81438:	d37cec01 	lsl	x1, x0, #4
   8143c:	f0000020 	adrp	x0, 88000 <cmd_list+0x980>
   81440:	911f8000 	add	x0, x0, #0x7e0
   81444:	f9400003 	ldr	x3, [x0]
   81448:	b98013e0 	ldrsw	x0, [sp, #16]
   8144c:	d37cec00 	lsl	x0, x0, #4
   81450:	8b000060 	add	x0, x3, x0
   81454:	8b010041 	add	x1, x2, x1
   81458:	f9000401 	str	x1, [x0, #8]
    for (int i = 0; i < MAX_SLOT_EXP + 1; i++) {
   8145c:	b94013e0 	ldr	w0, [sp, #16]
   81460:	11000400 	add	w0, w0, #0x1
   81464:	b90013e0 	str	w0, [sp, #16]
   81468:	b94013e0 	ldr	w0, [sp, #16]
   8146c:	71001c1f 	cmp	w0, #0x7
   81470:	54fffc2d 	b.le	813f4 <allocator_init+0x278>
    // uart_sendline("\n_start ~ _end:");
    // memory_reserve((unsigned long long)&_start, (unsigned long long)&_end); // kernel image (stack, heap included)
    // uart_sendline("\nCPIO_DEFAULT_START ~ CPIO_DEFAULT_END:");
    // memory_reserve((unsigned long long)CPIO_DEFAULT_START, (unsigned long long)CPIO_DEFAULT_END); // initramfs
    // dump_free_frame_list();
}
   81474:	d503201f 	nop
   81478:	d503201f 	nop
   8147c:	a8c27bfd 	ldp	x29, x30, [sp], #32
   81480:	d65f03c0 	ret

0000000000081484 <page_malloc>:

// size: Byte
void *page_malloc(unsigned int size) {
   81484:	a9bc7bfd 	stp	x29, x30, [sp, #-64]!
   81488:	910003fd 	mov	x29, sp
   8148c:	b9001fe0 	str	w0, [sp, #28]
    // calculate least frame size needed
    int needed_frame = (size >> PAGE_LEVEL) + ((size & (0xFFF)) > 0);
   81490:	b9401fe0 	ldr	w0, [sp, #28]
   81494:	530c7c00 	lsr	w0, w0, #12
   81498:	b9401fe1 	ldr	w1, [sp, #28]
   8149c:	12002c21 	and	w1, w1, #0xfff
   814a0:	7100003f 	cmp	w1, #0x0
   814a4:	1a9f07e1 	cset	w1, ne  // ne = any
   814a8:	12001c21 	and	w1, w1, #0xff
   814ac:	0b010000 	add	w0, w0, w1
   814b0:	b90033e0 	str	w0, [sp, #48]
    // uart_sendline("Request size: %d B (%d frames)\n", size, needed_frame);

    size = needed_frame; // turn size into frame (4KB = 2^12 bytes)
   814b4:	b94033e0 	ldr	w0, [sp, #48]
   814b8:	b9001fe0 	str	w0, [sp, #28]
    void *allocated_addr = (void *)0;
   814bc:	f9001fff 	str	xzr, [sp, #56]

    // traverse and find available continuous frame
    for (int i = 0;; i++) {
   814c0:	b90037ff 	str	wzr, [sp, #52]
        // failed
        if (i > MAX_PAGE_EXP) {
   814c4:	b94037e0 	ldr	w0, [sp, #52]
   814c8:	7100281f 	cmp	w0, #0xa
   814cc:	540000ad 	b.le	814e0 <page_malloc+0x5c>
            uart_sendline("page malloc failed, no space left\n");
   814d0:	b0000020 	adrp	x0, 86000 <el1t_irq_invalid+0x78>
   814d4:	910f6000 	add	x0, x0, #0x3d8
   814d8:	94000e84 	bl	84ee8 <uart_sendline>
            break;
   814dc:	14000042 	b	815e4 <page_malloc+0x160>
        }

        // find smallest block to store
        if ((1 << i) >= size && free_frame_list[i].next != &free_frame_list[i]) {
   814e0:	b94037e0 	ldr	w0, [sp, #52]
   814e4:	52800021 	mov	w1, #0x1                   	// #1
   814e8:	1ac02020 	lsl	w0, w1, w0
   814ec:	2a0003e1 	mov	w1, w0
   814f0:	b9401fe0 	ldr	w0, [sp, #28]
   814f4:	6b01001f 	cmp	w0, w1
   814f8:	540006e8 	b.hi	815d4 <page_malloc+0x150>  // b.pmore
   814fc:	f0000020 	adrp	x0, 88000 <cmd_list+0x980>
   81500:	911f6000 	add	x0, x0, #0x7d8
   81504:	f9400001 	ldr	x1, [x0]
   81508:	b98037e0 	ldrsw	x0, [sp, #52]
   8150c:	d37be800 	lsl	x0, x0, #5
   81510:	8b000020 	add	x0, x1, x0
   81514:	f9400001 	ldr	x1, [x0]
   81518:	f0000020 	adrp	x0, 88000 <cmd_list+0x980>
   8151c:	911f6000 	add	x0, x0, #0x7d8
   81520:	f9400002 	ldr	x2, [x0]
   81524:	b98037e0 	ldrsw	x0, [sp, #52]
   81528:	d37be800 	lsl	x0, x0, #5
   8152c:	8b000040 	add	x0, x2, x0
   81530:	eb00003f 	cmp	x1, x0
   81534:	54000500 	b.eq	815d4 <page_malloc+0x150>  // b.none
            // calculate address by frame index
            frame *node = free_frame_list[i].next;
   81538:	f0000020 	adrp	x0, 88000 <cmd_list+0x980>
   8153c:	911f6000 	add	x0, x0, #0x7d8
   81540:	f9400001 	ldr	x1, [x0]
   81544:	b98037e0 	ldrsw	x0, [sp, #52]
   81548:	d37be800 	lsl	x0, x0, #5
   8154c:	8b000020 	add	x0, x1, x0
   81550:	f9400000 	ldr	x0, [x0]
   81554:	f90017e0 	str	x0, [sp, #40]
            allocated_addr = (void *)(((uint64_t)(node->idx) << PAGE_LEVEL) + ALLOCATION_BASE);
   81558:	f94017e0 	ldr	x0, [sp, #40]
   8155c:	b9401000 	ldr	w0, [x0, #16]
   81560:	2a0003e0 	mov	w0, w0
   81564:	d374cc00 	lsl	x0, x0, #12
   81568:	f9001fe0 	str	x0, [sp, #56]
            // uart_sendline("[allocte] From index %d, allocated %d frame with total size "
            //               "%d KB\n",
            //               node->idx, (1 << i), (1 << (i + PAGE_LEVEL - 10)));

            // update frame array head (set val to 2^i continuous frame)
            node->val = i;
   8156c:	f94017e0 	ldr	x0, [sp, #40]
   81570:	b94037e1 	ldr	w1, [sp, #52]
   81574:	b9001801 	str	w1, [x0, #24]
            node->used = FRAME_OCCUPIED_FLAG;
   81578:	f94017e0 	ldr	x0, [sp, #40]
   8157c:	12800021 	mov	w1, #0xfffffffe            	// #-2
   81580:	b9001401 	str	w1, [x0, #20]

            // remove node from freelist
            node->prev->next = node->next;
   81584:	f94017e0 	ldr	x0, [sp, #40]
   81588:	f9400400 	ldr	x0, [x0, #8]
   8158c:	f94017e1 	ldr	x1, [sp, #40]
   81590:	f9400021 	ldr	x1, [x1]
   81594:	f9000001 	str	x1, [x0]
            node->next->prev = node->prev;
   81598:	f94017e0 	ldr	x0, [sp, #40]
   8159c:	f9400000 	ldr	x0, [x0]
   815a0:	f94017e1 	ldr	x1, [sp, #40]
   815a4:	f9400421 	ldr	x1, [x1, #8]
   815a8:	f9000401 	str	x1, [x0, #8]
            node->next = node;
   815ac:	f94017e0 	ldr	x0, [sp, #40]
   815b0:	f94017e1 	ldr	x1, [sp, #40]
   815b4:	f9000001 	str	x1, [x0]
            node->prev = node;
   815b8:	f94017e0 	ldr	x0, [sp, #40]
   815bc:	f94017e1 	ldr	x1, [sp, #40]
   815c0:	f9000401 	str	x1, [x0, #8]

            // release redundant frame
            release_redundant(node, size);
   815c4:	b9401fe1 	ldr	w1, [sp, #28]
   815c8:	f94017e0 	ldr	x0, [sp, #40]
   815cc:	94000009 	bl	815f0 <release_redundant>

            // uart_sendline("allocated address from %x ~ %x\n", allocated_addr, end);
            break;
   815d0:	14000005 	b	815e4 <page_malloc+0x160>
    for (int i = 0;; i++) {
   815d4:	b94037e0 	ldr	w0, [sp, #52]
   815d8:	11000400 	add	w0, w0, #0x1
   815dc:	b90037e0 	str	w0, [sp, #52]
        if (i > MAX_PAGE_EXP) {
   815e0:	17ffffb9 	b	814c4 <page_malloc+0x40>
        }
    }
    // dump_free_frame_list();
    return allocated_addr;
   815e4:	f9401fe0 	ldr	x0, [sp, #56]
}
   815e8:	a8c47bfd 	ldp	x29, x30, [sp], #64
   815ec:	d65f03c0 	ret

00000000000815f0 <release_redundant>:

// if allocated frames / 2 > needed frame, take it back
void release_redundant(frame *node, unsigned int size) {
   815f0:	a9bd7bfd 	stp	x29, x30, [sp, #-48]!
   815f4:	910003fd 	mov	x29, sp
   815f8:	f9000fe0 	str	x0, [sp, #24]
   815fc:	b90017e1 	str	w1, [sp, #20]
    // loop until < size
    while (node->val > 0 && size <= (1 << (node->val - 1))) {
   81600:	14000023 	b	8168c <release_redundant+0x9c>
        // cut half
        node->val -= 1;
   81604:	f9400fe0 	ldr	x0, [sp, #24]
   81608:	b9401800 	ldr	w0, [x0, #24]
   8160c:	51000401 	sub	w1, w0, #0x1
   81610:	f9400fe0 	ldr	x0, [sp, #24]
   81614:	b9001801 	str	w1, [x0, #24]

        // get the half been cut
        frame *buddy = &frame_array[node->idx ^ (1 << node->val)];
   81618:	f0000020 	adrp	x0, 88000 <cmd_list+0x980>
   8161c:	911f4000 	add	x0, x0, #0x7d0
   81620:	f9400001 	ldr	x1, [x0]
   81624:	f9400fe0 	ldr	x0, [sp, #24]
   81628:	b9401000 	ldr	w0, [x0, #16]
   8162c:	f9400fe2 	ldr	x2, [sp, #24]
   81630:	b9401842 	ldr	w2, [x2, #24]
   81634:	52800023 	mov	w3, #0x1                   	// #1
   81638:	1ac22062 	lsl	w2, w3, w2
   8163c:	4a020000 	eor	w0, w0, w2
   81640:	2a0003e0 	mov	w0, w0
   81644:	d37be800 	lsl	x0, x0, #5
   81648:	8b000020 	add	x0, x1, x0
   8164c:	f90017e0 	str	x0, [sp, #40]
        buddy->val = node->val; // mark level to coalesce
   81650:	f9400fe0 	ldr	x0, [sp, #24]
   81654:	b9401801 	ldr	w1, [x0, #24]
   81658:	f94017e0 	ldr	x0, [sp, #40]
   8165c:	b9001801 	str	w1, [x0, #24]

        // add buddy to free frame list
        insert_frame_node(buddy, &free_frame_list[node->val]);
   81660:	f0000020 	adrp	x0, 88000 <cmd_list+0x980>
   81664:	911f6000 	add	x0, x0, #0x7d8
   81668:	f9400001 	ldr	x1, [x0]
   8166c:	f9400fe0 	ldr	x0, [sp, #24]
   81670:	b9401800 	ldr	w0, [x0, #24]
   81674:	93407c00 	sxtw	x0, w0
   81678:	d37be800 	lsl	x0, x0, #5
   8167c:	8b000020 	add	x0, x1, x0
   81680:	aa0003e1 	mov	x1, x0
   81684:	f94017e0 	ldr	x0, [sp, #40]
   81688:	97fffea8 	bl	81128 <insert_frame_node>
    while (node->val > 0 && size <= (1 << (node->val - 1))) {
   8168c:	f9400fe0 	ldr	x0, [sp, #24]
   81690:	b9401800 	ldr	w0, [x0, #24]
   81694:	7100001f 	cmp	w0, #0x0
   81698:	5400014d 	b.le	816c0 <release_redundant+0xd0>
   8169c:	f9400fe0 	ldr	x0, [sp, #24]
   816a0:	b9401800 	ldr	w0, [x0, #24]
   816a4:	51000400 	sub	w0, w0, #0x1
   816a8:	52800021 	mov	w1, #0x1                   	// #1
   816ac:	1ac02020 	lsl	w0, w1, w0
   816b0:	2a0003e1 	mov	w1, w0
   816b4:	b94017e0 	ldr	w0, [sp, #20]
   816b8:	6b01001f 	cmp	w0, w1
   816bc:	54fffa49 	b.ls	81604 <release_redundant+0x14>  // b.plast

        // uart_sendline("[release] From index %d, released %d frame with total size %d "
        //               "KB\n",
        //               buddy->idx, (1 << node->val), (1 << (node->val + PAGE_LEVEL - 10)));
    }
}
   816c0:	d503201f 	nop
   816c4:	a8c37bfd 	ldp	x29, x30, [sp], #48
   816c8:	d65f03c0 	ret

00000000000816cc <page_free>:

// val = frame's level (2^val)
void page_free(void *ptr) {
   816cc:	a9bd7bfd 	stp	x29, x30, [sp, #-48]!
   816d0:	910003fd 	mov	x29, sp
   816d4:	f9000fe0 	str	x0, [sp, #24]
    // get the target in array: (addr - base) / 8(byte) / 4096(frame size)
    frame *page_frame_ptr = &frame_array[((unsigned long long)ptr - ALLOCATION_BASE) >> PAGE_LEVEL];
   816d8:	f0000020 	adrp	x0, 88000 <cmd_list+0x980>
   816dc:	911f4000 	add	x0, x0, #0x7d0
   816e0:	f9400001 	ldr	x1, [x0]
   816e4:	f9400fe0 	ldr	x0, [sp, #24]
   816e8:	d34cfc00 	lsr	x0, x0, #12
   816ec:	d37be800 	lsl	x0, x0, #5
   816f0:	8b000020 	add	x0, x1, x0
   816f4:	f90017e0 	str	x0, [sp, #40]

    // uart_sendline("[Free] From index %d, released %d frame with total size %d KB\n", page_frame_ptr->idx, (1 << page_frame_ptr->val),
    //               (1 << (page_frame_ptr->val + PAGE_LEVEL - 10)));

    // update tag to 'un-used'
    page_frame_ptr->used = FRAME_FREE_FLAG;
   816f8:	f94017e0 	ldr	x0, [sp, #40]
   816fc:	12800001 	mov	w1, #0xffffffff            	// #-1
   81700:	b9001401 	str	w1, [x0, #20]

    // coalesce iteratively
    while (coalesce(&page_frame_ptr) == 0) {};
   81704:	d503201f 	nop
   81708:	9100a3e0 	add	x0, sp, #0x28
   8170c:	94000012 	bl	81754 <coalesce>
   81710:	7100001f 	cmp	w0, #0x0
   81714:	54ffffa0 	b.eq	81708 <page_free+0x3c>  // b.none

    // add whole coalesced frames into free frame list
    insert_frame_node(page_frame_ptr, &free_frame_list[page_frame_ptr->val]);
   81718:	f94017e2 	ldr	x2, [sp, #40]
   8171c:	f0000020 	adrp	x0, 88000 <cmd_list+0x980>
   81720:	911f6000 	add	x0, x0, #0x7d8
   81724:	f9400001 	ldr	x1, [x0]
   81728:	f94017e0 	ldr	x0, [sp, #40]
   8172c:	b9401800 	ldr	w0, [x0, #24]
   81730:	93407c00 	sxtw	x0, w0
   81734:	d37be800 	lsl	x0, x0, #5
   81738:	8b000020 	add	x0, x1, x0
   8173c:	aa0003e1 	mov	x1, x0
   81740:	aa0203e0 	mov	x0, x2
   81744:	97fffe79 	bl	81128 <insert_frame_node>

    // dump_free_frame_list();
}
   81748:	d503201f 	nop
   8174c:	a8c37bfd 	ldp	x29, x30, [sp], #48
   81750:	d65f03c0 	ret

0000000000081754 <coalesce>:

// return 0 if success, return -1 otherwise
int coalesce(frame **ptr) {
   81754:	d10083ff 	sub	sp, sp, #0x20
   81758:	f90007e0 	str	x0, [sp, #8]
    frame *frame_ptr = *ptr;
   8175c:	f94007e0 	ldr	x0, [sp, #8]
   81760:	f9400000 	ldr	x0, [x0]
   81764:	f9000fe0 	str	x0, [sp, #24]
    // find buddy's index
    frame *buddy = &frame_array[frame_ptr->idx ^ (1 << frame_ptr->val)];
   81768:	f0000020 	adrp	x0, 88000 <cmd_list+0x980>
   8176c:	911f4000 	add	x0, x0, #0x7d0
   81770:	f9400001 	ldr	x1, [x0]
   81774:	f9400fe0 	ldr	x0, [sp, #24]
   81778:	b9401000 	ldr	w0, [x0, #16]
   8177c:	f9400fe2 	ldr	x2, [sp, #24]
   81780:	b9401842 	ldr	w2, [x2, #24]
   81784:	52800023 	mov	w3, #0x1                   	// #1
   81788:	1ac22062 	lsl	w2, w3, w2
   8178c:	4a020000 	eor	w0, w0, w2
   81790:	2a0003e0 	mov	w0, w0
   81794:	d37be800 	lsl	x0, x0, #5
   81798:	8b000020 	add	x0, x1, x0
   8179c:	f9000be0 	str	x0, [sp, #16]

    // frame must in same level (varify if buddy is free)
    if (frame_ptr->val != buddy->val)
   817a0:	f9400fe0 	ldr	x0, [sp, #24]
   817a4:	b9401801 	ldr	w1, [x0, #24]
   817a8:	f9400be0 	ldr	x0, [sp, #16]
   817ac:	b9401800 	ldr	w0, [x0, #24]
   817b0:	6b00003f 	cmp	w1, w0
   817b4:	54000060 	b.eq	817c0 <coalesce+0x6c>  // b.none
        return -1;
   817b8:	12800000 	mov	w0, #0xffffffff            	// #-1
   817bc:	14000020 	b	8183c <coalesce+0xe8>

    // buddy is in used
    if (buddy->used != FRAME_FREE_FLAG)
   817c0:	f9400be0 	ldr	x0, [sp, #16]
   817c4:	b9401400 	ldr	w0, [x0, #20]
   817c8:	3100041f 	cmn	w0, #0x1
   817cc:	54000060 	b.eq	817d8 <coalesce+0x84>  // b.none
        return -1;
   817d0:	12800000 	mov	w0, #0xffffffff            	// #-1
   817d4:	1400001a 	b	8183c <coalesce+0xe8>

    // uart_sendline("[Coalesce] Merge frame %d and frame %d\n", frame_ptr->idx, buddy->idx);

    // remove buddy from freelist
    buddy->prev->next = buddy->next;
   817d8:	f9400be0 	ldr	x0, [sp, #16]
   817dc:	f9400400 	ldr	x0, [x0, #8]
   817e0:	f9400be1 	ldr	x1, [sp, #16]
   817e4:	f9400021 	ldr	x1, [x1]
   817e8:	f9000001 	str	x1, [x0]
    buddy->next->prev = buddy->prev;
   817ec:	f9400be0 	ldr	x0, [sp, #16]
   817f0:	f9400000 	ldr	x0, [x0]
   817f4:	f9400be1 	ldr	x1, [sp, #16]
   817f8:	f9400421 	ldr	x1, [x1, #8]
   817fc:	f9000401 	str	x1, [x0, #8]

    // ptr point to head of merged frames
    if (buddy->idx < frame_ptr->idx)
   81800:	f9400be0 	ldr	x0, [sp, #16]
   81804:	b9401001 	ldr	w1, [x0, #16]
   81808:	f9400fe0 	ldr	x0, [sp, #24]
   8180c:	b9401000 	ldr	w0, [x0, #16]
   81810:	6b00003f 	cmp	w1, w0
   81814:	54000082 	b.cs	81824 <coalesce+0xd0>  // b.hs, b.nlast
        *ptr = buddy;
   81818:	f94007e0 	ldr	x0, [sp, #8]
   8181c:	f9400be1 	ldr	x1, [sp, #16]
   81820:	f9000001 	str	x1, [x0]

    // since merge, upgrade level
    (*ptr)->val++;
   81824:	f94007e0 	ldr	x0, [sp, #8]
   81828:	f9400000 	ldr	x0, [x0]
   8182c:	b9401801 	ldr	w1, [x0, #24]
   81830:	11000421 	add	w1, w1, #0x1
   81834:	b9001801 	str	w1, [x0, #24]

    return 0;
   81838:	52800000 	mov	w0, #0x0                   	// #0
}
   8183c:	910083ff 	add	sp, sp, #0x20
   81840:	d65f03c0 	ret

0000000000081844 <dump_free_frame_list>:

void dump_free_frame_list() {
   81844:	a9bd7bfd 	stp	x29, x30, [sp, #-48]!
   81848:	910003fd 	mov	x29, sp
    uart_sendline("\n===========================================\n");
   8184c:	b0000020 	adrp	x0, 86000 <el1t_irq_invalid+0x78>
   81850:	91100000 	add	x0, x0, #0x400
   81854:	94000da5 	bl	84ee8 <uart_sendline>
    uart_sendline("[free frame list]\n");
   81858:	b0000020 	adrp	x0, 86000 <el1t_irq_invalid+0x78>
   8185c:	9110c000 	add	x0, x0, #0x430
   81860:	94000da2 	bl	84ee8 <uart_sendline>
    for (int i = 0; i <= MAX_PAGE_EXP; i++) {
   81864:	b9002fff 	str	wzr, [sp, #44]
   81868:	14000026 	b	81900 <dump_free_frame_list+0xbc>
        frame *it = free_frame_list[i].next;
   8186c:	f0000020 	adrp	x0, 88000 <cmd_list+0x980>
   81870:	911f6000 	add	x0, x0, #0x7d8
   81874:	f9400001 	ldr	x1, [x0]
   81878:	b9802fe0 	ldrsw	x0, [sp, #44]
   8187c:	d37be800 	lsl	x0, x0, #5
   81880:	8b000020 	add	x0, x1, x0
   81884:	f9400000 	ldr	x0, [x0]
   81888:	f90013e0 	str	x0, [sp, #32]
        int len = 0;
   8188c:	b9001fff 	str	wzr, [sp, #28]
        while (it != &free_frame_list[i]) {
   81890:	14000007 	b	818ac <dump_free_frame_list+0x68>
            // uart_sendline("Frame sequence index %d, sized %d KB\n", it->idx, (1 << (i + 2))); // ((1<<i) * 4)KB
            len++;
   81894:	b9401fe0 	ldr	w0, [sp, #28]
   81898:	11000400 	add	w0, w0, #0x1
   8189c:	b9001fe0 	str	w0, [sp, #28]
            it = it->next;
   818a0:	f94013e0 	ldr	x0, [sp, #32]
   818a4:	f9400000 	ldr	x0, [x0]
   818a8:	f90013e0 	str	x0, [sp, #32]
        while (it != &free_frame_list[i]) {
   818ac:	f0000020 	adrp	x0, 88000 <cmd_list+0x980>
   818b0:	911f6000 	add	x0, x0, #0x7d8
   818b4:	f9400001 	ldr	x1, [x0]
   818b8:	b9802fe0 	ldrsw	x0, [sp, #44]
   818bc:	d37be800 	lsl	x0, x0, #5
   818c0:	8b000020 	add	x0, x1, x0
   818c4:	f94013e1 	ldr	x1, [sp, #32]
   818c8:	eb00003f 	cmp	x1, x0
   818cc:	54fffe41 	b.ne	81894 <dump_free_frame_list+0x50>  // b.any
        }
        uart_sendline("Frame size %d KB:\t%d left\n", (1 << (i + PAGE_LEVEL - 10)), len);
   818d0:	b9402fe0 	ldr	w0, [sp, #44]
   818d4:	11000800 	add	w0, w0, #0x2
   818d8:	52800021 	mov	w1, #0x1                   	// #1
   818dc:	1ac02020 	lsl	w0, w1, w0
   818e0:	b9401fe2 	ldr	w2, [sp, #28]
   818e4:	2a0003e1 	mov	w1, w0
   818e8:	b0000020 	adrp	x0, 86000 <el1t_irq_invalid+0x78>
   818ec:	91112000 	add	x0, x0, #0x448
   818f0:	94000d7e 	bl	84ee8 <uart_sendline>
    for (int i = 0; i <= MAX_PAGE_EXP; i++) {
   818f4:	b9402fe0 	ldr	w0, [sp, #44]
   818f8:	11000400 	add	w0, w0, #0x1
   818fc:	b9002fe0 	str	w0, [sp, #44]
   81900:	b9402fe0 	ldr	w0, [sp, #44]
   81904:	7100281f 	cmp	w0, #0xa
   81908:	54fffb2d 	b.le	8186c <dump_free_frame_list+0x28>
    }
    uart_sendline("===========================================\n\n");
   8190c:	b0000020 	adrp	x0, 86000 <el1t_irq_invalid+0x78>
   81910:	9111a000 	add	x0, x0, #0x468
   81914:	94000d75 	bl	84ee8 <uart_sendline>
}
   81918:	d503201f 	nop
   8191c:	a8c37bfd 	ldp	x29, x30, [sp], #48
   81920:	d65f03c0 	ret

0000000000081924 <cut_page_to_slot>:

// get a page from buddy system
void cut_page_to_slot(int expo) {
   81924:	a9bb7bfd 	stp	x29, x30, [sp, #-80]!
   81928:	910003fd 	mov	x29, sp
   8192c:	b9001fe0 	str	w0, [sp, #28]
    // (char*) to index it Byte by Byte
    char *addr = page_malloc(PAGE_SIZE);
   81930:	52820000 	mov	w0, #0x1000                	// #4096
   81934:	97fffed4 	bl	81484 <page_malloc>
   81938:	f90023e0 	str	x0, [sp, #64]
    frame *page = &frame_array[((unsigned long long)addr - ALLOCATION_BASE) >> PAGE_LEVEL];
   8193c:	f0000020 	adrp	x0, 88000 <cmd_list+0x980>
   81940:	911f4000 	add	x0, x0, #0x7d0
   81944:	f9400001 	ldr	x1, [x0]
   81948:	f94023e0 	ldr	x0, [sp, #64]
   8194c:	d34cfc00 	lsr	x0, x0, #12
   81950:	d37be800 	lsl	x0, x0, #5
   81954:	8b000020 	add	x0, x1, x0
   81958:	f9001fe0 	str	x0, [sp, #56]
    page->slot_level = expo;
   8195c:	f9401fe0 	ldr	x0, [sp, #56]
   81960:	b9401fe1 	ldr	w1, [sp, #28]
   81964:	b9001c01 	str	w1, [x0, #28]

    // insert_frame_node(page, &dynamic_mem_allocator_head[expo]);
    int slot_size = SLOT_SIZE << expo;
   81968:	b9401fe0 	ldr	w0, [sp, #28]
   8196c:	52800401 	mov	w1, #0x20                  	// #32
   81970:	1ac02020 	lsl	w0, w1, w0
   81974:	b90037e0 	str	w0, [sp, #52]
    for (int i = 0; i < PAGE_SIZE; i += slot_size) {
   81978:	b9004fff 	str	wzr, [sp, #76]
   8197c:	14000022 	b	81a04 <cut_page_to_slot+0xe0>
        // temporary use the space to store next, prev ptr
        // it will be overwrite after allocated
        frame_slot *slot = (frame_slot *)(addr + i);
   81980:	b9804fe0 	ldrsw	x0, [sp, #76]
   81984:	f94023e1 	ldr	x1, [sp, #64]
   81988:	8b000020 	add	x0, x1, x0
   8198c:	f90017e0 	str	x0, [sp, #40]
        slot->next = free_slot_list[expo].next;
   81990:	f0000020 	adrp	x0, 88000 <cmd_list+0x980>
   81994:	911f8000 	add	x0, x0, #0x7e0
   81998:	f9400001 	ldr	x1, [x0]
   8199c:	b9801fe0 	ldrsw	x0, [sp, #28]
   819a0:	d37cec00 	lsl	x0, x0, #4
   819a4:	8b000020 	add	x0, x1, x0
   819a8:	f9400001 	ldr	x1, [x0]
   819ac:	f94017e0 	ldr	x0, [sp, #40]
   819b0:	f9000001 	str	x1, [x0]
        slot->prev = &free_slot_list[expo];
   819b4:	f0000020 	adrp	x0, 88000 <cmd_list+0x980>
   819b8:	911f8000 	add	x0, x0, #0x7e0
   819bc:	f9400001 	ldr	x1, [x0]
   819c0:	b9801fe0 	ldrsw	x0, [sp, #28]
   819c4:	d37cec00 	lsl	x0, x0, #4
   819c8:	8b000021 	add	x1, x1, x0
   819cc:	f94017e0 	ldr	x0, [sp, #40]
   819d0:	f9000401 	str	x1, [x0, #8]
        slot->next->prev = slot;
   819d4:	f94017e0 	ldr	x0, [sp, #40]
   819d8:	f9400000 	ldr	x0, [x0]
   819dc:	f94017e1 	ldr	x1, [sp, #40]
   819e0:	f9000401 	str	x1, [x0, #8]
        slot->prev->next = slot;
   819e4:	f94017e0 	ldr	x0, [sp, #40]
   819e8:	f9400400 	ldr	x0, [x0, #8]
   819ec:	f94017e1 	ldr	x1, [sp, #40]
   819f0:	f9000001 	str	x1, [x0]
    for (int i = 0; i < PAGE_SIZE; i += slot_size) {
   819f4:	b9404fe1 	ldr	w1, [sp, #76]
   819f8:	b94037e0 	ldr	w0, [sp, #52]
   819fc:	0b000020 	add	w0, w1, w0
   81a00:	b9004fe0 	str	w0, [sp, #76]
   81a04:	b9404fe0 	ldr	w0, [sp, #76]
   81a08:	713ffc1f 	cmp	w0, #0xfff
   81a0c:	54fffbad 	b.le	81980 <cut_page_to_slot+0x5c>
    }
    // dump_free_slot_list();
}
   81a10:	d503201f 	nop
   81a14:	d503201f 	nop
   81a18:	a8c57bfd 	ldp	x29, x30, [sp], #80
   81a1c:	d65f03c0 	ret

0000000000081a20 <dynamic_malloc>:

// size: byte
void *dynamic_malloc(unsigned int size) {
   81a20:	a9bc7bfd 	stp	x29, x30, [sp, #-64]!
   81a24:	910003fd 	mov	x29, sp
   81a28:	b9001fe0 	str	w0, [sp, #28]
    // calculate least frame size needed
    int slot_needed = (size >> SLOT_LEVEL) + ((size & (0x1F)) > 0);
   81a2c:	b9401fe0 	ldr	w0, [sp, #28]
   81a30:	53057c00 	lsr	w0, w0, #5
   81a34:	b9401fe1 	ldr	w1, [sp, #28]
   81a38:	12001021 	and	w1, w1, #0x1f
   81a3c:	7100003f 	cmp	w1, #0x0
   81a40:	1a9f07e1 	cset	w1, ne  // ne = any
   81a44:	12001c21 	and	w1, w1, #0xff
   81a48:	0b010000 	add	w0, w0, w1
   81a4c:	b9003be0 	str	w0, [sp, #56]
    // uart_sendline("Request size: %d Byte (%d slots) < 4KB\n", size, slot_needed);
    size = slot_needed;
   81a50:	b9403be0 	ldr	w0, [sp, #56]
   81a54:	b9001fe0 	str	w0, [sp, #28]

    // find the level needed
    int expo = 0;
   81a58:	b9003fff 	str	wzr, [sp, #60]
    while ((1 << expo) < size)
   81a5c:	14000004 	b	81a6c <dynamic_malloc+0x4c>
        expo++;
   81a60:	b9403fe0 	ldr	w0, [sp, #60]
   81a64:	11000400 	add	w0, w0, #0x1
   81a68:	b9003fe0 	str	w0, [sp, #60]
    while ((1 << expo) < size)
   81a6c:	b9403fe0 	ldr	w0, [sp, #60]
   81a70:	52800021 	mov	w1, #0x1                   	// #1
   81a74:	1ac02020 	lsl	w0, w1, w0
   81a78:	2a0003e1 	mov	w1, w0
   81a7c:	b9401fe0 	ldr	w0, [sp, #28]
   81a80:	6b01001f 	cmp	w0, w1
   81a84:	54fffee8 	b.hi	81a60 <dynamic_malloc+0x40>  // b.pmore

    // if no free slot
    if (free_slot_list[expo].next == &free_slot_list[expo]) {
   81a88:	f0000020 	adrp	x0, 88000 <cmd_list+0x980>
   81a8c:	911f8000 	add	x0, x0, #0x7e0
   81a90:	f9400001 	ldr	x1, [x0]
   81a94:	b9803fe0 	ldrsw	x0, [sp, #60]
   81a98:	d37cec00 	lsl	x0, x0, #4
   81a9c:	8b000020 	add	x0, x1, x0
   81aa0:	f9400001 	ldr	x1, [x0]
   81aa4:	f0000020 	adrp	x0, 88000 <cmd_list+0x980>
   81aa8:	911f8000 	add	x0, x0, #0x7e0
   81aac:	f9400002 	ldr	x2, [x0]
   81ab0:	b9803fe0 	ldrsw	x0, [sp, #60]
   81ab4:	d37cec00 	lsl	x0, x0, #4
   81ab8:	8b000040 	add	x0, x2, x0
   81abc:	eb00003f 	cmp	x1, x0
   81ac0:	54000061 	b.ne	81acc <dynamic_malloc+0xac>  // b.any
        // uart_sendline("[Dynamic malloc] no free slot\n");
        cut_page_to_slot(expo);
   81ac4:	b9403fe0 	ldr	w0, [sp, #60]
   81ac8:	97ffff97 	bl	81924 <cut_page_to_slot>
    }

    void *slot_addr = free_slot_list[expo].next; // allocated space
   81acc:	f0000020 	adrp	x0, 88000 <cmd_list+0x980>
   81ad0:	911f8000 	add	x0, x0, #0x7e0
   81ad4:	f9400001 	ldr	x1, [x0]
   81ad8:	b9803fe0 	ldrsw	x0, [sp, #60]
   81adc:	d37cec00 	lsl	x0, x0, #4
   81ae0:	8b000020 	add	x0, x1, x0
   81ae4:	f9400000 	ldr	x0, [x0]
   81ae8:	f9001be0 	str	x0, [sp, #48]
    // remove slot from free_slot_list
    frame_slot *it = free_slot_list[expo].next;
   81aec:	f0000020 	adrp	x0, 88000 <cmd_list+0x980>
   81af0:	911f8000 	add	x0, x0, #0x7e0
   81af4:	f9400001 	ldr	x1, [x0]
   81af8:	b9803fe0 	ldrsw	x0, [sp, #60]
   81afc:	d37cec00 	lsl	x0, x0, #4
   81b00:	8b000020 	add	x0, x1, x0
   81b04:	f9400000 	ldr	x0, [x0]
   81b08:	f90017e0 	str	x0, [sp, #40]
    it->prev->next = it->next;
   81b0c:	f94017e0 	ldr	x0, [sp, #40]
   81b10:	f9400400 	ldr	x0, [x0, #8]
   81b14:	f94017e1 	ldr	x1, [sp, #40]
   81b18:	f9400021 	ldr	x1, [x1]
   81b1c:	f9000001 	str	x1, [x0]
    it->next->prev = it->prev;
   81b20:	f94017e0 	ldr	x0, [sp, #40]
   81b24:	f9400000 	ldr	x0, [x0]
   81b28:	f94017e1 	ldr	x1, [sp, #40]
   81b2c:	f9400421 	ldr	x1, [x1, #8]
   81b30:	f9000401 	str	x1, [x0, #8]

    // uart_sendline("[Dynamic malloc] start from %x, sized %d Byte\n", slot_addr, (1 << expo));
    // dump_free_slot_list();

    return slot_addr;
   81b34:	f9401be0 	ldr	x0, [sp, #48]
}
   81b38:	a8c47bfd 	ldp	x29, x30, [sp], #64
   81b3c:	d65f03c0 	ret

0000000000081b40 <dynamic_free>:

void dynamic_free(void *ptr) {
   81b40:	d10083ff 	sub	sp, sp, #0x20
   81b44:	f90007e0 	str	x0, [sp, #8]
    // get the list to insert
    int expo = frame_array[((unsigned long long)ptr - ALLOCATION_BASE) >> 12].slot_level;
   81b48:	f0000020 	adrp	x0, 88000 <cmd_list+0x980>
   81b4c:	911f4000 	add	x0, x0, #0x7d0
   81b50:	f9400001 	ldr	x1, [x0]
   81b54:	f94007e0 	ldr	x0, [sp, #8]
   81b58:	d34cfc00 	lsr	x0, x0, #12
   81b5c:	d37be800 	lsl	x0, x0, #5
   81b60:	8b000020 	add	x0, x1, x0
   81b64:	b9401c00 	ldr	w0, [x0, #28]
   81b68:	b9001fe0 	str	w0, [sp, #28]
    // type trans to re-get 'next', 'prev' field
    frame_slot *slot = (frame_slot *)ptr;
   81b6c:	f94007e0 	ldr	x0, [sp, #8]
   81b70:	f9000be0 	str	x0, [sp, #16]

    // uart_sendline("[Dynamic free] start from %x, sized %d Byte\n", ptr, (1 << expo) * SLOT_SIZE);

    // insert
    slot->next = free_slot_list[expo].next;
   81b74:	f0000020 	adrp	x0, 88000 <cmd_list+0x980>
   81b78:	911f8000 	add	x0, x0, #0x7e0
   81b7c:	f9400001 	ldr	x1, [x0]
   81b80:	b9801fe0 	ldrsw	x0, [sp, #28]
   81b84:	d37cec00 	lsl	x0, x0, #4
   81b88:	8b000020 	add	x0, x1, x0
   81b8c:	f9400001 	ldr	x1, [x0]
   81b90:	f9400be0 	ldr	x0, [sp, #16]
   81b94:	f9000001 	str	x1, [x0]
    slot->prev = &free_slot_list[expo];
   81b98:	f0000020 	adrp	x0, 88000 <cmd_list+0x980>
   81b9c:	911f8000 	add	x0, x0, #0x7e0
   81ba0:	f9400001 	ldr	x1, [x0]
   81ba4:	b9801fe0 	ldrsw	x0, [sp, #28]
   81ba8:	d37cec00 	lsl	x0, x0, #4
   81bac:	8b000021 	add	x1, x1, x0
   81bb0:	f9400be0 	ldr	x0, [sp, #16]
   81bb4:	f9000401 	str	x1, [x0, #8]
    slot->next->prev = slot;
   81bb8:	f9400be0 	ldr	x0, [sp, #16]
   81bbc:	f9400000 	ldr	x0, [x0]
   81bc0:	f9400be1 	ldr	x1, [sp, #16]
   81bc4:	f9000401 	str	x1, [x0, #8]
    slot->prev->next = slot;
   81bc8:	f9400be0 	ldr	x0, [sp, #16]
   81bcc:	f9400400 	ldr	x0, [x0, #8]
   81bd0:	f9400be1 	ldr	x1, [sp, #16]
   81bd4:	f9000001 	str	x1, [x0]

    // dump_free_slot_list();
}
   81bd8:	d503201f 	nop
   81bdc:	910083ff 	add	sp, sp, #0x20
   81be0:	d65f03c0 	ret

0000000000081be4 <dump_free_slot_list>:

void dump_free_slot_list() {
   81be4:	a9bd7bfd 	stp	x29, x30, [sp, #-48]!
   81be8:	910003fd 	mov	x29, sp
    uart_sendline("\n===========================================\n");
   81bec:	b0000020 	adrp	x0, 86000 <el1t_irq_invalid+0x78>
   81bf0:	91100000 	add	x0, x0, #0x400
   81bf4:	94000cbd 	bl	84ee8 <uart_sendline>
    uart_sendline("[free slot list]\n");
   81bf8:	b0000020 	adrp	x0, 86000 <el1t_irq_invalid+0x78>
   81bfc:	91126000 	add	x0, x0, #0x498
   81c00:	94000cba 	bl	84ee8 <uart_sendline>
    for (int i = 0; i <= MAX_SLOT_EXP; i++) {
   81c04:	b9002fff 	str	wzr, [sp, #44]
   81c08:	14000025 	b	81c9c <dump_free_slot_list+0xb8>
        frame_slot *it = free_slot_list[i].next;
   81c0c:	f0000020 	adrp	x0, 88000 <cmd_list+0x980>
   81c10:	911f8000 	add	x0, x0, #0x7e0
   81c14:	f9400001 	ldr	x1, [x0]
   81c18:	b9802fe0 	ldrsw	x0, [sp, #44]
   81c1c:	d37cec00 	lsl	x0, x0, #4
   81c20:	8b000020 	add	x0, x1, x0
   81c24:	f9400000 	ldr	x0, [x0]
   81c28:	f90013e0 	str	x0, [sp, #32]
        int len = 0;
   81c2c:	b9001fff 	str	wzr, [sp, #28]
        while (it != &free_slot_list[i]) {
   81c30:	14000007 	b	81c4c <dump_free_slot_list+0x68>
            len++;
   81c34:	b9401fe0 	ldr	w0, [sp, #28]
   81c38:	11000400 	add	w0, w0, #0x1
   81c3c:	b9001fe0 	str	w0, [sp, #28]
            it = it->next;
   81c40:	f94013e0 	ldr	x0, [sp, #32]
   81c44:	f9400000 	ldr	x0, [x0]
   81c48:	f90013e0 	str	x0, [sp, #32]
        while (it != &free_slot_list[i]) {
   81c4c:	f0000020 	adrp	x0, 88000 <cmd_list+0x980>
   81c50:	911f8000 	add	x0, x0, #0x7e0
   81c54:	f9400001 	ldr	x1, [x0]
   81c58:	b9802fe0 	ldrsw	x0, [sp, #44]
   81c5c:	d37cec00 	lsl	x0, x0, #4
   81c60:	8b000020 	add	x0, x1, x0
   81c64:	f94013e1 	ldr	x1, [sp, #32]
   81c68:	eb00003f 	cmp	x1, x0
   81c6c:	54fffe41 	b.ne	81c34 <dump_free_slot_list+0x50>  // b.any
        }
        uart_sendline("Slot size %d Byte:\t%d left\n", (SLOT_SIZE << i), len);
   81c70:	b9402fe0 	ldr	w0, [sp, #44]
   81c74:	52800401 	mov	w1, #0x20                  	// #32
   81c78:	1ac02020 	lsl	w0, w1, w0
   81c7c:	b9401fe2 	ldr	w2, [sp, #28]
   81c80:	2a0003e1 	mov	w1, w0
   81c84:	b0000020 	adrp	x0, 86000 <el1t_irq_invalid+0x78>
   81c88:	9112c000 	add	x0, x0, #0x4b0
   81c8c:	94000c97 	bl	84ee8 <uart_sendline>
    for (int i = 0; i <= MAX_SLOT_EXP; i++) {
   81c90:	b9402fe0 	ldr	w0, [sp, #44]
   81c94:	11000400 	add	w0, w0, #0x1
   81c98:	b9002fe0 	str	w0, [sp, #44]
   81c9c:	b9402fe0 	ldr	w0, [sp, #44]
   81ca0:	71001c1f 	cmp	w0, #0x7
   81ca4:	54fffb4d 	b.le	81c0c <dump_free_slot_list+0x28>
    }
    uart_sendline("===========================================\n\n");
   81ca8:	b0000020 	adrp	x0, 86000 <el1t_irq_invalid+0x78>
   81cac:	9111a000 	add	x0, x0, #0x468
   81cb0:	94000c8e 	bl	84ee8 <uart_sendline>
}
   81cb4:	d503201f 	nop
   81cb8:	a8c37bfd 	ldp	x29, x30, [sp], #48
   81cbc:	d65f03c0 	ret

0000000000081cc0 <kmalloc>:

void *kmalloc(unsigned int size) {
   81cc0:	a9bd7bfd 	stp	x29, x30, [sp, #-48]!
   81cc4:	910003fd 	mov	x29, sp
   81cc8:	b9001fe0 	str	w0, [sp, #28]
    void *addr;
    if (size > PAGE_SIZE / 2)
   81ccc:	b9401fe0 	ldr	w0, [sp, #28]
   81cd0:	7120001f 	cmp	w0, #0x800
   81cd4:	540000a9 	b.ls	81ce8 <kmalloc+0x28>  // b.plast
        addr = page_malloc(size);
   81cd8:	b9401fe0 	ldr	w0, [sp, #28]
   81cdc:	97fffdea 	bl	81484 <page_malloc>
   81ce0:	f90017e0 	str	x0, [sp, #40]
   81ce4:	14000004 	b	81cf4 <kmalloc+0x34>
    else
        addr = dynamic_malloc(size);
   81ce8:	b9401fe0 	ldr	w0, [sp, #28]
   81cec:	97ffff4d 	bl	81a20 <dynamic_malloc>
   81cf0:	f90017e0 	str	x0, [sp, #40]
    return addr;
   81cf4:	f94017e0 	ldr	x0, [sp, #40]
}
   81cf8:	a8c37bfd 	ldp	x29, x30, [sp], #48
   81cfc:	d65f03c0 	ret

0000000000081d00 <kfree>:

void kfree(void *ptr) {
   81d00:	a9bd7bfd 	stp	x29, x30, [sp, #-48]!
   81d04:	910003fd 	mov	x29, sp
   81d08:	f9000fe0 	str	x0, [sp, #24]
    // if ptr's space in frame array has 'slot_level' attribute, use dynamic free
    frame *the_frame = &frame_array[((unsigned long long)ptr - ALLOCATION_BASE) >> 12];
   81d0c:	f0000020 	adrp	x0, 88000 <cmd_list+0x980>
   81d10:	911f4000 	add	x0, x0, #0x7d0
   81d14:	f9400001 	ldr	x1, [x0]
   81d18:	f9400fe0 	ldr	x0, [sp, #24]
   81d1c:	d34cfc00 	lsr	x0, x0, #12
   81d20:	d37be800 	lsl	x0, x0, #5
   81d24:	8b000020 	add	x0, x1, x0
   81d28:	f90017e0 	str	x0, [sp, #40]
    if (the_frame->slot_level == NOT_A_SLOT)
   81d2c:	f94017e0 	ldr	x0, [sp, #40]
   81d30:	b9401c00 	ldr	w0, [x0, #28]
   81d34:	3100041f 	cmn	w0, #0x1
   81d38:	54000081 	b.ne	81d48 <kfree+0x48>  // b.any
        page_free(ptr);
   81d3c:	f9400fe0 	ldr	x0, [sp, #24]
   81d40:	97fffe63 	bl	816cc <page_free>
    else
        dynamic_free(ptr);
}
   81d44:	14000003 	b	81d50 <kfree+0x50>
        dynamic_free(ptr);
   81d48:	f9400fe0 	ldr	x0, [sp, #24]
   81d4c:	97ffff7d 	bl	81b40 <dynamic_free>
}
   81d50:	d503201f 	nop
   81d54:	a8c37bfd 	ldp	x29, x30, [sp], #48
   81d58:	d65f03c0 	ret

0000000000081d5c <memory_reserve>:

// start, end: address (e.g. 0x1234 5678), a frame contains 0x8000 bits !!!
void memory_reserve(unsigned long long start, unsigned long long end) {
   81d5c:	a9bb7bfd 	stp	x29, x30, [sp, #-80]!
   81d60:	910003fd 	mov	x29, sp
   81d64:	f9000fe0 	str	x0, [sp, #24]
   81d68:	f9000be1 	str	x1, [sp, #16]
    // turn start, end into frame idx
    // uart_sendline("\nReserve Memory from 0x%8x to 0x%8x", start, end);
    start = ((start - ALLOCATION_BASE) >> PAGE_LEVEL);
   81d6c:	f9400fe0 	ldr	x0, [sp, #24]
   81d70:	d34cfc00 	lsr	x0, x0, #12
   81d74:	f9000fe0 	str	x0, [sp, #24]
    end = (end % (1 << PAGE_LEVEL)) == 0 ? ((end - ALLOCATION_BASE) >> PAGE_LEVEL) : ((end - ALLOCATION_BASE) >> PAGE_LEVEL) + 1;
   81d78:	f9400be0 	ldr	x0, [sp, #16]
   81d7c:	92402c00 	and	x0, x0, #0xfff
   81d80:	f100001f 	cmp	x0, #0x0
   81d84:	54000081 	b.ne	81d94 <memory_reserve+0x38>  // b.any
   81d88:	f9400be0 	ldr	x0, [sp, #16]
   81d8c:	d34cfc00 	lsr	x0, x0, #12
   81d90:	14000004 	b	81da0 <memory_reserve+0x44>
   81d94:	f9400be0 	ldr	x0, [sp, #16]
   81d98:	d34cfc00 	lsr	x0, x0, #12
   81d9c:	91000400 	add	x0, x0, #0x1
   81da0:	f9000be0 	str	x0, [sp, #16]
    // uart_sendline(" (frame %d ~ %d)\n", start, end);

    for (int expo = MAX_PAGE_EXP; expo >= 0; expo--) {
   81da4:	52800140 	mov	w0, #0xa                   	// #10
   81da8:	b9004fe0 	str	w0, [sp, #76]
   81dac:	14000080 	b	81fac <memory_reserve+0x250>

        for (frame *it = free_frame_list[expo].next; it != &free_frame_list[expo];) {
   81db0:	f0000020 	adrp	x0, 88000 <cmd_list+0x980>
   81db4:	911f6000 	add	x0, x0, #0x7d8
   81db8:	f9400001 	ldr	x1, [x0]
   81dbc:	b9804fe0 	ldrsw	x0, [sp, #76]
   81dc0:	d37be800 	lsl	x0, x0, #5
   81dc4:	8b000020 	add	x0, x1, x0
   81dc8:	f9400000 	ldr	x0, [x0]
   81dcc:	f90023e0 	str	x0, [sp, #64]
   81dd0:	1400006b 	b	81f7c <memory_reserve+0x220>

            int frame_start = it->idx, frame_end = it->idx + (1 << it->val); // get the range of frames
   81dd4:	f94023e0 	ldr	x0, [sp, #64]
   81dd8:	b9401000 	ldr	w0, [x0, #16]
   81ddc:	b9003fe0 	str	w0, [sp, #60]
   81de0:	f94023e0 	ldr	x0, [sp, #64]
   81de4:	b9401000 	ldr	w0, [x0, #16]
   81de8:	f94023e1 	ldr	x1, [sp, #64]
   81dec:	b9401821 	ldr	w1, [x1, #24]
   81df0:	52800022 	mov	w2, #0x1                   	// #1
   81df4:	1ac12041 	lsl	w1, w2, w1
   81df8:	0b010000 	add	w0, w0, w1
   81dfc:	b9003be0 	str	w0, [sp, #56]
            // reserve
            if (start <= frame_start && frame_end <= end) {
   81e00:	b9803fe0 	ldrsw	x0, [sp, #60]
   81e04:	f9400fe1 	ldr	x1, [sp, #24]
   81e08:	eb00003f 	cmp	x1, x0
   81e0c:	540002c8 	b.hi	81e64 <memory_reserve+0x108>  // b.pmore
   81e10:	b9803be0 	ldrsw	x0, [sp, #56]
   81e14:	f9400be1 	ldr	x1, [sp, #16]
   81e18:	eb00003f 	cmp	x1, x0
   81e1c:	54000243 	b.cc	81e64 <memory_reserve+0x108>  // b.lo, b.ul, b.last
                // uart_sendline("[Reserve] 0x%8x ~ 0x%8x\n", ((it->idx << PAGE_LEVEL) + ALLOCATION_BASE),
                //               (((it->idx + (1 << it->val)) << PAGE_LEVEL) + ALLOCATION_BASE));
                it->used = FRAME_OCCUPIED_FLAG;
   81e20:	f94023e0 	ldr	x0, [sp, #64]
   81e24:	12800021 	mov	w1, #0xfffffffe            	// #-2
   81e28:	b9001401 	str	w1, [x0, #20]
                it->prev->next = it->next;
   81e2c:	f94023e0 	ldr	x0, [sp, #64]
   81e30:	f9400400 	ldr	x0, [x0, #8]
   81e34:	f94023e1 	ldr	x1, [sp, #64]
   81e38:	f9400021 	ldr	x1, [x1]
   81e3c:	f9000001 	str	x1, [x0]
                it->next->prev = it->prev;
   81e40:	f94023e0 	ldr	x0, [sp, #64]
   81e44:	f9400000 	ldr	x0, [x0]
   81e48:	f94023e1 	ldr	x1, [sp, #64]
   81e4c:	f9400421 	ldr	x1, [x1, #8]
   81e50:	f9000401 	str	x1, [x0, #8]
                it = it->next;
   81e54:	f94023e0 	ldr	x0, [sp, #64]
   81e58:	f9400000 	ldr	x0, [x0]
   81e5c:	f90023e0 	str	x0, [sp, #64]
   81e60:	14000047 	b	81f7c <memory_reserve+0x220>
            }
            // free
            else if (frame_start >= end || frame_end <= start) {
   81e64:	b9803fe0 	ldrsw	x0, [sp, #60]
   81e68:	f9400be1 	ldr	x1, [sp, #16]
   81e6c:	eb00003f 	cmp	x1, x0
   81e70:	540000a9 	b.ls	81e84 <memory_reserve+0x128>  // b.plast
   81e74:	b9803be0 	ldrsw	x0, [sp, #56]
   81e78:	f9400fe1 	ldr	x1, [sp, #24]
   81e7c:	eb00003f 	cmp	x1, x0
   81e80:	540000a3 	b.cc	81e94 <memory_reserve+0x138>  // b.lo, b.ul, b.last
                it = it->next;
   81e84:	f94023e0 	ldr	x0, [sp, #64]
   81e88:	f9400000 	ldr	x0, [x0]
   81e8c:	f90023e0 	str	x0, [sp, #64]
   81e90:	1400003b 	b	81f7c <memory_reserve+0x220>
            }
            // remove it, cut half, go next iteration
            else {
                it->prev->next = it->next; // remove
   81e94:	f94023e0 	ldr	x0, [sp, #64]
   81e98:	f9400400 	ldr	x0, [x0, #8]
   81e9c:	f94023e1 	ldr	x1, [sp, #64]
   81ea0:	f9400021 	ldr	x1, [x1]
   81ea4:	f9000001 	str	x1, [x0]
                it->next->prev = it->prev;
   81ea8:	f94023e0 	ldr	x0, [sp, #64]
   81eac:	f9400000 	ldr	x0, [x0]
   81eb0:	f94023e1 	ldr	x1, [sp, #64]
   81eb4:	f9400421 	ldr	x1, [x1, #8]
   81eb8:	f9000401 	str	x1, [x0, #8]

                frame *buddy = &frame_array[it->idx ^ (1 << (expo - 1))]; // get its buddy (another half)
   81ebc:	f0000020 	adrp	x0, 88000 <cmd_list+0x980>
   81ec0:	911f4000 	add	x0, x0, #0x7d0
   81ec4:	f9400001 	ldr	x1, [x0]
   81ec8:	f94023e0 	ldr	x0, [sp, #64]
   81ecc:	b9401000 	ldr	w0, [x0, #16]
   81ed0:	b9404fe2 	ldr	w2, [sp, #76]
   81ed4:	51000442 	sub	w2, w2, #0x1
   81ed8:	52800023 	mov	w3, #0x1                   	// #1
   81edc:	1ac22062 	lsl	w2, w3, w2
   81ee0:	4a020000 	eor	w0, w0, w2
   81ee4:	2a0003e0 	mov	w0, w0
   81ee8:	d37be800 	lsl	x0, x0, #5
   81eec:	8b000020 	add	x0, x1, x0
   81ef0:	f9001be0 	str	x0, [sp, #48]
                it->val--;
   81ef4:	f94023e0 	ldr	x0, [sp, #64]
   81ef8:	b9401800 	ldr	w0, [x0, #24]
   81efc:	51000401 	sub	w1, w0, #0x1
   81f00:	f94023e0 	ldr	x0, [sp, #64]
   81f04:	b9001801 	str	w1, [x0, #24]
                buddy->val = it->val;
   81f08:	f94023e0 	ldr	x0, [sp, #64]
   81f0c:	b9401801 	ldr	w1, [x0, #24]
   81f10:	f9401be0 	ldr	x0, [sp, #48]
   81f14:	b9001801 	str	w1, [x0, #24]

                frame *tmp = it->next; // backup it.next
   81f18:	f94023e0 	ldr	x0, [sp, #64]
   81f1c:	f9400000 	ldr	x0, [x0]
   81f20:	f90017e0 	str	x0, [sp, #40]

                insert_frame_node(buddy, &free_frame_list[expo - 1]); // add to lower level list
   81f24:	f0000020 	adrp	x0, 88000 <cmd_list+0x980>
   81f28:	911f6000 	add	x0, x0, #0x7d8
   81f2c:	f9400001 	ldr	x1, [x0]
   81f30:	b9804fe0 	ldrsw	x0, [sp, #76]
   81f34:	d37be800 	lsl	x0, x0, #5
   81f38:	d1008000 	sub	x0, x0, #0x20
   81f3c:	8b000020 	add	x0, x1, x0
   81f40:	aa0003e1 	mov	x1, x0
   81f44:	f9401be0 	ldr	x0, [sp, #48]
   81f48:	97fffc78 	bl	81128 <insert_frame_node>
                insert_frame_node(it, &free_frame_list[expo - 1]);
   81f4c:	f0000020 	adrp	x0, 88000 <cmd_list+0x980>
   81f50:	911f6000 	add	x0, x0, #0x7d8
   81f54:	f9400001 	ldr	x1, [x0]
   81f58:	b9804fe0 	ldrsw	x0, [sp, #76]
   81f5c:	d37be800 	lsl	x0, x0, #5
   81f60:	d1008000 	sub	x0, x0, #0x20
   81f64:	8b000020 	add	x0, x1, x0
   81f68:	aa0003e1 	mov	x1, x0
   81f6c:	f94023e0 	ldr	x0, [sp, #64]
   81f70:	97fffc6e 	bl	81128 <insert_frame_node>

                it = tmp; // restore
   81f74:	f94017e0 	ldr	x0, [sp, #40]
   81f78:	f90023e0 	str	x0, [sp, #64]
        for (frame *it = free_frame_list[expo].next; it != &free_frame_list[expo];) {
   81f7c:	f0000020 	adrp	x0, 88000 <cmd_list+0x980>
   81f80:	911f6000 	add	x0, x0, #0x7d8
   81f84:	f9400001 	ldr	x1, [x0]
   81f88:	b9804fe0 	ldrsw	x0, [sp, #76]
   81f8c:	d37be800 	lsl	x0, x0, #5
   81f90:	8b000020 	add	x0, x1, x0
   81f94:	f94023e1 	ldr	x1, [sp, #64]
   81f98:	eb00003f 	cmp	x1, x0
   81f9c:	54fff1c1 	b.ne	81dd4 <memory_reserve+0x78>  // b.any
    for (int expo = MAX_PAGE_EXP; expo >= 0; expo--) {
   81fa0:	b9404fe0 	ldr	w0, [sp, #76]
   81fa4:	51000400 	sub	w0, w0, #0x1
   81fa8:	b9004fe0 	str	w0, [sp, #76]
   81fac:	b9404fe0 	ldr	w0, [sp, #76]
   81fb0:	7100001f 	cmp	w0, #0x0
   81fb4:	54ffefea 	b.ge	81db0 <memory_reserve+0x54>  // b.tcont
            }
        }
    }
   81fb8:	d503201f 	nop
   81fbc:	d503201f 	nop
   81fc0:	a8c57bfd 	ldp	x29, x30, [sp], #80
   81fc4:	d65f03c0 	ret

0000000000081fc8 <do_cmd_exec>:
    {.command = "mem_test", .help = "lazy testing kmalloc and kfree"},
    {.command = "thread_test", .help = "test threads interleaving"},
    {.command = "syscall_test", .help = "test syscall"},
};

void do_cmd_exec(char *filepath) {
   81fc8:	a9bb7bfd 	stp	x29, x30, [sp, #-80]!
   81fcc:	910003fd 	mov	x29, sp
   81fd0:	f9000fe0 	str	x0, [sp, #24]
    char *c_filepath;
    char *c_filedata;
    unsigned int c_filesize;
    struct cpio_newc_header *header_ptr = CPIO_DEFAULT_START;
   81fd4:	f0000020 	adrp	x0, 88000 <cmd_list+0x980>
   81fd8:	911fa000 	add	x0, x0, #0x7e8
   81fdc:	f9400000 	ldr	x0, [x0]
   81fe0:	f90017e0 	str	x0, [sp, #40]

    // traverse the whole ramdisk, check filename one by one
    while (header_ptr != 0) {
   81fe4:	14000023 	b	82070 <do_cmd_exec+0xa8>
        // function return -1 when error
        int error = cpio_newc_parse_header(header_ptr, &c_filepath, &c_filesize, &c_filedata, &header_ptr);
   81fe8:	f94017e0 	ldr	x0, [sp, #40]
   81fec:	9100a3e4 	add	x4, sp, #0x28
   81ff0:	9100e3e3 	add	x3, sp, #0x38
   81ff4:	9100d3e2 	add	x2, sp, #0x34
   81ff8:	910103e1 	add	x1, sp, #0x40
   81ffc:	97fff872 	bl	801c4 <cpio_newc_parse_header>
   82000:	b9004fe0 	str	w0, [sp, #76]
        if (error) {
   82004:	b9404fe0 	ldr	w0, [sp, #76]
   82008:	7100001f 	cmp	w0, #0x0
   8200c:	540000a0 	b.eq	82020 <do_cmd_exec+0x58>  // b.none
            uart_sendline("cpio parse error");
   82010:	90000020 	adrp	x0, 86000 <el1t_irq_invalid+0x78>
   82014:	91134000 	add	x0, x0, #0x4d0
   82018:	94000bb4 	bl	84ee8 <uart_sendline>
            break;
   8201c:	14000019 	b	82080 <do_cmd_exec+0xb8>
        }

        // if match
        if (strcmp(c_filepath, filepath) == 0) {
   82020:	f94023e0 	ldr	x0, [sp, #64]
   82024:	f9400fe1 	ldr	x1, [sp, #24]
   82028:	940009f1 	bl	847ec <strcmp>
   8202c:	7100001f 	cmp	w0, #0x0
   82030:	54000121 	b.ne	82054 <do_cmd_exec+0x8c>  // b.any
            // char *ustack = simple_malloc(256);
            // asm volatile("msr spsr_el1, %0;" ::"r"(0x3c0));      // set state to user mode, and enable interrupt
            // asm volatile("msr elr_el1, %0;" ::"r"(c_filedata));  // set exception return addr to 'c_filedata'
            // asm volatile("msr sp_el0, %0;" ::"r"(ustack + 256)); // set el0's sp to top of new stack
            // asm volatile("eret;");                               // switch EL to 0
            uart_recv_echo_flag = 0;
   82034:	d0000020 	adrp	x0, 88000 <cmd_list+0x980>
   82038:	f942e400 	ldr	x0, [x0, #1480]
   8203c:	b900001f 	str	wzr, [x0]
            thread_exec(c_filedata, c_filesize);
   82040:	f9401fe0 	ldr	x0, [sp, #56]
   82044:	b94037e1 	ldr	w1, [sp, #52]
   82048:	12001c21 	and	w1, w1, #0xff
   8204c:	940006d7 	bl	83ba8 <thread_exec>
            break;
   82050:	1400000c 	b	82080 <do_cmd_exec+0xb8>
        }

        // if meet TRAILER!!! (last file)
        if (header_ptr == 0)
   82054:	f94017e0 	ldr	x0, [sp, #40]
   82058:	f100001f 	cmp	x0, #0x0
   8205c:	540000a1 	b.ne	82070 <do_cmd_exec+0xa8>  // b.any
            uart_sendline("cat: %s: No such file or directory.\n", filepath);
   82060:	f9400fe1 	ldr	x1, [sp, #24]
   82064:	90000020 	adrp	x0, 86000 <el1t_irq_invalid+0x78>
   82068:	9113a000 	add	x0, x0, #0x4e8
   8206c:	94000b9f 	bl	84ee8 <uart_sendline>
    while (header_ptr != 0) {
   82070:	f94017e0 	ldr	x0, [sp, #40]
   82074:	f100001f 	cmp	x0, #0x0
   82078:	54fffb81 	b.ne	81fe8 <do_cmd_exec+0x20>  // b.any
    }
}
   8207c:	d503201f 	nop
   82080:	d503201f 	nop
   82084:	a8c57bfd 	ldp	x29, x30, [sp], #80
   82088:	d65f03c0 	ret

000000000008208c <cli_cmd_strcmp>:

int cli_cmd_strcmp(const char *p1, const char *p2) {
   8208c:	d100c3ff 	sub	sp, sp, #0x30
   82090:	f90007e0 	str	x0, [sp, #8]
   82094:	f90003e1 	str	x1, [sp]
    const unsigned char *s1 = (const unsigned char *)p1;
   82098:	f94007e0 	ldr	x0, [sp, #8]
   8209c:	f90017e0 	str	x0, [sp, #40]
    const unsigned char *s2 = (const unsigned char *)p2;
   820a0:	f94003e0 	ldr	x0, [sp]
   820a4:	f90013e0 	str	x0, [sp, #32]
    unsigned char c1, c2;

    do {
        c1 = (unsigned char)*s1++;
   820a8:	f94017e0 	ldr	x0, [sp, #40]
   820ac:	91000401 	add	x1, x0, #0x1
   820b0:	f90017e1 	str	x1, [sp, #40]
   820b4:	39400000 	ldrb	w0, [x0]
   820b8:	39007fe0 	strb	w0, [sp, #31]
        c2 = (unsigned char)*s2++;
   820bc:	f94013e0 	ldr	x0, [sp, #32]
   820c0:	91000401 	add	x1, x0, #0x1
   820c4:	f90013e1 	str	x1, [sp, #32]
   820c8:	39400000 	ldrb	w0, [x0]
   820cc:	39007be0 	strb	w0, [sp, #30]
        if (c1 == '\0')
   820d0:	39407fe0 	ldrb	w0, [sp, #31]
   820d4:	7100001f 	cmp	w0, #0x0
   820d8:	540000a1 	b.ne	820ec <cli_cmd_strcmp+0x60>  // b.any
            return c1 - c2;
   820dc:	39407fe1 	ldrb	w1, [sp, #31]
   820e0:	39407be0 	ldrb	w0, [sp, #30]
   820e4:	4b000020 	sub	w0, w1, w0
   820e8:	14000008 	b	82108 <cli_cmd_strcmp+0x7c>
    } while (c1 == c2);
   820ec:	39407fe1 	ldrb	w1, [sp, #31]
   820f0:	39407be0 	ldrb	w0, [sp, #30]
   820f4:	6b00003f 	cmp	w1, w0
   820f8:	54fffd80 	b.eq	820a8 <cli_cmd_strcmp+0x1c>  // b.none
    return c1 - c2;
   820fc:	39407fe1 	ldrb	w1, [sp, #31]
   82100:	39407be0 	ldrb	w0, [sp, #30]
   82104:	4b000020 	sub	w0, w1, w0
}
   82108:	9100c3ff 	add	sp, sp, #0x30
   8210c:	d65f03c0 	ret

0000000000082110 <cli_cmd_clear>:

void cli_cmd_clear(char *buffer, int length) {
   82110:	d10083ff 	sub	sp, sp, #0x20
   82114:	f90007e0 	str	x0, [sp, #8]
   82118:	b90007e1 	str	w1, [sp, #4]
    for (int i = 0; i < length; i++) {
   8211c:	b9001fff 	str	wzr, [sp, #28]
   82120:	14000008 	b	82140 <cli_cmd_clear+0x30>
        buffer[i] = '\0';
   82124:	b9801fe0 	ldrsw	x0, [sp, #28]
   82128:	f94007e1 	ldr	x1, [sp, #8]
   8212c:	8b000020 	add	x0, x1, x0
   82130:	3900001f 	strb	wzr, [x0]
    for (int i = 0; i < length; i++) {
   82134:	b9401fe0 	ldr	w0, [sp, #28]
   82138:	11000400 	add	w0, w0, #0x1
   8213c:	b9001fe0 	str	w0, [sp, #28]
   82140:	b9401fe1 	ldr	w1, [sp, #28]
   82144:	b94007e0 	ldr	w0, [sp, #4]
   82148:	6b00003f 	cmp	w1, w0
   8214c:	54fffecb 	b.lt	82124 <cli_cmd_clear+0x14>  // b.tstop
    }
};
   82150:	d503201f 	nop
   82154:	d503201f 	nop
   82158:	910083ff 	add	sp, sp, #0x20
   8215c:	d65f03c0 	ret

0000000000082160 <cli_cmd_read>:

void cli_cmd_read(char *buffer) {
   82160:	a9bd7bfd 	stp	x29, x30, [sp, #-48]!
   82164:	910003fd 	mov	x29, sp
   82168:	f9000fe0 	str	x0, [sp, #24]
    int idx = 0;
   8216c:	b9002fff 	str	wzr, [sp, #44]

    while (1) {
        char c = uart_async_getc();
   82170:	94000c17 	bl	851cc <uart_async_getc>
   82174:	3900afe0 	strb	w0, [sp, #43]

        if (c == '\n') {
   82178:	3940afe0 	ldrb	w0, [sp, #43]
   8217c:	7100281f 	cmp	w0, #0xa
   82180:	540000c1 	b.ne	82198 <cli_cmd_read+0x38>  // b.any
            // uart_send(c);
            buffer[idx] = '\0';
   82184:	b9802fe0 	ldrsw	x0, [sp, #44]
   82188:	f9400fe1 	ldr	x1, [sp, #24]
   8218c:	8b000020 	add	x0, x1, x0
   82190:	3900001f 	strb	wzr, [x0]
            break;
   82194:	14000026 	b	8222c <cli_cmd_read+0xcc>
        } else if (c >= 32 && c <= 126) {
   82198:	3940afe0 	ldrb	w0, [sp, #43]
   8219c:	71007c1f 	cmp	w0, #0x1f
   821a0:	540001a9 	b.ls	821d4 <cli_cmd_read+0x74>  // b.plast
   821a4:	3940afe0 	ldrb	w0, [sp, #43]
   821a8:	7101f81f 	cmp	w0, #0x7e
   821ac:	54000148 	b.hi	821d4 <cli_cmd_read+0x74>  // b.pmore
            // uart_send(c);
            buffer[idx++] = c;
   821b0:	b9402fe0 	ldr	w0, [sp, #44]
   821b4:	11000401 	add	w1, w0, #0x1
   821b8:	b9002fe1 	str	w1, [sp, #44]
   821bc:	93407c00 	sxtw	x0, w0
   821c0:	f9400fe1 	ldr	x1, [sp, #24]
   821c4:	8b000020 	add	x0, x1, x0
   821c8:	3940afe1 	ldrb	w1, [sp, #43]
   821cc:	39000001 	strb	w1, [x0]
   821d0:	14000016 	b	82228 <cli_cmd_read+0xc8>
        } else if (c == 127) {
   821d4:	3940afe0 	ldrb	w0, [sp, #43]
   821d8:	7101fc1f 	cmp	w0, #0x7f
   821dc:	54000241 	b.ne	82224 <cli_cmd_read+0xc4>  // b.any
            // Handle backspaces
            if (idx > 0) {
   821e0:	b9402fe0 	ldr	w0, [sp, #44]
   821e4:	7100001f 	cmp	w0, #0x0
   821e8:	54fffc4d 	b.le	82170 <cli_cmd_read+0x10>
                buffer[idx--] = 0;
   821ec:	b9402fe0 	ldr	w0, [sp, #44]
   821f0:	51000401 	sub	w1, w0, #0x1
   821f4:	b9002fe1 	str	w1, [sp, #44]
   821f8:	93407c00 	sxtw	x0, w0
   821fc:	f9400fe1 	ldr	x1, [sp, #24]
   82200:	8b000020 	add	x0, x1, x0
   82204:	3900001f 	strb	wzr, [x0]
                uart_send('\b');
   82208:	52800100 	mov	w0, #0x8                   	// #8
   8220c:	94000b06 	bl	84e24 <uart_send>
                uart_send(' ');
   82210:	52800400 	mov	w0, #0x20                  	// #32
   82214:	94000b04 	bl	84e24 <uart_send>
                uart_send('\b');
   82218:	52800100 	mov	w0, #0x8                   	// #8
   8221c:	94000b02 	bl	84e24 <uart_send>
   82220:	17ffffd4 	b	82170 <cli_cmd_read+0x10>
            }
        } else {
            // Ignore unprintable chars
            continue;
   82224:	d503201f 	nop
    while (1) {
   82228:	17ffffd2 	b	82170 <cli_cmd_read+0x10>
        }
    }
}
   8222c:	d503201f 	nop
   82230:	a8c37bfd 	ldp	x29, x30, [sp], #48
   82234:	d65f03c0 	ret

0000000000082238 <cli_cmd_exec>:

void cli_cmd_exec(char *buffer) {
   82238:	a9bc7bfd 	stp	x29, x30, [sp, #-64]!
   8223c:	910003fd 	mov	x29, sp
   82240:	f9000fe0 	str	x0, [sp, #24]
    if (!buffer)
   82244:	f9400fe0 	ldr	x0, [sp, #24]
   82248:	f100001f 	cmp	x0, #0x0
   8224c:	54001420 	b.eq	824d0 <cli_cmd_exec+0x298>  // b.none
        return;

    char *cmd = buffer;
   82250:	f9400fe0 	ldr	x0, [sp, #24]
   82254:	f9001be0 	str	x0, [sp, #48]
    char *argvs; // get the first param after cmd

    while (1) {
        if (*buffer == '\0') {
   82258:	f9400fe0 	ldr	x0, [sp, #24]
   8225c:	39400000 	ldrb	w0, [x0]
   82260:	7100001f 	cmp	w0, #0x0
   82264:	54000081 	b.ne	82274 <cli_cmd_exec+0x3c>  // b.any
            argvs = buffer;
   82268:	f9400fe0 	ldr	x0, [sp, #24]
   8226c:	f9001fe0 	str	x0, [sp, #56]
            break;
   82270:	1400000f 	b	822ac <cli_cmd_exec+0x74>
        }
        if (*buffer == ' ') {
   82274:	f9400fe0 	ldr	x0, [sp, #24]
   82278:	39400000 	ldrb	w0, [x0]
   8227c:	7100801f 	cmp	w0, #0x20
   82280:	540000e1 	b.ne	8229c <cli_cmd_exec+0x64>  // b.any
            *buffer = '\0';
   82284:	f9400fe0 	ldr	x0, [sp, #24]
   82288:	3900001f 	strb	wzr, [x0]
            argvs = buffer + 1;
   8228c:	f9400fe0 	ldr	x0, [sp, #24]
   82290:	91000400 	add	x0, x0, #0x1
   82294:	f9001fe0 	str	x0, [sp, #56]
            break;
   82298:	14000005 	b	822ac <cli_cmd_exec+0x74>
        }
        buffer++;
   8229c:	f9400fe0 	ldr	x0, [sp, #24]
   822a0:	91000400 	add	x0, x0, #0x1
   822a4:	f9000fe0 	str	x0, [sp, #24]
        if (*buffer == '\0') {
   822a8:	17ffffec 	b	82258 <cli_cmd_exec+0x20>
    }

    if (strcmp(cmd, "cat") == 0) {
   822ac:	90000020 	adrp	x0, 86000 <el1t_irq_invalid+0x78>
   822b0:	91144001 	add	x1, x0, #0x510
   822b4:	f9401be0 	ldr	x0, [sp, #48]
   822b8:	9400094d 	bl	847ec <strcmp>
   822bc:	7100001f 	cmp	w0, #0x0
   822c0:	54000081 	b.ne	822d0 <cli_cmd_exec+0x98>  // b.any
        do_cmd_cat(argvs);
   822c4:	f9401fe0 	ldr	x0, [sp, #56]
   822c8:	940000c6 	bl	825e0 <do_cmd_cat>
   822cc:	14000082 	b	824d4 <cli_cmd_exec+0x29c>
    } else if (strcmp(cmd, "dtb") == 0) {
   822d0:	90000020 	adrp	x0, 86000 <el1t_irq_invalid+0x78>
   822d4:	91146001 	add	x1, x0, #0x518
   822d8:	f9401be0 	ldr	x0, [sp, #48]
   822dc:	94000944 	bl	847ec <strcmp>
   822e0:	7100001f 	cmp	w0, #0x0
   822e4:	54000061 	b.ne	822f0 <cli_cmd_exec+0xb8>  // b.any
        do_cmd_dtb();
   822e8:	940000ef 	bl	826a4 <do_cmd_dtb>
   822ec:	1400007a 	b	824d4 <cli_cmd_exec+0x29c>
    } else if (strcmp(cmd, "hello") == 0) {
   822f0:	90000020 	adrp	x0, 86000 <el1t_irq_invalid+0x78>
   822f4:	91148001 	add	x1, x0, #0x520
   822f8:	f9401be0 	ldr	x0, [sp, #48]
   822fc:	9400093c 	bl	847ec <strcmp>
   82300:	7100001f 	cmp	w0, #0x0
   82304:	54000061 	b.ne	82310 <cli_cmd_exec+0xd8>  // b.any
        do_cmd_hello();
   82308:	94000114 	bl	82758 <do_cmd_hello>
   8230c:	14000072 	b	824d4 <cli_cmd_exec+0x29c>
    } else if (strcmp(cmd, "help") == 0) {
   82310:	90000020 	adrp	x0, 86000 <el1t_irq_invalid+0x78>
   82314:	9114a001 	add	x1, x0, #0x528
   82318:	f9401be0 	ldr	x0, [sp, #48]
   8231c:	94000934 	bl	847ec <strcmp>
   82320:	7100001f 	cmp	w0, #0x0
   82324:	54000061 	b.ne	82330 <cli_cmd_exec+0xf8>  // b.any
        do_cmd_help();
   82328:	940000eb 	bl	826d4 <do_cmd_help>
   8232c:	1400006a 	b	824d4 <cli_cmd_exec+0x29c>
    } else if (strcmp(cmd, "info") == 0) {
   82330:	90000020 	adrp	x0, 86000 <el1t_irq_invalid+0x78>
   82334:	9114c001 	add	x1, x0, #0x530
   82338:	f9401be0 	ldr	x0, [sp, #48]
   8233c:	9400092c 	bl	847ec <strcmp>
   82340:	7100001f 	cmp	w0, #0x0
   82344:	54000061 	b.ne	82350 <cli_cmd_exec+0x118>  // b.any
        do_cmd_info();
   82348:	9400010c 	bl	82778 <do_cmd_info>
   8234c:	14000062 	b	824d4 <cli_cmd_exec+0x29c>
    } else if (strcmp(cmd, "simple_malloc") == 0) {
   82350:	90000020 	adrp	x0, 86000 <el1t_irq_invalid+0x78>
   82354:	9114e001 	add	x1, x0, #0x538
   82358:	f9401be0 	ldr	x0, [sp, #48]
   8235c:	94000924 	bl	847ec <strcmp>
   82360:	7100001f 	cmp	w0, #0x0
   82364:	54000061 	b.ne	82370 <cli_cmd_exec+0x138>  // b.any
        do_cmd_simple_malloc();
   82368:	94000171 	bl	8292c <do_cmd_simple_malloc>
   8236c:	1400005a 	b	824d4 <cli_cmd_exec+0x29c>
    } else if (strcmp(cmd, "ls") == 0) {
   82370:	90000020 	adrp	x0, 86000 <el1t_irq_invalid+0x78>
   82374:	91152001 	add	x1, x0, #0x548
   82378:	f9401be0 	ldr	x0, [sp, #48]
   8237c:	9400091c 	bl	847ec <strcmp>
   82380:	7100001f 	cmp	w0, #0x0
   82384:	54000081 	b.ne	82394 <cli_cmd_exec+0x15c>  // b.any
        do_cmd_ls(argvs);
   82388:	f9401fe0 	ldr	x0, [sp, #56]
   8238c:	94000191 	bl	829d0 <do_cmd_ls>
   82390:	14000051 	b	824d4 <cli_cmd_exec+0x29c>
    } else if (strcmp(cmd, "exec") == 0) {
   82394:	90000020 	adrp	x0, 86000 <el1t_irq_invalid+0x78>
   82398:	91154001 	add	x1, x0, #0x550
   8239c:	f9401be0 	ldr	x0, [sp, #48]
   823a0:	94000913 	bl	847ec <strcmp>
   823a4:	7100001f 	cmp	w0, #0x0
   823a8:	54000081 	b.ne	823b8 <cli_cmd_exec+0x180>  // b.any
        do_cmd_exec(argvs);
   823ac:	f9401fe0 	ldr	x0, [sp, #56]
   823b0:	97ffff06 	bl	81fc8 <do_cmd_exec>
   823b4:	14000048 	b	824d4 <cli_cmd_exec+0x29c>
    } else if (strcmp(cmd, "reboot") == 0) {
   823b8:	90000020 	adrp	x0, 86000 <el1t_irq_invalid+0x78>
   823bc:	91156001 	add	x1, x0, #0x558
   823c0:	f9401be0 	ldr	x0, [sp, #48]
   823c4:	9400090a 	bl	847ec <strcmp>
   823c8:	7100001f 	cmp	w0, #0x0
   823cc:	54000061 	b.ne	823d8 <cli_cmd_exec+0x1a0>  // b.any
        do_cmd_reboot();
   823d0:	940001a5 	bl	82a64 <do_cmd_reboot>
   823d4:	14000040 	b	824d4 <cli_cmd_exec+0x29c>
    } else if (strcmp(cmd, "set2sAlert") == 0) {
   823d8:	90000020 	adrp	x0, 86000 <el1t_irq_invalid+0x78>
   823dc:	91158001 	add	x1, x0, #0x560
   823e0:	f9401be0 	ldr	x0, [sp, #48]
   823e4:	94000902 	bl	847ec <strcmp>
   823e8:	7100001f 	cmp	w0, #0x0
   823ec:	540000a1 	b.ne	82400 <cli_cmd_exec+0x1c8>  // b.any
        do_cmd_set2sTimer("2s time's up");
   823f0:	90000020 	adrp	x0, 86000 <el1t_irq_invalid+0x78>
   823f4:	9115c000 	add	x0, x0, #0x570
   823f8:	940001b1 	bl	82abc <do_cmd_set2sTimer>
   823fc:	14000036 	b	824d4 <cli_cmd_exec+0x29c>
    } else if (strcmp(cmd, "setTimer") == 0) {
   82400:	90000020 	adrp	x0, 86000 <el1t_irq_invalid+0x78>
   82404:	91160001 	add	x1, x0, #0x580
   82408:	f9401be0 	ldr	x0, [sp, #48]
   8240c:	940008f8 	bl	847ec <strcmp>
   82410:	7100001f 	cmp	w0, #0x0
   82414:	54000141 	b.ne	8243c <cli_cmd_exec+0x204>  // b.any
        char *sec = str_SepbySpace(argvs);
   82418:	f9401fe0 	ldr	x0, [sp, #56]
   8241c:	940009c5 	bl	84b30 <str_SepbySpace>
   82420:	f90017e0 	str	x0, [sp, #40]
        do_cmd_setTimer(argvs, atoi(sec));
   82424:	f94017e0 	ldr	x0, [sp, #40]
   82428:	940009dc 	bl	84b98 <atoi>
   8242c:	2a0003e1 	mov	w1, w0
   82430:	f9401fe0 	ldr	x0, [sp, #56]
   82434:	940001bb 	bl	82b20 <do_cmd_setTimer>
   82438:	14000027 	b	824d4 <cli_cmd_exec+0x29c>
    } else if (strcmp(cmd, "testAsyncUart") == 0) {
   8243c:	90000020 	adrp	x0, 86000 <el1t_irq_invalid+0x78>
   82440:	91164001 	add	x1, x0, #0x590
   82444:	f9401be0 	ldr	x0, [sp, #48]
   82448:	940008e9 	bl	847ec <strcmp>
   8244c:	7100001f 	cmp	w0, #0x0
   82450:	54000061 	b.ne	8245c <cli_cmd_exec+0x224>  // b.any
        do_cmd_testAsyncUart();
   82454:	94000022 	bl	824dc <do_cmd_testAsyncUart>
   82458:	1400001f 	b	824d4 <cli_cmd_exec+0x29c>
    } else if (strcmp(cmd, "mem_test") == 0) {
   8245c:	90000020 	adrp	x0, 86000 <el1t_irq_invalid+0x78>
   82460:	91168001 	add	x1, x0, #0x5a0
   82464:	f9401be0 	ldr	x0, [sp, #48]
   82468:	940008e1 	bl	847ec <strcmp>
   8246c:	7100001f 	cmp	w0, #0x0
   82470:	54000061 	b.ne	8247c <cli_cmd_exec+0x244>  // b.any
        do_cmd_mem_test();
   82474:	940001bc 	bl	82b64 <do_cmd_mem_test>
   82478:	14000017 	b	824d4 <cli_cmd_exec+0x29c>
    } else if (strcmp(cmd, "thread_test") == 0) {
   8247c:	90000020 	adrp	x0, 86000 <el1t_irq_invalid+0x78>
   82480:	9116c001 	add	x1, x0, #0x5b0
   82484:	f9401be0 	ldr	x0, [sp, #48]
   82488:	940008d9 	bl	847ec <strcmp>
   8248c:	7100001f 	cmp	w0, #0x0
   82490:	54000061 	b.ne	8249c <cli_cmd_exec+0x264>  // b.any
        do_cmd_thread_test();
   82494:	9400022d 	bl	82d48 <do_cmd_thread_test>
   82498:	1400000f 	b	824d4 <cli_cmd_exec+0x29c>
    } else if (strcmp(cmd, "syscall_test") == 0) {
   8249c:	90000020 	adrp	x0, 86000 <el1t_irq_invalid+0x78>
   824a0:	91170001 	add	x1, x0, #0x5c0
   824a4:	f9401be0 	ldr	x0, [sp, #48]
   824a8:	940008d1 	bl	847ec <strcmp>
   824ac:	7100001f 	cmp	w0, #0x0
   824b0:	54000061 	b.ne	824bc <cli_cmd_exec+0x284>  // b.any
        do_cmd_syscall_test();
   824b4:	9400023b 	bl	82da0 <do_cmd_syscall_test>
   824b8:	14000007 	b	824d4 <cli_cmd_exec+0x29c>
    } else {
        uart_sendline("%s : command not found\n", cmd);
   824bc:	f9401be1 	ldr	x1, [sp, #48]
   824c0:	90000020 	adrp	x0, 86000 <el1t_irq_invalid+0x78>
   824c4:	91174000 	add	x0, x0, #0x5d0
   824c8:	94000a88 	bl	84ee8 <uart_sendline>
   824cc:	14000002 	b	824d4 <cli_cmd_exec+0x29c>
        return;
   824d0:	d503201f 	nop
    }
}
   824d4:	a8c47bfd 	ldp	x29, x30, [sp], #64
   824d8:	d65f03c0 	ret

00000000000824dc <do_cmd_testAsyncUart>:

void do_cmd_testAsyncUart() {
   824dc:	a9b67bfd 	stp	x29, x30, [sp, #-160]!
   824e0:	910003fd 	mov	x29, sp
    while (1) {
        uart_sendline("type 'q' to quit\n");
   824e4:	90000020 	adrp	x0, 86000 <el1t_irq_invalid+0x78>
   824e8:	9117a000 	add	x0, x0, #0x5e8
   824ec:	94000a7f 	bl	84ee8 <uart_sendline>
        char buffer[CMD_MAX_LEN];
        int idx = 0;
   824f0:	b9009fff 	str	wzr, [sp, #156]
        while (idx < CMD_MAX_LEN) {
   824f4:	1400000d 	b	82528 <do_cmd_testAsyncUart+0x4c>
            char c = uart_async_getc();
   824f8:	94000b35 	bl	851cc <uart_async_getc>
   824fc:	39025fe0 	strb	w0, [sp, #151]
            buffer[idx++] = c;
   82500:	b9409fe0 	ldr	w0, [sp, #156]
   82504:	11000401 	add	w1, w0, #0x1
   82508:	b9009fe1 	str	w1, [sp, #156]
   8250c:	93407c00 	sxtw	x0, w0
   82510:	910043e1 	add	x1, sp, #0x10
   82514:	39425fe2 	ldrb	w2, [sp, #151]
   82518:	38206822 	strb	w2, [x1, x0]
            if (c == '\n')
   8251c:	39425fe0 	ldrb	w0, [sp, #151]
   82520:	7100281f 	cmp	w0, #0xa
   82524:	540000a0 	b.eq	82538 <do_cmd_testAsyncUart+0x5c>  // b.none
        while (idx < CMD_MAX_LEN) {
   82528:	b9409fe0 	ldr	w0, [sp, #156]
   8252c:	7101fc1f 	cmp	w0, #0x7f
   82530:	54fffe4d 	b.le	824f8 <do_cmd_testAsyncUart+0x1c>
   82534:	14000002 	b	8253c <do_cmd_testAsyncUart+0x60>
                break;
   82538:	d503201f 	nop
        }
        if (buffer[0] == 'q' && buffer[1] == '\n')
   8253c:	394043e0 	ldrb	w0, [sp, #16]
   82540:	7101c41f 	cmp	w0, #0x71
   82544:	54000081 	b.ne	82554 <do_cmd_testAsyncUart+0x78>  // b.any
   82548:	394047e0 	ldrb	w0, [sp, #17]
   8254c:	7100281f 	cmp	w0, #0xa
   82550:	54000260 	b.eq	8259c <do_cmd_testAsyncUart+0xc0>  // b.none
            break;
        for (int i = 0; i < idx; i++) {
   82554:	b9009bff 	str	wzr, [sp, #152]
   82558:	14000008 	b	82578 <do_cmd_testAsyncUart+0x9c>
            uart_async_putc(buffer[i]);
   8255c:	b9809be0 	ldrsw	x0, [sp, #152]
   82560:	910043e1 	add	x1, sp, #0x10
   82564:	38606820 	ldrb	w0, [x1, x0]
   82568:	94000af3 	bl	85134 <uart_async_putc>
        for (int i = 0; i < idx; i++) {
   8256c:	b9409be0 	ldr	w0, [sp, #152]
   82570:	11000400 	add	w0, w0, #0x1
   82574:	b9009be0 	str	w0, [sp, #152]
   82578:	b9409be1 	ldr	w1, [sp, #152]
   8257c:	b9409fe0 	ldr	w0, [sp, #156]
   82580:	6b00003f 	cmp	w1, w0
   82584:	54fffecb 	b.lt	8255c <do_cmd_testAsyncUart+0x80>  // b.tstop
        }
        uart_async_putc('\r');
   82588:	528001a0 	mov	w0, #0xd                   	// #13
   8258c:	94000aea 	bl	85134 <uart_async_putc>
        uart_async_putc('\n');
   82590:	52800140 	mov	w0, #0xa                   	// #10
   82594:	94000ae8 	bl	85134 <uart_async_putc>
    while (1) {
   82598:	17ffffd3 	b	824e4 <do_cmd_testAsyncUart+0x8>
    }
}
   8259c:	d503201f 	nop
   825a0:	a8ca7bfd 	ldp	x29, x30, [sp], #160
   825a4:	d65f03c0 	ret

00000000000825a8 <cli_print_banner>:

void cli_print_banner() {
   825a8:	a9bf7bfd 	stp	x29, x30, [sp, #-16]!
   825ac:	910003fd 	mov	x29, sp
    uart_sendline("=======================================\r\n");
   825b0:	90000020 	adrp	x0, 86000 <el1t_irq_invalid+0x78>
   825b4:	91180000 	add	x0, x0, #0x600
   825b8:	94000a4c 	bl	84ee8 <uart_sendline>
    uart_sendline("  Welcome to NYCU-OSC 2024 Lab5 Shell  \r\n");
   825bc:	90000020 	adrp	x0, 86000 <el1t_irq_invalid+0x78>
   825c0:	9118c000 	add	x0, x0, #0x630
   825c4:	94000a49 	bl	84ee8 <uart_sendline>
    uart_sendline("=======================================\r\n");
   825c8:	90000020 	adrp	x0, 86000 <el1t_irq_invalid+0x78>
   825cc:	91180000 	add	x0, x0, #0x600
   825d0:	94000a46 	bl	84ee8 <uart_sendline>
}
   825d4:	d503201f 	nop
   825d8:	a8c17bfd 	ldp	x29, x30, [sp], #16
   825dc:	d65f03c0 	ret

00000000000825e0 <do_cmd_cat>:

void do_cmd_cat(char *filepath) {
   825e0:	a9bb7bfd 	stp	x29, x30, [sp, #-80]!
   825e4:	910003fd 	mov	x29, sp
   825e8:	f9000fe0 	str	x0, [sp, #24]
    char *c_filepath;
    char *c_filedata;
    unsigned int c_filesize;
    struct cpio_newc_header *header_ptr = CPIO_DEFAULT_START;
   825ec:	d0000020 	adrp	x0, 88000 <cmd_list+0x980>
   825f0:	911fa000 	add	x0, x0, #0x7e8
   825f4:	f9400000 	ldr	x0, [x0]
   825f8:	f90017e0 	str	x0, [sp, #40]

    // traverse the whole ramdisk, check filename one by one
    while (header_ptr != 0) {
   825fc:	14000021 	b	82680 <do_cmd_cat+0xa0>
        // func return -1 when error
        int error = cpio_newc_parse_header(header_ptr, &c_filepath, &c_filesize, &c_filedata, &header_ptr);
   82600:	f94017e0 	ldr	x0, [sp, #40]
   82604:	9100a3e4 	add	x4, sp, #0x28
   82608:	9100e3e3 	add	x3, sp, #0x38
   8260c:	9100d3e2 	add	x2, sp, #0x34
   82610:	910103e1 	add	x1, sp, #0x40
   82614:	97fff6ec 	bl	801c4 <cpio_newc_parse_header>
   82618:	b9004fe0 	str	w0, [sp, #76]
        if (error) {
   8261c:	b9404fe0 	ldr	w0, [sp, #76]
   82620:	7100001f 	cmp	w0, #0x0
   82624:	540000a0 	b.eq	82638 <do_cmd_cat+0x58>  // b.none
            uart_sendline("cpio parse error");
   82628:	90000020 	adrp	x0, 86000 <el1t_irq_invalid+0x78>
   8262c:	91134000 	add	x0, x0, #0x4d0
   82630:	94000a2e 	bl	84ee8 <uart_sendline>
            break;
   82634:	14000016 	b	8268c <do_cmd_cat+0xac>
        }

        if (strcmp(c_filepath, filepath) == 0) {
   82638:	f94023e0 	ldr	x0, [sp, #64]
   8263c:	f9400fe1 	ldr	x1, [sp, #24]
   82640:	9400086b 	bl	847ec <strcmp>
   82644:	7100001f 	cmp	w0, #0x0
   82648:	540000e1 	b.ne	82664 <do_cmd_cat+0x84>  // b.any
            uart_sendline("%s", c_filedata);
   8264c:	f9401fe0 	ldr	x0, [sp, #56]
   82650:	aa0003e1 	mov	x1, x0
   82654:	90000020 	adrp	x0, 86000 <el1t_irq_invalid+0x78>
   82658:	91198000 	add	x0, x0, #0x660
   8265c:	94000a23 	bl	84ee8 <uart_sendline>
            break;
   82660:	1400000b 	b	8268c <do_cmd_cat+0xac>
        }

        // if is TRAILER!!!
        if (header_ptr == 0) {
   82664:	f94017e0 	ldr	x0, [sp, #40]
   82668:	f100001f 	cmp	x0, #0x0
   8266c:	540000a1 	b.ne	82680 <do_cmd_cat+0xa0>  // b.any
            uart_sendline("cat: %s: No such file or directory", filepath);
   82670:	f9400fe1 	ldr	x1, [sp, #24]
   82674:	90000020 	adrp	x0, 86000 <el1t_irq_invalid+0x78>
   82678:	9119a000 	add	x0, x0, #0x668
   8267c:	94000a1b 	bl	84ee8 <uart_sendline>
    while (header_ptr != 0) {
   82680:	f94017e0 	ldr	x0, [sp, #40]
   82684:	f100001f 	cmp	x0, #0x0
   82688:	54fffbc1 	b.ne	82600 <do_cmd_cat+0x20>  // b.any
        }
    }
    uart_sendline("\n");
   8268c:	90000020 	adrp	x0, 86000 <el1t_irq_invalid+0x78>
   82690:	911a4000 	add	x0, x0, #0x690
   82694:	94000a15 	bl	84ee8 <uart_sendline>
}
   82698:	d503201f 	nop
   8269c:	a8c57bfd 	ldp	x29, x30, [sp], #80
   826a0:	d65f03c0 	ret

00000000000826a4 <do_cmd_dtb>:

void do_cmd_dtb() {
   826a4:	a9bf7bfd 	stp	x29, x30, [sp, #-16]!
   826a8:	910003fd 	mov	x29, sp
    traverse_device_tree(dtb_ptr, dtb_callback_show_tree);
   826ac:	d0000020 	adrp	x0, 88000 <cmd_list+0x980>
   826b0:	f942ec00 	ldr	x0, [x0, #1496]
   826b4:	f9400002 	ldr	x2, [x0]
   826b8:	d0000020 	adrp	x0, 88000 <cmd_list+0x980>
   826bc:	f9430001 	ldr	x1, [x0, #1536]
   826c0:	aa0203e0 	mov	x0, x2
   826c4:	97fff767 	bl	80460 <traverse_device_tree>
}
   826c8:	d503201f 	nop
   826cc:	a8c17bfd 	ldp	x29, x30, [sp], #16
   826d0:	d65f03c0 	ret

00000000000826d4 <do_cmd_help>:

void do_cmd_help() {
   826d4:	a9be7bfd 	stp	x29, x30, [sp, #-32]!
   826d8:	910003fd 	mov	x29, sp
    for (int i = 0; i < CLI_MAX_CMD; i++) {
   826dc:	b9001fff 	str	wzr, [sp, #28]
   826e0:	14000017 	b	8273c <do_cmd_help+0x68>
        uart_sendline(cmd_list[i].command);
   826e4:	b9801fe0 	ldrsw	x0, [sp, #28]
   826e8:	d378dc01 	lsl	x1, x0, #8
   826ec:	b0000020 	adrp	x0, 87000 <hang+0xd64>
   826f0:	911a0000 	add	x0, x0, #0x680
   826f4:	8b000020 	add	x0, x1, x0
   826f8:	940009fc 	bl	84ee8 <uart_sendline>
        uart_sendline("\t\t: ");
   826fc:	90000020 	adrp	x0, 86000 <el1t_irq_invalid+0x78>
   82700:	911a6000 	add	x0, x0, #0x698
   82704:	940009f9 	bl	84ee8 <uart_sendline>
        uart_sendline(cmd_list[i].help);
   82708:	b9801fe0 	ldrsw	x0, [sp, #28]
   8270c:	d378dc00 	lsl	x0, x0, #8
   82710:	91020001 	add	x1, x0, #0x80
   82714:	b0000020 	adrp	x0, 87000 <hang+0xd64>
   82718:	911a0000 	add	x0, x0, #0x680
   8271c:	8b000020 	add	x0, x1, x0
   82720:	940009f2 	bl	84ee8 <uart_sendline>
        uart_sendline("\r\n");
   82724:	90000020 	adrp	x0, 86000 <el1t_irq_invalid+0x78>
   82728:	911a8000 	add	x0, x0, #0x6a0
   8272c:	940009ef 	bl	84ee8 <uart_sendline>
    for (int i = 0; i < CLI_MAX_CMD; i++) {
   82730:	b9401fe0 	ldr	w0, [sp, #28]
   82734:	11000400 	add	w0, w0, #0x1
   82738:	b9001fe0 	str	w0, [sp, #28]
   8273c:	b9401fe0 	ldr	w0, [sp, #28]
   82740:	7100381f 	cmp	w0, #0xe
   82744:	54fffd0d 	b.le	826e4 <do_cmd_help+0x10>
    }
}
   82748:	d503201f 	nop
   8274c:	d503201f 	nop
   82750:	a8c27bfd 	ldp	x29, x30, [sp], #32
   82754:	d65f03c0 	ret

0000000000082758 <do_cmd_hello>:

void do_cmd_hello() { // hello
   82758:	a9bf7bfd 	stp	x29, x30, [sp, #-16]!
   8275c:	910003fd 	mov	x29, sp
    uart_sendline("Hello World!\r\n");
   82760:	90000020 	adrp	x0, 86000 <el1t_irq_invalid+0x78>
   82764:	911aa000 	add	x0, x0, #0x6a8
   82768:	940009e0 	bl	84ee8 <uart_sendline>
}
   8276c:	d503201f 	nop
   82770:	a8c17bfd 	ldp	x29, x30, [sp], #16
   82774:	d65f03c0 	ret

0000000000082778 <do_cmd_info>:

void do_cmd_info() {
   82778:	a9bf7bfd 	stp	x29, x30, [sp, #-16]!
   8277c:	910003fd 	mov	x29, sp
    // print hw revision
    pt[0] = 8 * 4;
   82780:	d0000020 	adrp	x0, 88000 <cmd_list+0x980>
   82784:	f942cc00 	ldr	x0, [x0, #1432]
   82788:	52800401 	mov	w1, #0x20                  	// #32
   8278c:	b9000001 	str	w1, [x0]
    pt[1] = MBOX_REQUEST_PROCESS;
   82790:	d0000020 	adrp	x0, 88000 <cmd_list+0x980>
   82794:	f942cc00 	ldr	x0, [x0, #1432]
   82798:	b900041f 	str	wzr, [x0, #4]
    pt[2] = MBOX_TAG_GET_BOARD_REVISION;
   8279c:	d0000020 	adrp	x0, 88000 <cmd_list+0x980>
   827a0:	f942cc00 	ldr	x0, [x0, #1432]
   827a4:	52800041 	mov	w1, #0x2                   	// #2
   827a8:	72a00021 	movk	w1, #0x1, lsl #16
   827ac:	b9000801 	str	w1, [x0, #8]
    pt[3] = 4;
   827b0:	d0000020 	adrp	x0, 88000 <cmd_list+0x980>
   827b4:	f942cc00 	ldr	x0, [x0, #1432]
   827b8:	52800081 	mov	w1, #0x4                   	// #4
   827bc:	b9000c01 	str	w1, [x0, #12]
    pt[4] = MBOX_TAG_REQUEST_CODE;
   827c0:	d0000020 	adrp	x0, 88000 <cmd_list+0x980>
   827c4:	f942cc00 	ldr	x0, [x0, #1432]
   827c8:	b900101f 	str	wzr, [x0, #16]
    pt[5] = 0;
   827cc:	d0000020 	adrp	x0, 88000 <cmd_list+0x980>
   827d0:	f942cc00 	ldr	x0, [x0, #1432]
   827d4:	b900141f 	str	wzr, [x0, #20]
    pt[6] = 0;
   827d8:	d0000020 	adrp	x0, 88000 <cmd_list+0x980>
   827dc:	f942cc00 	ldr	x0, [x0, #1432]
   827e0:	b900181f 	str	wzr, [x0, #24]
    pt[7] = MBOX_TAG_LAST_BYTE;
   827e4:	d0000020 	adrp	x0, 88000 <cmd_list+0x980>
   827e8:	f942cc00 	ldr	x0, [x0, #1432]
   827ec:	b9001c1f 	str	wzr, [x0, #28]

    if (k_mbox_call(MBOX_TAGS_ARM_TO_VC, (unsigned int)((unsigned long)&pt))) {
   827f0:	d0000020 	adrp	x0, 88000 <cmd_list+0x980>
   827f4:	f942cc00 	ldr	x0, [x0, #1432]
   827f8:	2a0003e1 	mov	w1, w0
   827fc:	52800100 	mov	w0, #0x8                   	// #8
   82800:	97fffa01 	bl	81004 <k_mbox_call>
   82804:	7100001f 	cmp	w0, #0x0
   82808:	540001e0 	b.eq	82844 <do_cmd_info+0xcc>  // b.none
        uart_sendline("Hardware Revision\t: ");
   8280c:	90000020 	adrp	x0, 86000 <el1t_irq_invalid+0x78>
   82810:	911ae000 	add	x0, x0, #0x6b8
   82814:	940009b5 	bl	84ee8 <uart_sendline>
        uart_2hex(pt[6]);
   82818:	d0000020 	adrp	x0, 88000 <cmd_list+0x980>
   8281c:	f942cc00 	ldr	x0, [x0, #1432]
   82820:	b9401800 	ldr	w0, [x0, #24]
   82824:	94000990 	bl	84e64 <uart_2hex>
        uart_2hex(pt[5]);
   82828:	d0000020 	adrp	x0, 88000 <cmd_list+0x980>
   8282c:	f942cc00 	ldr	x0, [x0, #1432]
   82830:	b9401400 	ldr	w0, [x0, #20]
   82834:	9400098c 	bl	84e64 <uart_2hex>
        uart_sendline("\r\n");
   82838:	90000020 	adrp	x0, 86000 <el1t_irq_invalid+0x78>
   8283c:	911a8000 	add	x0, x0, #0x6a0
   82840:	940009aa 	bl	84ee8 <uart_sendline>
    }
    // print arm memory
    pt[0] = 8 * 4;
   82844:	d0000020 	adrp	x0, 88000 <cmd_list+0x980>
   82848:	f942cc00 	ldr	x0, [x0, #1432]
   8284c:	52800401 	mov	w1, #0x20                  	// #32
   82850:	b9000001 	str	w1, [x0]
    pt[1] = MBOX_REQUEST_PROCESS;
   82854:	d0000020 	adrp	x0, 88000 <cmd_list+0x980>
   82858:	f942cc00 	ldr	x0, [x0, #1432]
   8285c:	b900041f 	str	wzr, [x0, #4]
    pt[2] = MBOX_TAG_GET_ARM_MEMORY;
   82860:	d0000020 	adrp	x0, 88000 <cmd_list+0x980>
   82864:	f942cc00 	ldr	x0, [x0, #1432]
   82868:	528000a1 	mov	w1, #0x5                   	// #5
   8286c:	72a00021 	movk	w1, #0x1, lsl #16
   82870:	b9000801 	str	w1, [x0, #8]
    pt[3] = 8;
   82874:	d0000020 	adrp	x0, 88000 <cmd_list+0x980>
   82878:	f942cc00 	ldr	x0, [x0, #1432]
   8287c:	52800101 	mov	w1, #0x8                   	// #8
   82880:	b9000c01 	str	w1, [x0, #12]
    pt[4] = MBOX_TAG_REQUEST_CODE;
   82884:	d0000020 	adrp	x0, 88000 <cmd_list+0x980>
   82888:	f942cc00 	ldr	x0, [x0, #1432]
   8288c:	b900101f 	str	wzr, [x0, #16]
    pt[5] = 0;
   82890:	d0000020 	adrp	x0, 88000 <cmd_list+0x980>
   82894:	f942cc00 	ldr	x0, [x0, #1432]
   82898:	b900141f 	str	wzr, [x0, #20]
    pt[6] = 0;
   8289c:	d0000020 	adrp	x0, 88000 <cmd_list+0x980>
   828a0:	f942cc00 	ldr	x0, [x0, #1432]
   828a4:	b900181f 	str	wzr, [x0, #24]
    pt[7] = MBOX_TAG_LAST_BYTE;
   828a8:	d0000020 	adrp	x0, 88000 <cmd_list+0x980>
   828ac:	f942cc00 	ldr	x0, [x0, #1432]
   828b0:	b9001c1f 	str	wzr, [x0, #28]

    if (k_mbox_call(MBOX_TAGS_ARM_TO_VC, (unsigned int)((unsigned long)&pt))) {
   828b4:	d0000020 	adrp	x0, 88000 <cmd_list+0x980>
   828b8:	f942cc00 	ldr	x0, [x0, #1432]
   828bc:	2a0003e1 	mov	w1, w0
   828c0:	52800100 	mov	w0, #0x8                   	// #8
   828c4:	97fff9d0 	bl	81004 <k_mbox_call>
   828c8:	7100001f 	cmp	w0, #0x0
   828cc:	540002a0 	b.eq	82920 <do_cmd_info+0x1a8>  // b.none
        uart_sendline("ARM Memory Base Address\t: ");
   828d0:	90000020 	adrp	x0, 86000 <el1t_irq_invalid+0x78>
   828d4:	911b4000 	add	x0, x0, #0x6d0
   828d8:	94000984 	bl	84ee8 <uart_sendline>
        uart_2hex(pt[5]);
   828dc:	d0000020 	adrp	x0, 88000 <cmd_list+0x980>
   828e0:	f942cc00 	ldr	x0, [x0, #1432]
   828e4:	b9401400 	ldr	w0, [x0, #20]
   828e8:	9400095f 	bl	84e64 <uart_2hex>
        uart_sendline("\r\n");
   828ec:	90000020 	adrp	x0, 86000 <el1t_irq_invalid+0x78>
   828f0:	911a8000 	add	x0, x0, #0x6a0
   828f4:	9400097d 	bl	84ee8 <uart_sendline>
        uart_sendline("ARM Memory Size\t\t: ");
   828f8:	90000020 	adrp	x0, 86000 <el1t_irq_invalid+0x78>
   828fc:	911bc000 	add	x0, x0, #0x6f0
   82900:	9400097a 	bl	84ee8 <uart_sendline>
        uart_2hex(pt[6]);
   82904:	d0000020 	adrp	x0, 88000 <cmd_list+0x980>
   82908:	f942cc00 	ldr	x0, [x0, #1432]
   8290c:	b9401800 	ldr	w0, [x0, #24]
   82910:	94000955 	bl	84e64 <uart_2hex>
        uart_sendline("\r\n");
   82914:	90000020 	adrp	x0, 86000 <el1t_irq_invalid+0x78>
   82918:	911a8000 	add	x0, x0, #0x6a0
   8291c:	94000973 	bl	84ee8 <uart_sendline>
    }
}
   82920:	d503201f 	nop
   82924:	a8c17bfd 	ldp	x29, x30, [sp], #16
   82928:	d65f03c0 	ret

000000000008292c <do_cmd_simple_malloc>:

void do_cmd_simple_malloc() {
   8292c:	a9bd7bfd 	stp	x29, x30, [sp, #-48]!
   82930:	910003fd 	mov	x29, sp
    char *test1 = simple_malloc(0x18);
   82934:	52800300 	mov	w0, #0x18                  	// #24
   82938:	97fff9dd 	bl	810ac <simple_malloc>
   8293c:	f90017e0 	str	x0, [sp, #40]
    memcpy(test1, "test malloc1", sizeof("test amlloc1"));
   82940:	d28001a2 	mov	x2, #0xd                   	// #13
   82944:	90000020 	adrp	x0, 86000 <el1t_irq_invalid+0x78>
   82948:	911c2001 	add	x1, x0, #0x708
   8294c:	f94017e0 	ldr	x0, [sp, #40]
   82950:	94000852 	bl	84a98 <memcpy>
    uart_sendline("%s\n", test1);
   82954:	f94017e1 	ldr	x1, [sp, #40]
   82958:	90000020 	adrp	x0, 86000 <el1t_irq_invalid+0x78>
   8295c:	911c6000 	add	x0, x0, #0x718
   82960:	94000962 	bl	84ee8 <uart_sendline>

    char *test2 = simple_malloc(0x20);
   82964:	52800400 	mov	w0, #0x20                  	// #32
   82968:	97fff9d1 	bl	810ac <simple_malloc>
   8296c:	f90013e0 	str	x0, [sp, #32]
    memcpy(test2, "test malloc2", sizeof("test amlloc2"));
   82970:	d28001a2 	mov	x2, #0xd                   	// #13
   82974:	90000020 	adrp	x0, 86000 <el1t_irq_invalid+0x78>
   82978:	911c8001 	add	x1, x0, #0x720
   8297c:	f94013e0 	ldr	x0, [sp, #32]
   82980:	94000846 	bl	84a98 <memcpy>
    uart_sendline("%s\n", test2);
   82984:	f94013e1 	ldr	x1, [sp, #32]
   82988:	90000020 	adrp	x0, 86000 <el1t_irq_invalid+0x78>
   8298c:	911c6000 	add	x0, x0, #0x718
   82990:	94000956 	bl	84ee8 <uart_sendline>

    char *test3 = simple_malloc(0x28);
   82994:	52800500 	mov	w0, #0x28                  	// #40
   82998:	97fff9c5 	bl	810ac <simple_malloc>
   8299c:	f9000fe0 	str	x0, [sp, #24]
    memcpy(test3, "test malloc3", sizeof("test amlloc3"));
   829a0:	d28001a2 	mov	x2, #0xd                   	// #13
   829a4:	90000020 	adrp	x0, 86000 <el1t_irq_invalid+0x78>
   829a8:	911cc001 	add	x1, x0, #0x730
   829ac:	f9400fe0 	ldr	x0, [sp, #24]
   829b0:	9400083a 	bl	84a98 <memcpy>
    uart_sendline("%s\n", test3);
   829b4:	f9400fe1 	ldr	x1, [sp, #24]
   829b8:	90000020 	adrp	x0, 86000 <el1t_irq_invalid+0x78>
   829bc:	911c6000 	add	x0, x0, #0x718
   829c0:	9400094a 	bl	84ee8 <uart_sendline>
}
   829c4:	d503201f 	nop
   829c8:	a8c37bfd 	ldp	x29, x30, [sp], #48
   829cc:	d65f03c0 	ret

00000000000829d0 <do_cmd_ls>:

void do_cmd_ls(char *dir) {
   829d0:	a9bb7bfd 	stp	x29, x30, [sp, #-80]!
   829d4:	910003fd 	mov	x29, sp
   829d8:	f9000fe0 	str	x0, [sp, #24]
    char *c_filepath;
    char *c_filedata;
    unsigned int c_filesize;
    struct cpio_newc_header *header_ptr = CPIO_DEFAULT_START;
   829dc:	d0000020 	adrp	x0, 88000 <cmd_list+0x980>
   829e0:	911fa000 	add	x0, x0, #0x7e8
   829e4:	f9400000 	ldr	x0, [x0]
   829e8:	f90017e0 	str	x0, [sp, #40]

    while (header_ptr != 0) {
   829ec:	14000017 	b	82a48 <do_cmd_ls+0x78>
        int error = cpio_newc_parse_header(header_ptr, &c_filepath, &c_filesize, &c_filedata, &header_ptr);
   829f0:	f94017e0 	ldr	x0, [sp, #40]
   829f4:	9100a3e4 	add	x4, sp, #0x28
   829f8:	9100e3e3 	add	x3, sp, #0x38
   829fc:	9100d3e2 	add	x2, sp, #0x34
   82a00:	910103e1 	add	x1, sp, #0x40
   82a04:	97fff5f0 	bl	801c4 <cpio_newc_parse_header>
   82a08:	b9004fe0 	str	w0, [sp, #76]
        if (error) {
   82a0c:	b9404fe0 	ldr	w0, [sp, #76]
   82a10:	7100001f 	cmp	w0, #0x0
   82a14:	540000a0 	b.eq	82a28 <do_cmd_ls+0x58>  // b.none
            uart_sendline("cpio parse error");
   82a18:	90000020 	adrp	x0, 86000 <el1t_irq_invalid+0x78>
   82a1c:	91134000 	add	x0, x0, #0x4d0
   82a20:	94000932 	bl	84ee8 <uart_sendline>
            break;
   82a24:	1400000d 	b	82a58 <do_cmd_ls+0x88>
        }

        if (header_ptr != 0) {
   82a28:	f94017e0 	ldr	x0, [sp, #40]
   82a2c:	f100001f 	cmp	x0, #0x0
   82a30:	540000c0 	b.eq	82a48 <do_cmd_ls+0x78>  // b.none
            uart_sendline("%s\n", c_filepath);
   82a34:	f94023e0 	ldr	x0, [sp, #64]
   82a38:	aa0003e1 	mov	x1, x0
   82a3c:	90000020 	adrp	x0, 86000 <el1t_irq_invalid+0x78>
   82a40:	911c6000 	add	x0, x0, #0x718
   82a44:	94000929 	bl	84ee8 <uart_sendline>
    while (header_ptr != 0) {
   82a48:	f94017e0 	ldr	x0, [sp, #40]
   82a4c:	f100001f 	cmp	x0, #0x0
   82a50:	54fffd01 	b.ne	829f0 <do_cmd_ls+0x20>  // b.any
        }
    }
}
   82a54:	d503201f 	nop
   82a58:	d503201f 	nop
   82a5c:	a8c57bfd 	ldp	x29, x30, [sp], #80
   82a60:	d65f03c0 	ret

0000000000082a64 <do_cmd_reboot>:

void do_cmd_reboot() {
   82a64:	a9be7bfd 	stp	x29, x30, [sp, #-32]!
   82a68:	910003fd 	mov	x29, sp
    uart_sendline("Reboot in 5 seconds ...\r\n\r\n");
   82a6c:	90000020 	adrp	x0, 86000 <el1t_irq_invalid+0x78>
   82a70:	911d0000 	add	x0, x0, #0x740
   82a74:	9400091d 	bl	84ee8 <uart_sendline>
    volatile unsigned int *rst_addr = (unsigned int *)PM_RSTC;
   82a78:	d2800380 	mov	x0, #0x1c                  	// #28
   82a7c:	f2a7e200 	movk	x0, #0x3f10, lsl #16
   82a80:	f9000fe0 	str	x0, [sp, #24]
    *rst_addr = PM_PASSWORD | 0x20;
   82a84:	f9400fe0 	ldr	x0, [sp, #24]
   82a88:	52800401 	mov	w1, #0x20                  	// #32
   82a8c:	72ab4001 	movk	w1, #0x5a00, lsl #16
   82a90:	b9000001 	str	w1, [x0]
    volatile unsigned int *wdg_addr = (unsigned int *)PM_WDOG;
   82a94:	d2800480 	mov	x0, #0x24                  	// #36
   82a98:	f2a7e200 	movk	x0, #0x3f10, lsl #16
   82a9c:	f9000be0 	str	x0, [sp, #16]
    *wdg_addr = PM_PASSWORD | 5;
   82aa0:	f9400be0 	ldr	x0, [sp, #16]
   82aa4:	528000a1 	mov	w1, #0x5                   	// #5
   82aa8:	72ab4001 	movk	w1, #0x5a00, lsl #16
   82aac:	b9000001 	str	w1, [x0]
}
   82ab0:	d503201f 	nop
   82ab4:	a8c27bfd 	ldp	x29, x30, [sp], #32
   82ab8:	d65f03c0 	ret

0000000000082abc <do_cmd_set2sTimer>:

void do_cmd_set2sTimer(char *msg) {
   82abc:	a9bd7bfd 	stp	x29, x30, [sp, #-48]!
   82ac0:	910003fd 	mov	x29, sp
   82ac4:	f9000fe0 	str	x0, [sp, #24]
    // get '1 sec' length
    long long int cntpct_el0, cntfrq_el0;
    asm volatile("mrs %0, cntpct_el0\n\t" : "=r"(cntpct_el0));
   82ac8:	d53be020 	mrs	x0, cntpct_el0
   82acc:	f90017e0 	str	x0, [sp, #40]
    asm volatile("mrs %0, cntfrq_el0\n\t" : "=r"(cntfrq_el0));
   82ad0:	d53be000 	mrs	x0, cntfrq_el0
   82ad4:	f90013e0 	str	x0, [sp, #32]
    uart_sendline("[Interrupt][el1_irq][%s] %d seconds after booting\n", msg, cntpct_el0 / cntfrq_el0);
   82ad8:	f94017e1 	ldr	x1, [sp, #40]
   82adc:	f94013e0 	ldr	x0, [sp, #32]
   82ae0:	9ac00c20 	sdiv	x0, x1, x0
   82ae4:	aa0003e2 	mov	x2, x0
   82ae8:	f9400fe1 	ldr	x1, [sp, #24]
   82aec:	90000020 	adrp	x0, 86000 <el1t_irq_invalid+0x78>
   82af0:	911d8000 	add	x0, x0, #0x760
   82af4:	940008fd 	bl	84ee8 <uart_sendline>

    add_timer(do_cmd_set2sTimer, msg, 2 * getTimerFreq());
   82af8:	9400058a 	bl	84120 <getTimerFreq>
   82afc:	d37ff800 	lsl	x0, x0, #1
   82b00:	aa0003e2 	mov	x2, x0
   82b04:	f9400fe1 	ldr	x1, [sp, #24]
   82b08:	90000000 	adrp	x0, 82000 <do_cmd_exec+0x38>
   82b0c:	912af000 	add	x0, x0, #0xabc
   82b10:	94000515 	bl	83f64 <add_timer>
}
   82b14:	d503201f 	nop
   82b18:	a8c37bfd 	ldp	x29, x30, [sp], #48
   82b1c:	d65f03c0 	ret

0000000000082b20 <do_cmd_setTimer>:

void do_cmd_setTimer(char *msg, int sec) {
   82b20:	a9bd7bfd 	stp	x29, x30, [sp, #-48]!
   82b24:	910003fd 	mov	x29, sp
   82b28:	f9000bf3 	str	x19, [sp, #16]
   82b2c:	f90017e0 	str	x0, [sp, #40]
   82b30:	b90027e1 	str	w1, [sp, #36]
    add_timer(timer_print_msg, msg, sec * getTimerFreq());
   82b34:	b98027f3 	ldrsw	x19, [sp, #36]
   82b38:	9400057a 	bl	84120 <getTimerFreq>
   82b3c:	9b007e60 	mul	x0, x19, x0
   82b40:	aa0003e2 	mov	x2, x0
   82b44:	f94017e1 	ldr	x1, [sp, #40]
   82b48:	d0000020 	adrp	x0, 88000 <cmd_list+0x980>
   82b4c:	f942d000 	ldr	x0, [x0, #1440]
   82b50:	94000505 	bl	83f64 <add_timer>
}
   82b54:	d503201f 	nop
   82b58:	f9400bf3 	ldr	x19, [sp, #16]
   82b5c:	a8c37bfd 	ldp	x29, x30, [sp], #48
   82b60:	d65f03c0 	ret

0000000000082b64 <do_cmd_mem_test>:

void do_cmd_mem_test() {
   82b64:	a9b57bfd 	stp	x29, x30, [sp, #-176]!
   82b68:	910003fd 	mov	x29, sp
    char *p1 = kmalloc(0x82000);
   82b6c:	52840000 	mov	w0, #0x2000                	// #8192
   82b70:	72a00100 	movk	w0, #0x8, lsl #16
   82b74:	97fffc53 	bl	81cc0 <kmalloc>
   82b78:	f90057e0 	str	x0, [sp, #168]
    char *p2 = kmalloc(0x90000);
   82b7c:	52a00120 	mov	w0, #0x90000               	// #589824
   82b80:	97fffc50 	bl	81cc0 <kmalloc>
   82b84:	f90053e0 	str	x0, [sp, #160]
    char *p3 = kmalloc(0x200000);
   82b88:	52a00400 	mov	w0, #0x200000              	// #2097152
   82b8c:	97fffc4d 	bl	81cc0 <kmalloc>
   82b90:	f9004fe0 	str	x0, [sp, #152]
    char *p4 = kmalloc(0x390000);
   82b94:	52a00720 	mov	w0, #0x390000              	// #3735552
   82b98:	97fffc4a 	bl	81cc0 <kmalloc>
   82b9c:	f9004be0 	str	x0, [sp, #144]
    kfree(p3);
   82ba0:	f9404fe0 	ldr	x0, [sp, #152]
   82ba4:	97fffc57 	bl	81d00 <kfree>
    kfree(p4);
   82ba8:	f9404be0 	ldr	x0, [sp, #144]
   82bac:	97fffc55 	bl	81d00 <kfree>
    kfree(p1);
   82bb0:	f94057e0 	ldr	x0, [sp, #168]
   82bb4:	97fffc53 	bl	81d00 <kfree>
    kfree(p2);
   82bb8:	f94053e0 	ldr	x0, [sp, #160]
   82bbc:	97fffc51 	bl	81d00 <kfree>
    char *a = kmalloc(0x1000);
   82bc0:	52820000 	mov	w0, #0x1000                	// #4096
   82bc4:	97fffc3f 	bl	81cc0 <kmalloc>
   82bc8:	f90047e0 	str	x0, [sp, #136]
    char *b = kmalloc(0x10000);
   82bcc:	52a00020 	mov	w0, #0x10000               	// #65536
   82bd0:	97fffc3c 	bl	81cc0 <kmalloc>
   82bd4:	f90043e0 	str	x0, [sp, #128]
    char *c = kmalloc(0x100000);
   82bd8:	52a00200 	mov	w0, #0x100000              	// #1048576
   82bdc:	97fffc39 	bl	81cc0 <kmalloc>
   82be0:	f9003fe0 	str	x0, [sp, #120]

    kfree(a);
   82be4:	f94047e0 	ldr	x0, [sp, #136]
   82be8:	97fffc46 	bl	81d00 <kfree>
    kfree(b);
   82bec:	f94043e0 	ldr	x0, [sp, #128]
   82bf0:	97fffc44 	bl	81d00 <kfree>
    kfree(c);
   82bf4:	f9403fe0 	ldr	x0, [sp, #120]
   82bf8:	97fffc42 	bl	81d00 <kfree>

    a = kmalloc(32);
   82bfc:	52800400 	mov	w0, #0x20                  	// #32
   82c00:	97fffc30 	bl	81cc0 <kmalloc>
   82c04:	f90047e0 	str	x0, [sp, #136]
    char *aa = kmalloc(50);
   82c08:	52800640 	mov	w0, #0x32                  	// #50
   82c0c:	97fffc2d 	bl	81cc0 <kmalloc>
   82c10:	f9003be0 	str	x0, [sp, #112]
    b = kmalloc(64);
   82c14:	52800800 	mov	w0, #0x40                  	// #64
   82c18:	97fffc2a 	bl	81cc0 <kmalloc>
   82c1c:	f90043e0 	str	x0, [sp, #128]
    char *bb = kmalloc(64);
   82c20:	52800800 	mov	w0, #0x40                  	// #64
   82c24:	97fffc27 	bl	81cc0 <kmalloc>
   82c28:	f90037e0 	str	x0, [sp, #104]
    c = kmalloc(128);
   82c2c:	52801000 	mov	w0, #0x80                  	// #128
   82c30:	97fffc24 	bl	81cc0 <kmalloc>
   82c34:	f9003fe0 	str	x0, [sp, #120]
    char *cc = kmalloc(129);
   82c38:	52801020 	mov	w0, #0x81                  	// #129
   82c3c:	97fffc21 	bl	81cc0 <kmalloc>
   82c40:	f90033e0 	str	x0, [sp, #96]
    char *d = kmalloc(256);
   82c44:	52802000 	mov	w0, #0x100                 	// #256
   82c48:	97fffc1e 	bl	81cc0 <kmalloc>
   82c4c:	f9002fe0 	str	x0, [sp, #88]
    char *dd = kmalloc(256);
   82c50:	52802000 	mov	w0, #0x100                 	// #256
   82c54:	97fffc1b 	bl	81cc0 <kmalloc>
   82c58:	f9002be0 	str	x0, [sp, #80]
    char *e = kmalloc(512);
   82c5c:	52804000 	mov	w0, #0x200                 	// #512
   82c60:	97fffc18 	bl	81cc0 <kmalloc>
   82c64:	f90027e0 	str	x0, [sp, #72]
    char *ee = kmalloc(999);
   82c68:	52807ce0 	mov	w0, #0x3e7                 	// #999
   82c6c:	97fffc15 	bl	81cc0 <kmalloc>
   82c70:	f90023e0 	str	x0, [sp, #64]

    char *f = kmalloc(0x2000);
   82c74:	52840000 	mov	w0, #0x2000                	// #8192
   82c78:	97fffc12 	bl	81cc0 <kmalloc>
   82c7c:	f9001fe0 	str	x0, [sp, #56]
    char *ff = kmalloc(0x2000);
   82c80:	52840000 	mov	w0, #0x2000                	// #8192
   82c84:	97fffc0f 	bl	81cc0 <kmalloc>
   82c88:	f9001be0 	str	x0, [sp, #48]
    char *g = kmalloc(0x2000);
   82c8c:	52840000 	mov	w0, #0x2000                	// #8192
   82c90:	97fffc0c 	bl	81cc0 <kmalloc>
   82c94:	f90017e0 	str	x0, [sp, #40]
    char *gg = kmalloc(0x2000);
   82c98:	52840000 	mov	w0, #0x2000                	// #8192
   82c9c:	97fffc09 	bl	81cc0 <kmalloc>
   82ca0:	f90013e0 	str	x0, [sp, #32]
    char *h = kmalloc(0x2000);
   82ca4:	52840000 	mov	w0, #0x2000                	// #8192
   82ca8:	97fffc06 	bl	81cc0 <kmalloc>
   82cac:	f9000fe0 	str	x0, [sp, #24]
    char *hh = kmalloc(0x2000);
   82cb0:	52840000 	mov	w0, #0x2000                	// #8192
   82cb4:	97fffc03 	bl	81cc0 <kmalloc>
   82cb8:	f9000be0 	str	x0, [sp, #16]

    kfree(a);
   82cbc:	f94047e0 	ldr	x0, [sp, #136]
   82cc0:	97fffc10 	bl	81d00 <kfree>
    kfree(aa);
   82cc4:	f9403be0 	ldr	x0, [sp, #112]
   82cc8:	97fffc0e 	bl	81d00 <kfree>
    kfree(b);
   82ccc:	f94043e0 	ldr	x0, [sp, #128]
   82cd0:	97fffc0c 	bl	81d00 <kfree>
    kfree(bb);
   82cd4:	f94037e0 	ldr	x0, [sp, #104]
   82cd8:	97fffc0a 	bl	81d00 <kfree>
    kfree(c);
   82cdc:	f9403fe0 	ldr	x0, [sp, #120]
   82ce0:	97fffc08 	bl	81d00 <kfree>
    kfree(cc);
   82ce4:	f94033e0 	ldr	x0, [sp, #96]
   82ce8:	97fffc06 	bl	81d00 <kfree>
    kfree(dd);
   82cec:	f9402be0 	ldr	x0, [sp, #80]
   82cf0:	97fffc04 	bl	81d00 <kfree>
    kfree(d);
   82cf4:	f9402fe0 	ldr	x0, [sp, #88]
   82cf8:	97fffc02 	bl	81d00 <kfree>
    kfree(e);
   82cfc:	f94027e0 	ldr	x0, [sp, #72]
   82d00:	97fffc00 	bl	81d00 <kfree>
    kfree(ee);
   82d04:	f94023e0 	ldr	x0, [sp, #64]
   82d08:	97fffbfe 	bl	81d00 <kfree>

    kfree(f);
   82d0c:	f9401fe0 	ldr	x0, [sp, #56]
   82d10:	97fffbfc 	bl	81d00 <kfree>
    kfree(ff);
   82d14:	f9401be0 	ldr	x0, [sp, #48]
   82d18:	97fffbfa 	bl	81d00 <kfree>
    kfree(g);
   82d1c:	f94017e0 	ldr	x0, [sp, #40]
   82d20:	97fffbf8 	bl	81d00 <kfree>
    kfree(gg);
   82d24:	f94013e0 	ldr	x0, [sp, #32]
   82d28:	97fffbf6 	bl	81d00 <kfree>
    kfree(h);
   82d2c:	f9400fe0 	ldr	x0, [sp, #24]
   82d30:	97fffbf4 	bl	81d00 <kfree>
    kfree(hh);
   82d34:	f9400be0 	ldr	x0, [sp, #16]
   82d38:	97fffbf2 	bl	81d00 <kfree>
}
   82d3c:	d503201f 	nop
   82d40:	a8cb7bfd 	ldp	x29, x30, [sp], #176
   82d44:	d65f03c0 	ret

0000000000082d48 <do_cmd_thread_test>:

void do_cmd_thread_test() {
   82d48:	a9be7bfd 	stp	x29, x30, [sp, #-32]!
   82d4c:	910003fd 	mov	x29, sp
    for (int i = 0; i < 5; i++) {
   82d50:	b9001fff 	str	wzr, [sp, #28]
   82d54:	1400000c 	b	82d84 <do_cmd_thread_test+0x3c>
        uart_sendline("testing: %d\n", thread_create(foo)->pid);
   82d58:	d0000020 	adrp	x0, 88000 <cmd_list+0x980>
   82d5c:	f942f000 	ldr	x0, [x0, #1504]
   82d60:	940002c0 	bl	83860 <thread_create>
   82d64:	b9402000 	ldr	w0, [x0, #32]
   82d68:	2a0003e1 	mov	w1, w0
   82d6c:	90000020 	adrp	x0, 86000 <el1t_irq_invalid+0x78>
   82d70:	911e6000 	add	x0, x0, #0x798
   82d74:	9400085d 	bl	84ee8 <uart_sendline>
    for (int i = 0; i < 5; i++) {
   82d78:	b9401fe0 	ldr	w0, [sp, #28]
   82d7c:	11000400 	add	w0, w0, #0x1
   82d80:	b9001fe0 	str	w0, [sp, #28]
   82d84:	b9401fe0 	ldr	w0, [sp, #28]
   82d88:	7100101f 	cmp	w0, #0x4
   82d8c:	54fffe6d 	b.le	82d58 <do_cmd_thread_test+0x10>
    }
    schedule_timer();
   82d90:	940003c1 	bl	83c94 <schedule_timer>
    // idle();
}
   82d94:	d503201f 	nop
   82d98:	a8c27bfd 	ldp	x29, x30, [sp], #32
   82d9c:	d65f03c0 	ret

0000000000082da0 <do_cmd_syscall_test>:

void do_cmd_syscall_test() {
   82da0:	a9bf7bfd 	stp	x29, x30, [sp, #-16]!
   82da4:	910003fd 	mov	x29, sp
    // TODO: switch to el0
    thread_create(fork_test);
   82da8:	90000000 	adrp	x0, 82000 <do_cmd_exec+0x38>
   82dac:	913bd000 	add	x0, x0, #0xef4
   82db0:	940002ac 	bl	83860 <thread_create>
    schedule();
   82db4:	9400031c 	bl	83a24 <schedule>
}
   82db8:	d503201f 	nop
   82dbc:	a8c17bfd 	ldp	x29, x30, [sp], #16
   82dc0:	d65f03c0 	ret

0000000000082dc4 <test_getpid>:

int test_getpid() {
   82dc4:	d10043ff 	sub	sp, sp, #0x10
    int ret = 0;
   82dc8:	b9000fff 	str	wzr, [sp, #12]
    asm volatile("mov x8, 0");
   82dcc:	d2800008 	mov	x8, #0x0                   	// #0
    asm volatile("svc 0");
   82dd0:	d4000001 	svc	#0x0
    asm volatile("mov %0, x0" : "=r"(ret));
   82dd4:	aa0003e0 	mov	x0, x0
   82dd8:	b9000fe0 	str	w0, [sp, #12]
    return ret;
   82ddc:	b9400fe0 	ldr	w0, [sp, #12]
}
   82de0:	910043ff 	add	sp, sp, #0x10
   82de4:	d65f03c0 	ret

0000000000082de8 <test_uart_read>:

size_t test_uart_read(char *buf, size_t size) {
   82de8:	d10083ff 	sub	sp, sp, #0x20
   82dec:	f90007e0 	str	x0, [sp, #8]
   82df0:	f90003e1 	str	x1, [sp]
    int ret = 0;
   82df4:	b9001fff 	str	wzr, [sp, #28]
    asm volatile("mov x1, %0" ::"r"(size));
   82df8:	f94003e0 	ldr	x0, [sp]
   82dfc:	aa0003e1 	mov	x1, x0
    asm volatile("mov x0, %0" ::"r"(buf));
   82e00:	f94007e0 	ldr	x0, [sp, #8]
   82e04:	aa0003e0 	mov	x0, x0
    asm volatile("mov x8, 1");
   82e08:	d2800028 	mov	x8, #0x1                   	// #1
    asm volatile("svc 0");
   82e0c:	d4000001 	svc	#0x0
    asm volatile("mov %0, x0" : "=r"(ret));
   82e10:	aa0003e0 	mov	x0, x0
   82e14:	b9001fe0 	str	w0, [sp, #28]
    return ret;
   82e18:	b9801fe0 	ldrsw	x0, [sp, #28]
}
   82e1c:	910083ff 	add	sp, sp, #0x20
   82e20:	d65f03c0 	ret

0000000000082e24 <test_uart_write>:

size_t test_uart_write(const char *buf, size_t size) {
   82e24:	d10083ff 	sub	sp, sp, #0x20
   82e28:	f90007e0 	str	x0, [sp, #8]
   82e2c:	f90003e1 	str	x1, [sp]
    int ret = 0;
   82e30:	b9001fff 	str	wzr, [sp, #28]
    asm volatile("mov x1, %0" ::"r"(size));
   82e34:	f94003e0 	ldr	x0, [sp]
   82e38:	aa0003e1 	mov	x1, x0
    asm volatile("mov x0, %0" ::"r"(buf));
   82e3c:	f94007e0 	ldr	x0, [sp, #8]
   82e40:	aa0003e0 	mov	x0, x0
    asm volatile("mov x8, 2");
   82e44:	d2800048 	mov	x8, #0x2                   	// #2
    asm volatile("svc 0");
   82e48:	d4000001 	svc	#0x0
    asm volatile("mov %0, x0" : "=r"(ret));
   82e4c:	aa0003e0 	mov	x0, x0
   82e50:	b9001fe0 	str	w0, [sp, #28]
    return ret;
   82e54:	b9801fe0 	ldrsw	x0, [sp, #28]
}
   82e58:	910083ff 	add	sp, sp, #0x20
   82e5c:	d65f03c0 	ret

0000000000082e60 <test_fork>:

int test_fork() {
   82e60:	d10043ff 	sub	sp, sp, #0x10
    int ret = 0;
   82e64:	b9000fff 	str	wzr, [sp, #12]
    asm volatile("mov x8, 4");
   82e68:	d2800088 	mov	x8, #0x4                   	// #4
    asm volatile("svc 0");
   82e6c:	d4000001 	svc	#0x0
    asm volatile("mov %0, x0" : "=r"(ret));
   82e70:	aa0003e0 	mov	x0, x0
   82e74:	b9000fe0 	str	w0, [sp, #12]
    return ret;
   82e78:	b9400fe0 	ldr	w0, [sp, #12]
}
   82e7c:	910043ff 	add	sp, sp, #0x10
   82e80:	d65f03c0 	ret

0000000000082e84 <test_exit>:

void test_exit() {
    asm volatile("mov x8, 5");
   82e84:	d28000a8 	mov	x8, #0x5                   	// #5
    asm volatile("svc 0");
   82e88:	d4000001 	svc	#0x0
}
   82e8c:	d503201f 	nop
   82e90:	d65f03c0 	ret

0000000000082e94 <test_mbox_call>:

int test_mbox_call(unsigned char ch, unsigned int *mbox) {
   82e94:	d10083ff 	sub	sp, sp, #0x20
   82e98:	39003fe0 	strb	w0, [sp, #15]
   82e9c:	f90003e1 	str	x1, [sp]
    int ret = 0;
   82ea0:	b9001fff 	str	wzr, [sp, #28]
    asm volatile("mov x1, %0" ::"r"(mbox));
   82ea4:	f94003e0 	ldr	x0, [sp]
   82ea8:	aa0003e1 	mov	x1, x0
    asm volatile("mov x0, %0" ::"r"(ch));
   82eac:	39403fe0 	ldrb	w0, [sp, #15]
   82eb0:	aa0003e0 	mov	x0, x0
    asm volatile("mov x8, 6");
   82eb4:	d28000c8 	mov	x8, #0x6                   	// #6
    asm volatile("svc 0");
   82eb8:	d4000001 	svc	#0x0
    asm volatile("mov %0, x0" : "=r"(ret));
   82ebc:	aa0003e0 	mov	x0, x0
   82ec0:	b9001fe0 	str	w0, [sp, #28]
    return ret;
   82ec4:	b9401fe0 	ldr	w0, [sp, #28]
}
   82ec8:	910083ff 	add	sp, sp, #0x20
   82ecc:	d65f03c0 	ret

0000000000082ed0 <test_kill>:

void test_kill(int pid) {
   82ed0:	d10043ff 	sub	sp, sp, #0x10
   82ed4:	b9000fe0 	str	w0, [sp, #12]
    asm volatile("mov x0, %0" ::"r"(pid));
   82ed8:	b9400fe0 	ldr	w0, [sp, #12]
   82edc:	aa0003e0 	mov	x0, x0
    asm volatile("mov x8, 7");
   82ee0:	d28000e8 	mov	x8, #0x7                   	// #7
    asm volatile("svc 0");
   82ee4:	d4000001 	svc	#0x0
}
   82ee8:	d503201f 	nop
   82eec:	910043ff 	add	sp, sp, #0x10
   82ef0:	d65f03c0 	ret

0000000000082ef4 <fork_test>:

// run in user space
void fork_test() {
   82ef4:	a9b57bfd 	stp	x29, x30, [sp, #-176]!
   82ef8:	910003fd 	mov	x29, sp
    // switch to user space
    from_el1_to_el0(cur_thread);
   82efc:	d0000020 	adrp	x0, 88000 <cmd_list+0x980>
   82f00:	f942fc00 	ldr	x0, [x0, #1528]
   82f04:	f9400000 	ldr	x0, [x0]
   82f08:	940002b4 	bl	839d8 <from_el1_to_el0>

    // uart I/O test
    char buf[128];
    uart_sendline("Input : ");
   82f0c:	90000020 	adrp	x0, 86000 <el1t_irq_invalid+0x78>
   82f10:	911ea000 	add	x0, x0, #0x7a8
   82f14:	940007f5 	bl	84ee8 <uart_sendline>
    test_uart_read(buf, 5);
   82f18:	910083e0 	add	x0, sp, #0x20
   82f1c:	d28000a1 	mov	x1, #0x5                   	// #5
   82f20:	97ffffb2 	bl	82de8 <test_uart_read>
    test_uart_write(buf, sizeof(buf));
   82f24:	910083e0 	add	x0, sp, #0x20
   82f28:	d2801001 	mov	x1, #0x80                  	// #128
   82f2c:	97ffffbe 	bl	82e24 <test_uart_write>

    // mailbox test

    // fork test
    uart_sendline("\nFork Test, pid %d\n", test_getpid());
   82f30:	97ffffa5 	bl	82dc4 <test_getpid>
   82f34:	2a0003e1 	mov	w1, w0
   82f38:	90000020 	adrp	x0, 86000 <el1t_irq_invalid+0x78>
   82f3c:	911ee000 	add	x0, x0, #0x7b8
   82f40:	940007ea 	bl	84ee8 <uart_sendline>
    int cnt = 1;
   82f44:	52800020 	mov	w0, #0x1                   	// #1
   82f48:	b9001fe0 	str	w0, [sp, #28]
    int ret = 999;
   82f4c:	52807ce0 	mov	w0, #0x3e7                 	// #999
   82f50:	b900abe0 	str	w0, [sp, #168]
    if ((ret = test_fork()) == 0) { // child
   82f54:	97ffffc3 	bl	82e60 <test_fork>
   82f58:	b900abe0 	str	w0, [sp, #168]
   82f5c:	b940abe0 	ldr	w0, [sp, #168]
   82f60:	7100001f 	cmp	w0, #0x0
   82f64:	54000861 	b.ne	83070 <fork_test+0x17c>  // b.any
        long long cur_sp;
        asm volatile("mov %0, sp" : "=r"(cur_sp));
   82f68:	910003e0 	mov	x0, sp
   82f6c:	f90053e0 	str	x0, [sp, #160]
        uart_sendline("first child pid: %d, cnt: %d, ptr: %x, sp : %x\n", test_getpid(), cnt, &cnt, cur_sp);
   82f70:	97ffff95 	bl	82dc4 <test_getpid>
   82f74:	2a0003e5 	mov	w5, w0
   82f78:	b9401fe0 	ldr	w0, [sp, #28]
   82f7c:	910073e1 	add	x1, sp, #0x1c
   82f80:	f94053e4 	ldr	x4, [sp, #160]
   82f84:	aa0103e3 	mov	x3, x1
   82f88:	2a0003e2 	mov	w2, w0
   82f8c:	2a0503e1 	mov	w1, w5
   82f90:	90000020 	adrp	x0, 86000 <el1t_irq_invalid+0x78>
   82f94:	911f4000 	add	x0, x0, #0x7d0
   82f98:	940007d4 	bl	84ee8 <uart_sendline>
        ++cnt;
   82f9c:	b9401fe0 	ldr	w0, [sp, #28]
   82fa0:	11000400 	add	w0, w0, #0x1
   82fa4:	b9001fe0 	str	w0, [sp, #28]

        if ((ret = test_fork()) != 0) {
   82fa8:	97ffffae 	bl	82e60 <test_fork>
   82fac:	b900abe0 	str	w0, [sp, #168]
   82fb0:	b940abe0 	ldr	w0, [sp, #168]
   82fb4:	7100001f 	cmp	w0, #0x0
   82fb8:	54000540 	b.eq	83060 <fork_test+0x16c>  // b.none
            asm volatile("mov %0, sp" : "=r"(cur_sp));
   82fbc:	910003e0 	mov	x0, sp
   82fc0:	f90053e0 	str	x0, [sp, #160]
            uart_sendline("first child pid: %d, cnt: %d, ptr: %x, sp : %x\n", test_getpid(), cnt, &cnt, cur_sp);
   82fc4:	97ffff80 	bl	82dc4 <test_getpid>
   82fc8:	2a0003e5 	mov	w5, w0
   82fcc:	b9401fe0 	ldr	w0, [sp, #28]
   82fd0:	910073e1 	add	x1, sp, #0x1c
   82fd4:	f94053e4 	ldr	x4, [sp, #160]
   82fd8:	aa0103e3 	mov	x3, x1
   82fdc:	2a0003e2 	mov	w2, w0
   82fe0:	2a0503e1 	mov	w1, w5
   82fe4:	90000020 	adrp	x0, 86000 <el1t_irq_invalid+0x78>
   82fe8:	911f4000 	add	x0, x0, #0x7d0
   82fec:	940007bf 	bl	84ee8 <uart_sendline>
   82ff0:	14000026 	b	83088 <fork_test+0x194>
        } else {
            while (cnt < 5) {
                asm volatile("mov %0, sp" : "=r"(cur_sp));
   82ff4:	910003e0 	mov	x0, sp
   82ff8:	f90053e0 	str	x0, [sp, #160]
                uart_sendline("second child pid: %d, cnt: %d, ptr: %x, sp : %x\n", test_getpid(), cnt, &cnt, cur_sp);
   82ffc:	97ffff72 	bl	82dc4 <test_getpid>
   83000:	2a0003e5 	mov	w5, w0
   83004:	b9401fe0 	ldr	w0, [sp, #28]
   83008:	910073e1 	add	x1, sp, #0x1c
   8300c:	f94053e4 	ldr	x4, [sp, #160]
   83010:	aa0103e3 	mov	x3, x1
   83014:	2a0003e2 	mov	w2, w0
   83018:	2a0503e1 	mov	w1, w5
   8301c:	f0000000 	adrp	x0, 86000 <el1t_irq_invalid+0x78>
   83020:	91200000 	add	x0, x0, #0x800
   83024:	940007b1 	bl	84ee8 <uart_sendline>
                for (int i = 0; i < 1000000; i++)
   83028:	b900afff 	str	wzr, [sp, #172]
   8302c:	14000005 	b	83040 <fork_test+0x14c>
                    asm volatile("nop\n\t");
   83030:	d503201f 	nop
                for (int i = 0; i < 1000000; i++)
   83034:	b940afe0 	ldr	w0, [sp, #172]
   83038:	11000400 	add	w0, w0, #0x1
   8303c:	b900afe0 	str	w0, [sp, #172]
   83040:	b940afe1 	ldr	w1, [sp, #172]
   83044:	528847e0 	mov	w0, #0x423f                	// #16959
   83048:	72a001e0 	movk	w0, #0xf, lsl #16
   8304c:	6b00003f 	cmp	w1, w0
   83050:	54ffff0d 	b.le	83030 <fork_test+0x13c>
                ++cnt;
   83054:	b9401fe0 	ldr	w0, [sp, #28]
   83058:	11000400 	add	w0, w0, #0x1
   8305c:	b9001fe0 	str	w0, [sp, #28]
            while (cnt < 5) {
   83060:	b9401fe0 	ldr	w0, [sp, #28]
   83064:	7100101f 	cmp	w0, #0x4
   83068:	54fffc6d 	b.le	82ff4 <fork_test+0x100>
   8306c:	14000007 	b	83088 <fork_test+0x194>
            }
        }
    } else {
        uart_sendline("parent here, pid %d, child %d\n", test_getpid(), ret);
   83070:	97ffff55 	bl	82dc4 <test_getpid>
   83074:	b940abe2 	ldr	w2, [sp, #168]
   83078:	2a0003e1 	mov	w1, w0
   8307c:	f0000000 	adrp	x0, 86000 <el1t_irq_invalid+0x78>
   83080:	9120e000 	add	x0, x0, #0x838
   83084:	94000799 	bl	84ee8 <uart_sendline>
    }
    test_exit();
   83088:	97ffff7f 	bl	82e84 <test_exit>

    // kill test
    // test_kill(test_getpid());
    // uart_sendline("failed to suicide\n");
}
   8308c:	d503201f 	nop
   83090:	a8cb7bfd 	ldp	x29, x30, [sp], #176
   83094:	d65f03c0 	ret

0000000000083098 <getpid>:
        The arguments would be stored in x0, x1, x2, 
        Return value would be stored in x0
        The system call numbers given would be stored in x8
    !!!!!!!!!!!!!!!!
*/
int getpid(trap_frame *tpf) {
   83098:	d10043ff 	sub	sp, sp, #0x10
   8309c:	f90007e0 	str	x0, [sp, #8]
    tpf->x0 = cur_thread->pid;
   830a0:	b0000020 	adrp	x0, 88000 <cmd_list+0x980>
   830a4:	f942fc00 	ldr	x0, [x0, #1528]
   830a8:	f9400000 	ldr	x0, [x0]
   830ac:	b9402000 	ldr	w0, [x0, #32]
   830b0:	93407c01 	sxtw	x1, w0
   830b4:	f94007e0 	ldr	x0, [sp, #8]
   830b8:	f9000001 	str	x1, [x0]
    return cur_thread->pid;
   830bc:	b0000020 	adrp	x0, 88000 <cmd_list+0x980>
   830c0:	f942fc00 	ldr	x0, [x0, #1528]
   830c4:	f9400000 	ldr	x0, [x0]
   830c8:	b9402000 	ldr	w0, [x0, #32]
}
   830cc:	910043ff 	add	sp, sp, #0x10
   830d0:	d65f03c0 	ret

00000000000830d4 <uart_read>:

// user have to allocate spaces to x0(buf) themself
size_t uart_read(trap_frame *tpf, char buf[], size_t size) {
   830d4:	a9bb7bfd 	stp	x29, x30, [sp, #-80]!
   830d8:	910003fd 	mov	x29, sp
   830dc:	f9000bf3 	str	x19, [sp, #16]
   830e0:	f9001fe0 	str	x0, [sp, #56]
   830e4:	f9001be1 	str	x1, [sp, #48]
   830e8:	f90017e2 	str	x2, [sp, #40]
    int i = 0;
   830ec:	b9004fff 	str	wzr, [sp, #76]
    while (i < size)
   830f0:	1400000a 	b	83118 <uart_read+0x44>
        buf[i++] = uart_async_getc();
   830f4:	b9404fe0 	ldr	w0, [sp, #76]
   830f8:	11000401 	add	w1, w0, #0x1
   830fc:	b9004fe1 	str	w1, [sp, #76]
   83100:	93407c00 	sxtw	x0, w0
   83104:	f9401be1 	ldr	x1, [sp, #48]
   83108:	8b000033 	add	x19, x1, x0
   8310c:	94000830 	bl	851cc <uart_async_getc>
   83110:	12001c00 	and	w0, w0, #0xff
   83114:	39000260 	strb	w0, [x19]
    while (i < size)
   83118:	b9804fe0 	ldrsw	x0, [sp, #76]
   8311c:	f94017e1 	ldr	x1, [sp, #40]
   83120:	eb00003f 	cmp	x1, x0
   83124:	54fffe88 	b.hi	830f4 <uart_read+0x20>  // b.pmore
    tpf->x0 = i;
   83128:	b9804fe1 	ldrsw	x1, [sp, #76]
   8312c:	f9401fe0 	ldr	x0, [sp, #56]
   83130:	f9000001 	str	x1, [x0]
    return i;
   83134:	b9804fe0 	ldrsw	x0, [sp, #76]
}
   83138:	f9400bf3 	ldr	x19, [sp, #16]
   8313c:	a8c57bfd 	ldp	x29, x30, [sp], #80
   83140:	d65f03c0 	ret

0000000000083144 <uart_write>:

// user have to allocate spaces to x0(buf) themself
size_t uart_write(trap_frame *tpf, const char buf[], size_t size) {
   83144:	a9bc7bfd 	stp	x29, x30, [sp, #-64]!
   83148:	910003fd 	mov	x29, sp
   8314c:	f90017e0 	str	x0, [sp, #40]
   83150:	f90013e1 	str	x1, [sp, #32]
   83154:	f9000fe2 	str	x2, [sp, #24]
    int i = 0;
   83158:	b9003fff 	str	wzr, [sp, #60]
    while (i < size)
   8315c:	14000009 	b	83180 <uart_write+0x3c>
        uart_async_putc(buf[i++]);
   83160:	b9403fe0 	ldr	w0, [sp, #60]
   83164:	11000401 	add	w1, w0, #0x1
   83168:	b9003fe1 	str	w1, [sp, #60]
   8316c:	93407c00 	sxtw	x0, w0
   83170:	f94013e1 	ldr	x1, [sp, #32]
   83174:	8b000020 	add	x0, x1, x0
   83178:	39400000 	ldrb	w0, [x0]
   8317c:	940007ee 	bl	85134 <uart_async_putc>
    while (i < size)
   83180:	b9803fe0 	ldrsw	x0, [sp, #60]
   83184:	f9400fe1 	ldr	x1, [sp, #24]
   83188:	eb00003f 	cmp	x1, x0
   8318c:	54fffea8 	b.hi	83160 <uart_write+0x1c>  // b.pmore
    tpf->x0 = i;
   83190:	b9803fe1 	ldrsw	x1, [sp, #60]
   83194:	f94017e0 	ldr	x0, [sp, #40]
   83198:	f9000001 	str	x1, [x0]
    return i;
   8319c:	b9803fe0 	ldrsw	x0, [sp, #60]
}
   831a0:	a8c47bfd 	ldp	x29, x30, [sp], #64
   831a4:	d65f03c0 	ret

00000000000831a8 <exec>:

// Note: In this lab, you wont have to deal with argument passing, but you can still use it.
int exec(trap_frame *tpf, const char *name, char *const argv[]) {
   831a8:	a9bc7bfd 	stp	x29, x30, [sp, #-64]!
   831ac:	910003fd 	mov	x29, sp
   831b0:	f9000bf3 	str	x19, [sp, #16]
   831b4:	f9001fe0 	str	x0, [sp, #56]
   831b8:	f9001be1 	str	x1, [sp, #48]
   831bc:	f90017e2 	str	x2, [sp, #40]
    cur_thread->codesize = get_file_size((char *)name);
   831c0:	b0000020 	adrp	x0, 88000 <cmd_list+0x980>
   831c4:	f942fc00 	ldr	x0, [x0, #1528]
   831c8:	f9400013 	ldr	x19, [x0]
   831cc:	f9401be0 	ldr	x0, [sp, #48]
   831d0:	94000103 	bl	835dc <get_file_size>
   831d4:	b9001a60 	str	w0, [x19, #24]
    memcpy(cur_thread->code, get_file_start((char *)name), cur_thread->codesize);
   831d8:	b0000020 	adrp	x0, 88000 <cmd_list+0x980>
   831dc:	f942fc00 	ldr	x0, [x0, #1528]
   831e0:	f9400000 	ldr	x0, [x0]
   831e4:	f9400813 	ldr	x19, [x0, #16]
   831e8:	f9401be0 	ldr	x0, [sp, #48]
   831ec:	94000127 	bl	83688 <get_file_start>
   831f0:	aa0003e1 	mov	x1, x0
   831f4:	b0000020 	adrp	x0, 88000 <cmd_list+0x980>
   831f8:	f942fc00 	ldr	x0, [x0, #1528]
   831fc:	f9400000 	ldr	x0, [x0]
   83200:	b9401800 	ldr	w0, [x0, #24]
   83204:	2a0003e0 	mov	w0, w0
   83208:	aa0003e2 	mov	x2, x0
   8320c:	aa1303e0 	mov	x0, x19
   83210:	94000622 	bl	84a98 <memcpy>
    tpf->elr_el1 = (unsigned long)cur_thread->code;
   83214:	b0000020 	adrp	x0, 88000 <cmd_list+0x980>
   83218:	f942fc00 	ldr	x0, [x0, #1528]
   8321c:	f9400000 	ldr	x0, [x0]
   83220:	f9400800 	ldr	x0, [x0, #16]
   83224:	aa0003e1 	mov	x1, x0
   83228:	f9401fe0 	ldr	x0, [sp, #56]
   8322c:	f9008001 	str	x1, [x0, #256]
    tpf->sp_el0 = (unsigned long)cur_thread->user_stack_ptr + USTACK_SIZE;
   83230:	b0000020 	adrp	x0, 88000 <cmd_list+0x980>
   83234:	f942fc00 	ldr	x0, [x0, #1528]
   83238:	f9400000 	ldr	x0, [x0]
   8323c:	f9401400 	ldr	x0, [x0, #40]
   83240:	91404001 	add	x1, x0, #0x10, lsl #12
   83244:	f9401fe0 	ldr	x0, [sp, #56]
   83248:	f9008401 	str	x1, [x0, #264]
    tpf->x0 = 0;
   8324c:	f9401fe0 	ldr	x0, [sp, #56]
   83250:	f900001f 	str	xzr, [x0]
    return 0;
   83254:	52800000 	mov	w0, #0x0                   	// #0
}
   83258:	f9400bf3 	ldr	x19, [sp, #16]
   8325c:	a8c47bfd 	ldp	x29, x30, [sp], #64
   83260:	d65f03c0 	ret

0000000000083264 <fork>:

// return child's id to parent, return 0 to child
int fork(trap_frame *tpf) {
   83264:	a9bb7bfd 	stp	x29, x30, [sp, #-80]!
   83268:	910003fd 	mov	x29, sp
   8326c:	f9000fe0 	str	x0, [sp, #24]
    lock();
   83270:	97fff5e2 	bl	809f8 <lock>

    thread *child = thread_create(cur_thread->code);                        // create new thread
   83274:	b0000020 	adrp	x0, 88000 <cmd_list+0x980>
   83278:	f942fc00 	ldr	x0, [x0, #1528]
   8327c:	f9400000 	ldr	x0, [x0]
   83280:	f9400800 	ldr	x0, [x0, #16]
   83284:	94000177 	bl	83860 <thread_create>
   83288:	f90027e0 	str	x0, [sp, #72]
    thread *parent = cur_thread;                                            // backup parent thread
   8328c:	b0000020 	adrp	x0, 88000 <cmd_list+0x980>
   83290:	f942fc00 	ldr	x0, [x0, #1528]
   83294:	f9400000 	ldr	x0, [x0]
   83298:	f90023e0 	str	x0, [sp, #64]
    int parent_id = cur_thread->pid;                                        // record original pid
   8329c:	b0000020 	adrp	x0, 88000 <cmd_list+0x980>
   832a0:	f942fc00 	ldr	x0, [x0, #1528]
   832a4:	f9400000 	ldr	x0, [x0]
   832a8:	b9402000 	ldr	w0, [x0, #32]
   832ac:	b9003fe0 	str	w0, [sp, #60]
    child->codesize = cur_thread->codesize;                                 // assign size
   832b0:	b0000020 	adrp	x0, 88000 <cmd_list+0x980>
   832b4:	f942fc00 	ldr	x0, [x0, #1528]
   832b8:	f9400000 	ldr	x0, [x0]
   832bc:	b9401801 	ldr	w1, [x0, #24]
   832c0:	f94027e0 	ldr	x0, [sp, #72]
   832c4:	b9001801 	str	w1, [x0, #24]
    memcpy(child->kernel_stack_ptr, parent->kernel_stack_ptr, KSTACK_SIZE); // copy kernel stack (deep copy)
   832c8:	f94027e0 	ldr	x0, [sp, #72]
   832cc:	f9401803 	ldr	x3, [x0, #48]
   832d0:	f94023e0 	ldr	x0, [sp, #64]
   832d4:	f9401800 	ldr	x0, [x0, #48]
   832d8:	d2a00022 	mov	x2, #0x10000               	// #65536
   832dc:	aa0003e1 	mov	x1, x0
   832e0:	aa0303e0 	mov	x0, x3
   832e4:	940005ed 	bl	84a98 <memcpy>
    memcpy(child->user_stack_ptr, parent->user_stack_ptr, USTACK_SIZE);     // copy user stack (deep copy)
   832e8:	f94027e0 	ldr	x0, [sp, #72]
   832ec:	f9401403 	ldr	x3, [x0, #40]
   832f0:	f94023e0 	ldr	x0, [sp, #64]
   832f4:	f9401400 	ldr	x0, [x0, #40]
   832f8:	d2a00022 	mov	x2, #0x10000               	// #65536
   832fc:	aa0003e1 	mov	x1, x0
   83300:	aa0303e0 	mov	x0, x3
   83304:	940005e5 	bl	84a98 <memcpy>

    // before coping context, update parent's context first!!!
    store_context(get_current());
   83308:	94000bda 	bl	86270 <get_current>
   8330c:	94000bdb 	bl	86278 <store_context>

    // child
    if (cur_thread->pid != parent_id) {
   83310:	b0000020 	adrp	x0, 88000 <cmd_list+0x980>
   83314:	f942fc00 	ldr	x0, [x0, #1528]
   83318:	f9400000 	ldr	x0, [x0]
   8331c:	b9402000 	ldr	w0, [x0, #32]
   83320:	b9403fe1 	ldr	w1, [sp, #60]
   83324:	6b00003f 	cmp	w1, w0
   83328:	540002e0 	b.eq	83384 <fork+0x120>  // b.none
        // TODO: explain why (parent's tpf + offset) = child's tpf -> because tpf in inside kernel stack
        // because the copied trap_frame still point to parent's trap_frame, so need to give it an offset
        unsigned long long offset = (unsigned long long)(child->kernel_stack_ptr) - (unsigned long long)(parent->kernel_stack_ptr);
   8332c:	f94027e0 	ldr	x0, [sp, #72]
   83330:	f9401800 	ldr	x0, [x0, #48]
   83334:	aa0003e1 	mov	x1, x0
   83338:	f94023e0 	ldr	x0, [sp, #64]
   8333c:	f9401800 	ldr	x0, [x0, #48]
   83340:	cb000020 	sub	x0, x1, x0
   83344:	f90017e0 	str	x0, [sp, #40]
        tpf = (trap_frame *)((char *)tpf + offset); // move child's tpf to "child's tpf in its stack"
   83348:	f9400fe1 	ldr	x1, [sp, #24]
   8334c:	f94017e0 	ldr	x0, [sp, #40]
   83350:	8b000020 	add	x0, x1, x0
   83354:	f9000fe0 	str	x0, [sp, #24]
        tpf->sp_el0 += offset;
   83358:	f9400fe0 	ldr	x0, [sp, #24]
   8335c:	f9408401 	ldr	x1, [x0, #264]
   83360:	f94017e0 	ldr	x0, [sp, #40]
   83364:	8b000021 	add	x1, x1, x0
   83368:	f9400fe0 	ldr	x0, [sp, #24]
   8336c:	f9008401 	str	x1, [x0, #264]
        tpf->x0 = 0;
   83370:	f9400fe0 	ldr	x0, [sp, #24]
   83374:	f900001f 	str	xzr, [x0]
        unlock();
   83378:	97fff5a6 	bl	80a10 <unlock>
        return 0; // jump to link register
   8337c:	52800000 	mov	w0, #0x0                   	// #0
   83380:	14000031 	b	83444 <fork+0x1e0>
    }

    // copy parent's context
    child->context = cur_thread->context;
   83384:	b0000020 	adrp	x0, 88000 <cmd_list+0x980>
   83388:	f942fc00 	ldr	x0, [x0, #1528]
   8338c:	f9400000 	ldr	x0, [x0]
   83390:	f94027e1 	ldr	x1, [sp, #72]
   83394:	9100e022 	add	x2, x1, #0x38
   83398:	9100e001 	add	x1, x0, #0x38
   8339c:	aa0203e0 	mov	x0, x2
   833a0:	a9400c22 	ldp	x2, x3, [x1]
   833a4:	a9000c02 	stp	x2, x3, [x0]
   833a8:	a9410c22 	ldp	x2, x3, [x1, #16]
   833ac:	a9010c02 	stp	x2, x3, [x0, #16]
   833b0:	a9420c22 	ldp	x2, x3, [x1, #32]
   833b4:	a9020c02 	stp	x2, x3, [x0, #32]
   833b8:	a9430c22 	ldp	x2, x3, [x1, #48]
   833bc:	a9030c02 	stp	x2, x3, [x0, #48]
   833c0:	a9440c22 	ldp	x2, x3, [x1, #64]
   833c4:	a9040c02 	stp	x2, x3, [x0, #64]
   833c8:	a9450c22 	ldp	x2, x3, [x1, #80]
   833cc:	a9050c02 	stp	x2, x3, [x0, #80]
   833d0:	f9403021 	ldr	x1, [x1, #96]
   833d4:	f9003001 	str	x1, [x0, #96]
    // fix stacks's offset
    // when create new thread, it will get a private/kernel stack space
    unsigned long long offset = (unsigned long long)(child->kernel_stack_ptr) - (unsigned long long)(parent->kernel_stack_ptr);
   833d8:	f94027e0 	ldr	x0, [sp, #72]
   833dc:	f9401800 	ldr	x0, [x0, #48]
   833e0:	aa0003e1 	mov	x1, x0
   833e4:	f94023e0 	ldr	x0, [sp, #64]
   833e8:	f9401800 	ldr	x0, [x0, #48]
   833ec:	cb000020 	sub	x0, x1, x0
   833f0:	f9001be0 	str	x0, [sp, #48]
    child->context.fp += offset;
   833f4:	f94027e0 	ldr	x0, [sp, #72]
   833f8:	f9404401 	ldr	x1, [x0, #136]
   833fc:	f9401be0 	ldr	x0, [sp, #48]
   83400:	8b000021 	add	x1, x1, x0
   83404:	f94027e0 	ldr	x0, [sp, #72]
   83408:	f9004401 	str	x1, [x0, #136]
    child->context.sp += offset;
   8340c:	f94027e0 	ldr	x0, [sp, #72]
   83410:	f9404c01 	ldr	x1, [x0, #152]
   83414:	f9401be0 	ldr	x0, [sp, #48]
   83418:	8b000021 	add	x1, x1, x0
   8341c:	f94027e0 	ldr	x0, [sp, #72]
   83420:	f9004c01 	str	x1, [x0, #152]

    tpf->x0 = child->pid; // return child's pid
   83424:	f94027e0 	ldr	x0, [sp, #72]
   83428:	b9402000 	ldr	w0, [x0, #32]
   8342c:	93407c01 	sxtw	x1, w0
   83430:	f9400fe0 	ldr	x0, [sp, #24]
   83434:	f9000001 	str	x1, [x0]
    unlock();
   83438:	97fff576 	bl	80a10 <unlock>
    return child->pid; // return child's pid
   8343c:	f94027e0 	ldr	x0, [sp, #72]
   83440:	b9402000 	ldr	w0, [x0, #32]
}
   83444:	a8c57bfd 	ldp	x29, x30, [sp], #80
   83448:	d65f03c0 	ret

000000000008344c <exit>:

void exit(trap_frame *tpf, int status) {
   8344c:	a9be7bfd 	stp	x29, x30, [sp, #-32]!
   83450:	910003fd 	mov	x29, sp
   83454:	f9000fe0 	str	x0, [sp, #24]
   83458:	b90017e1 	str	w1, [sp, #20]
    thread_exit();
   8345c:	94000198 	bl	83abc <thread_exit>
}
   83460:	d503201f 	nop
   83464:	a8c27bfd 	ldp	x29, x30, [sp], #32
   83468:	d65f03c0 	ret

000000000008346c <mbox_call>:

int mbox_call(trap_frame *tpf, unsigned char ch, unsigned int *mbox) {
   8346c:	a9bc7bfd 	stp	x29, x30, [sp, #-64]!
   83470:	910003fd 	mov	x29, sp
   83474:	f90017e0 	str	x0, [sp, #40]
   83478:	39009fe1 	strb	w1, [sp, #39]
   8347c:	f9000fe2 	str	x2, [sp, #24]
    lock();
   83480:	97fff55e 	bl	809f8 <lock>

    unsigned int r = (*mbox & ~(0xF)) | (*mbox | ch);
   83484:	f9400fe0 	ldr	x0, [sp, #24]
   83488:	b9400000 	ldr	w0, [x0]
   8348c:	121c6c01 	and	w1, w0, #0xfffffff0
   83490:	f9400fe0 	ldr	x0, [sp, #24]
   83494:	b9400002 	ldr	w2, [x0]
   83498:	39409fe0 	ldrb	w0, [sp, #39]
   8349c:	2a000040 	orr	w0, w2, w0
   834a0:	2a000020 	orr	w0, w1, w0
   834a4:	b9003fe0 	str	w0, [sp, #60]
    while ((*MBOX_STATUS & BCM_ARM_VC_MS_FULL) != 0) {}
   834a8:	d503201f 	nop
   834ac:	d2971300 	mov	x0, #0xb898                	// #47256
   834b0:	f2a7e000 	movk	x0, #0x3f00, lsl #16
   834b4:	b9400000 	ldr	w0, [x0]
   834b8:	7100001f 	cmp	w0, #0x0
   834bc:	54ffff8b 	b.lt	834ac <mbox_call+0x40>  // b.tstop
    *MBOX_WRITE = r;
   834c0:	d2971400 	mov	x0, #0xb8a0                	// #47264
   834c4:	f2a7e000 	movk	x0, #0x3f00, lsl #16
   834c8:	b9403fe1 	ldr	w1, [sp, #60]
   834cc:	b9000001 	str	w1, [x0]

    while (1) {
        while (*MBOX_STATUS & BCM_ARM_VC_MS_EMPTY) {}
   834d0:	d503201f 	nop
   834d4:	d2971300 	mov	x0, #0xb898                	// #47256
   834d8:	f2a7e000 	movk	x0, #0x3f00, lsl #16
   834dc:	b9400000 	ldr	w0, [x0]
   834e0:	12020000 	and	w0, w0, #0x40000000
   834e4:	7100001f 	cmp	w0, #0x0
   834e8:	54ffff61 	b.ne	834d4 <mbox_call+0x68>  // b.any
        if (*MBOX_READ == r) {
   834ec:	d2971000 	mov	x0, #0xb880                	// #47232
   834f0:	f2a7e000 	movk	x0, #0x3f00, lsl #16
   834f4:	b9400000 	ldr	w0, [x0]
   834f8:	b9403fe1 	ldr	w1, [sp, #60]
   834fc:	6b00003f 	cmp	w1, w0
   83500:	54fffe81 	b.ne	834d0 <mbox_call+0x64>  // b.any
            tpf->x0 = (mbox[1] == MBOX_REQUEST_SUCCEED);
   83504:	f9400fe0 	ldr	x0, [sp, #24]
   83508:	91001000 	add	x0, x0, #0x4
   8350c:	b9400001 	ldr	w1, [x0]
   83510:	52b00000 	mov	w0, #0x80000000            	// #-2147483648
   83514:	6b00003f 	cmp	w1, w0
   83518:	1a9f17e0 	cset	w0, eq  // eq = none
   8351c:	12001c00 	and	w0, w0, #0xff
   83520:	92401c01 	and	x1, x0, #0xff
   83524:	f94017e0 	ldr	x0, [sp, #40]
   83528:	f9000001 	str	x1, [x0]
            unlock();
   8352c:	97fff539 	bl	80a10 <unlock>
            return tpf->x0;
   83530:	f94017e0 	ldr	x0, [sp, #40]
   83534:	f9400000 	ldr	x0, [x0]
        }
    }
    tpf->x0 = 0;
    unlock();
    return 0;
}
   83538:	a8c47bfd 	ldp	x29, x30, [sp], #64
   8353c:	d65f03c0 	ret

0000000000083540 <kill>:

void kill(trap_frame *tpf, int pid) {
   83540:	a9be7bfd 	stp	x29, x30, [sp, #-32]!
   83544:	910003fd 	mov	x29, sp
   83548:	f9000fe0 	str	x0, [sp, #24]
   8354c:	b90017e1 	str	w1, [sp, #20]
    if (pid < 0 || pid > MAXPID || !thread_list[pid].isused)
   83550:	b94017e0 	ldr	w0, [sp, #20]
   83554:	7100001f 	cmp	w0, #0x0
   83558:	540003cb 	b.lt	835d0 <kill+0x90>  // b.tstop
   8355c:	b94017e1 	ldr	w1, [sp, #20]
   83560:	528ff4c0 	mov	w0, #0x7fa6                	// #32678
   83564:	6b00003f 	cmp	w1, w0
   83568:	5400034c 	b.gt	835d0 <kill+0x90>
   8356c:	b0000020 	adrp	x0, 88000 <cmd_list+0x980>
   83570:	f942e002 	ldr	x2, [x0, #1472]
   83574:	b98017e1 	ldrsw	x1, [sp, #20]
   83578:	aa0103e0 	mov	x0, x1
   8357c:	d37ef400 	lsl	x0, x0, #2
   83580:	8b010000 	add	x0, x0, x1
   83584:	d37be800 	lsl	x0, x0, #5
   83588:	8b000040 	add	x0, x2, x0
   8358c:	b9402400 	ldr	w0, [x0, #36]
   83590:	7100001f 	cmp	w0, #0x0
   83594:	540001e0 	b.eq	835d0 <kill+0x90>  // b.none
        return;
    lock();
   83598:	97fff518 	bl	809f8 <lock>
    thread_list[pid].iszombie = 1;
   8359c:	b0000020 	adrp	x0, 88000 <cmd_list+0x980>
   835a0:	f942e002 	ldr	x2, [x0, #1472]
   835a4:	b98017e1 	ldrsw	x1, [sp, #20]
   835a8:	aa0103e0 	mov	x0, x1
   835ac:	d37ef400 	lsl	x0, x0, #2
   835b0:	8b010000 	add	x0, x0, x1
   835b4:	d37be800 	lsl	x0, x0, #5
   835b8:	8b000040 	add	x0, x2, x0
   835bc:	52800021 	mov	w1, #0x1                   	// #1
   835c0:	b9001c01 	str	w1, [x0, #28]
    unlock();
   835c4:	97fff513 	bl	80a10 <unlock>
    schedule();
   835c8:	94000117 	bl	83a24 <schedule>
   835cc:	14000002 	b	835d4 <kill+0x94>
        return;
   835d0:	d503201f 	nop
}
   835d4:	a8c27bfd 	ldp	x29, x30, [sp], #32
   835d8:	d65f03c0 	ret

00000000000835dc <get_file_size>:

unsigned int get_file_size(char *path) {
   835dc:	a9bb7bfd 	stp	x29, x30, [sp, #-80]!
   835e0:	910003fd 	mov	x29, sp
   835e4:	f9000fe0 	str	x0, [sp, #24]
    char *filepath, *filedata;
    unsigned int filesize;
    struct cpio_newc_header *head = CPIO_DEFAULT_START;
   835e8:	b0000020 	adrp	x0, 88000 <cmd_list+0x980>
   835ec:	f942f800 	ldr	x0, [x0, #1520]
   835f0:	f9400000 	ldr	x0, [x0]
   835f4:	f90017e0 	str	x0, [sp, #40]

    // traverse the whole ramdisk, check filename one by one
    while (head != 0) {
   835f8:	1400001e 	b	83670 <get_file_size+0x94>
        int error = cpio_newc_parse_header(head, &filepath, &filesize, &filedata, &head);
   835fc:	f94017e0 	ldr	x0, [sp, #40]
   83600:	9100a3e4 	add	x4, sp, #0x28
   83604:	9100e3e3 	add	x3, sp, #0x38
   83608:	9100d3e2 	add	x2, sp, #0x34
   8360c:	910103e1 	add	x1, sp, #0x40
   83610:	97fff2ed 	bl	801c4 <cpio_newc_parse_header>
   83614:	b9004fe0 	str	w0, [sp, #76]
        if (error) {
   83618:	b9404fe0 	ldr	w0, [sp, #76]
   8361c:	7100001f 	cmp	w0, #0x0
   83620:	540000c0 	b.eq	83638 <get_file_size+0x5c>  // b.none
            uart_sendline("cpio parse error\n");
   83624:	f0000000 	adrp	x0, 86000 <el1t_irq_invalid+0x78>
   83628:	91216000 	add	x0, x0, #0x858
   8362c:	9400062f 	bl	84ee8 <uart_sendline>
            return -1;
   83630:	12800000 	mov	w0, #0xffffffff            	// #-1
   83634:	14000013 	b	83680 <get_file_size+0xa4>
        }
        if (strcmp(filepath, path) == 0)
   83638:	f94023e0 	ldr	x0, [sp, #64]
   8363c:	f9400fe1 	ldr	x1, [sp, #24]
   83640:	9400046b 	bl	847ec <strcmp>
   83644:	7100001f 	cmp	w0, #0x0
   83648:	54000061 	b.ne	83654 <get_file_size+0x78>  // b.any
            return filesize;
   8364c:	b94037e0 	ldr	w0, [sp, #52]
   83650:	1400000c 	b	83680 <get_file_size+0xa4>

        // if TRAILER!!!
        if (head == 0)
   83654:	f94017e0 	ldr	x0, [sp, #40]
   83658:	f100001f 	cmp	x0, #0x0
   8365c:	540000a1 	b.ne	83670 <get_file_size+0x94>  // b.any
            uart_sendline("execfile: %s: No such file or directory\n", path);
   83660:	f9400fe1 	ldr	x1, [sp, #24]
   83664:	f0000000 	adrp	x0, 86000 <el1t_irq_invalid+0x78>
   83668:	9121c000 	add	x0, x0, #0x870
   8366c:	9400061f 	bl	84ee8 <uart_sendline>
    while (head != 0) {
   83670:	f94017e0 	ldr	x0, [sp, #40]
   83674:	f100001f 	cmp	x0, #0x0
   83678:	54fffc21 	b.ne	835fc <get_file_size+0x20>  // b.any
    }
    return 0;
   8367c:	52800000 	mov	w0, #0x0                   	// #0
}
   83680:	a8c57bfd 	ldp	x29, x30, [sp], #80
   83684:	d65f03c0 	ret

0000000000083688 <get_file_start>:

char *get_file_start(char *path) {
   83688:	a9bb7bfd 	stp	x29, x30, [sp, #-80]!
   8368c:	910003fd 	mov	x29, sp
   83690:	f9000fe0 	str	x0, [sp, #24]
    char *filepath, *filedata;
    unsigned int filesize;
    struct cpio_newc_header *head = CPIO_DEFAULT_START;
   83694:	b0000020 	adrp	x0, 88000 <cmd_list+0x980>
   83698:	f942f800 	ldr	x0, [x0, #1520]
   8369c:	f9400000 	ldr	x0, [x0]
   836a0:	f90017e0 	str	x0, [sp, #40]

    // traverse the whole ramdisk, check filename one by one
    while (head != 0) {
   836a4:	1400001d 	b	83718 <get_file_start+0x90>
        int error = cpio_newc_parse_header(head, &filepath, &filesize, &filedata, &head);
   836a8:	f94017e0 	ldr	x0, [sp, #40]
   836ac:	9100a3e4 	add	x4, sp, #0x28
   836b0:	9100e3e3 	add	x3, sp, #0x38
   836b4:	9100d3e2 	add	x2, sp, #0x34
   836b8:	910103e1 	add	x1, sp, #0x40
   836bc:	97fff2c2 	bl	801c4 <cpio_newc_parse_header>
   836c0:	b9004fe0 	str	w0, [sp, #76]
        if (error) {
   836c4:	b9404fe0 	ldr	w0, [sp, #76]
   836c8:	7100001f 	cmp	w0, #0x0
   836cc:	540000a0 	b.eq	836e0 <get_file_start+0x58>  // b.none
            uart_sendline("cpio parse error\n");
   836d0:	f0000000 	adrp	x0, 86000 <el1t_irq_invalid+0x78>
   836d4:	91216000 	add	x0, x0, #0x858
   836d8:	94000604 	bl	84ee8 <uart_sendline>
            break;
   836dc:	14000012 	b	83724 <get_file_start+0x9c>
        }
        if (strcmp(filepath, path) == 0)
   836e0:	f94023e0 	ldr	x0, [sp, #64]
   836e4:	f9400fe1 	ldr	x1, [sp, #24]
   836e8:	94000441 	bl	847ec <strcmp>
   836ec:	7100001f 	cmp	w0, #0x0
   836f0:	54000061 	b.ne	836fc <get_file_start+0x74>  // b.any
            return filedata;
   836f4:	f9401fe0 	ldr	x0, [sp, #56]
   836f8:	1400000c 	b	83728 <get_file_start+0xa0>

        // if TRAILER!!!
        if (head == 0)
   836fc:	f94017e0 	ldr	x0, [sp, #40]
   83700:	f100001f 	cmp	x0, #0x0
   83704:	540000a1 	b.ne	83718 <get_file_start+0x90>  // b.any
            uart_sendline("execfile: %s: No such file or directory\n", path);
   83708:	f9400fe1 	ldr	x1, [sp, #24]
   8370c:	f0000000 	adrp	x0, 86000 <el1t_irq_invalid+0x78>
   83710:	9121c000 	add	x0, x0, #0x870
   83714:	940005f5 	bl	84ee8 <uart_sendline>
    while (head != 0) {
   83718:	f94017e0 	ldr	x0, [sp, #40]
   8371c:	f100001f 	cmp	x0, #0x0
   83720:	54fffc41 	b.ne	836a8 <get_file_start+0x20>  // b.any
    }
    return 0;
   83724:	d2800000 	mov	x0, #0x0                   	// #0
   83728:	a8c57bfd 	ldp	x29, x30, [sp], #80
   8372c:	d65f03c0 	ret

0000000000083730 <init_thread>:
thread thread_list[MAXPID + 1];
thread *cur_thread;

int pid_cnt = 0;

void init_thread() {
   83730:	a9be7bfd 	stp	x29, x30, [sp, #-32]!
   83734:	910003fd 	mov	x29, sp
    lock();
   83738:	97fff4b0 	bl	809f8 <lock>
    // init 'thread_list' & 'run_queue'
    run_queue = kmalloc(sizeof(thread));
   8373c:	52801400 	mov	w0, #0xa0                  	// #160
   83740:	97fff960 	bl	81cc0 <kmalloc>
   83744:	aa0003e1 	mov	x1, x0
   83748:	b0000020 	adrp	x0, 88000 <cmd_list+0x980>
   8374c:	911fe000 	add	x0, x0, #0x7f8
   83750:	f9000001 	str	x1, [x0]
    run_queue->next = run_queue;
   83754:	b0000020 	adrp	x0, 88000 <cmd_list+0x980>
   83758:	911fe000 	add	x0, x0, #0x7f8
   8375c:	f9400000 	ldr	x0, [x0]
   83760:	b0000021 	adrp	x1, 88000 <cmd_list+0x980>
   83764:	911fe021 	add	x1, x1, #0x7f8
   83768:	f9400021 	ldr	x1, [x1]
   8376c:	f9000001 	str	x1, [x0]
    run_queue->prev = run_queue;
   83770:	b0000020 	adrp	x0, 88000 <cmd_list+0x980>
   83774:	911fe000 	add	x0, x0, #0x7f8
   83778:	f9400000 	ldr	x0, [x0]
   8377c:	b0000021 	adrp	x1, 88000 <cmd_list+0x980>
   83780:	911fe021 	add	x1, x1, #0x7f8
   83784:	f9400021 	ldr	x1, [x1]
   83788:	f9000401 	str	x1, [x0, #8]

    for (int i = 0; i <= MAXPID; i++) {
   8378c:	b9001fff 	str	wzr, [sp, #28]
   83790:	14000020 	b	83810 <init_thread+0xe0>
        thread_list[i].isused = 0;
   83794:	b0000020 	adrp	x0, 88000 <cmd_list+0x980>
   83798:	91200002 	add	x2, x0, #0x800
   8379c:	b9801fe1 	ldrsw	x1, [sp, #28]
   837a0:	aa0103e0 	mov	x0, x1
   837a4:	d37ef400 	lsl	x0, x0, #2
   837a8:	8b010000 	add	x0, x0, x1
   837ac:	d37be800 	lsl	x0, x0, #5
   837b0:	8b000040 	add	x0, x2, x0
   837b4:	b900241f 	str	wzr, [x0, #36]
        thread_list[i].iszombie = 0;
   837b8:	b0000020 	adrp	x0, 88000 <cmd_list+0x980>
   837bc:	91200002 	add	x2, x0, #0x800
   837c0:	b9801fe1 	ldrsw	x1, [sp, #28]
   837c4:	aa0103e0 	mov	x0, x1
   837c8:	d37ef400 	lsl	x0, x0, #2
   837cc:	8b010000 	add	x0, x0, x1
   837d0:	d37be800 	lsl	x0, x0, #5
   837d4:	8b000040 	add	x0, x2, x0
   837d8:	b9001c1f 	str	wzr, [x0, #28]
        thread_list[i].pid = i;
   837dc:	b0000020 	adrp	x0, 88000 <cmd_list+0x980>
   837e0:	91200002 	add	x2, x0, #0x800
   837e4:	b9801fe1 	ldrsw	x1, [sp, #28]
   837e8:	aa0103e0 	mov	x0, x1
   837ec:	d37ef400 	lsl	x0, x0, #2
   837f0:	8b010000 	add	x0, x0, x1
   837f4:	d37be800 	lsl	x0, x0, #5
   837f8:	8b000040 	add	x0, x2, x0
   837fc:	b9401fe1 	ldr	w1, [sp, #28]
   83800:	b9002001 	str	w1, [x0, #32]
    for (int i = 0; i <= MAXPID; i++) {
   83804:	b9401fe0 	ldr	w0, [sp, #28]
   83808:	11000400 	add	w0, w0, #0x1
   8380c:	b9001fe0 	str	w0, [sp, #28]
   83810:	b9401fe1 	ldr	w1, [sp, #28]
   83814:	528ff4c0 	mov	w0, #0x7fa6                	// #32678
   83818:	6b00003f 	cmp	w1, w0
   8381c:	54fffbcd 	b.le	83794 <init_thread+0x64>
    }
    // BUG: Don't let thread structure NULL as we enable the functionality
    cur_thread = thread_create(idle);
   83820:	90000000 	adrp	x0, 83000 <fork_test+0x10c>
   83824:	912a8000 	add	x0, x0, #0xaa0
   83828:	9400000e 	bl	83860 <thread_create>
   8382c:	aa0003e1 	mov	x1, x0
   83830:	d0002800 	adrp	x0, 585000 <_bss_size+0x4e5675>
   83834:	91018000 	add	x0, x0, #0x60
   83838:	f9000001 	str	x1, [x0]
    asm volatile("msr tpidr_el1, %0" ::"r"(&cur_thread->context));
   8383c:	d0002800 	adrp	x0, 585000 <_bss_size+0x4e5675>
   83840:	91018000 	add	x0, x0, #0x60
   83844:	f9400000 	ldr	x0, [x0]
   83848:	9100e000 	add	x0, x0, #0x38
   8384c:	d518d080 	msr	tpidr_el1, x0

    unlock();
   83850:	97fff470 	bl	80a10 <unlock>
}
   83854:	d503201f 	nop
   83858:	a8c27bfd 	ldp	x29, x30, [sp], #32
   8385c:	d65f03c0 	ret

0000000000083860 <thread_create>:

thread *thread_create(void *funcion_start_point) {
   83860:	a9bd7bfd 	stp	x29, x30, [sp, #-48]!
   83864:	910003fd 	mov	x29, sp
   83868:	f9000fe0 	str	x0, [sp, #24]
    lock();
   8386c:	97fff463 	bl	809f8 <lock>
    thread *the_thread;
    if (pid_cnt > MAXPID)
   83870:	d0002800 	adrp	x0, 585000 <_bss_size+0x4e5675>
   83874:	9101a000 	add	x0, x0, #0x68
   83878:	b9400001 	ldr	w1, [x0]
   8387c:	528ff4c0 	mov	w0, #0x7fa6                	// #32678
   83880:	6b00003f 	cmp	w1, w0
   83884:	5400006d 	b.le	83890 <thread_create+0x30>
        return 0;
   83888:	d2800000 	mov	x0, #0x0                   	// #0
   8388c:	14000051 	b	839d0 <thread_create+0x170>

    // check the pid in thread_list, if not use yet, take it
    // TODO: pid_cnt need to mod max size
    if (!thread_list[pid_cnt].isused)
   83890:	d0002800 	adrp	x0, 585000 <_bss_size+0x4e5675>
   83894:	9101a000 	add	x0, x0, #0x68
   83898:	b9400001 	ldr	w1, [x0]
   8389c:	b0000020 	adrp	x0, 88000 <cmd_list+0x980>
   838a0:	91200002 	add	x2, x0, #0x800
   838a4:	93407c21 	sxtw	x1, w1
   838a8:	aa0103e0 	mov	x0, x1
   838ac:	d37ef400 	lsl	x0, x0, #2
   838b0:	8b010000 	add	x0, x0, x1
   838b4:	d37be800 	lsl	x0, x0, #5
   838b8:	8b000040 	add	x0, x2, x0
   838bc:	b9402400 	ldr	w0, [x0, #36]
   838c0:	7100001f 	cmp	w0, #0x0
   838c4:	54000841 	b.ne	839cc <thread_create+0x16c>  // b.any
        the_thread = &thread_list[pid_cnt++];
   838c8:	d0002800 	adrp	x0, 585000 <_bss_size+0x4e5675>
   838cc:	9101a000 	add	x0, x0, #0x68
   838d0:	b9400000 	ldr	w0, [x0]
   838d4:	11000402 	add	w2, w0, #0x1
   838d8:	d0002801 	adrp	x1, 585000 <_bss_size+0x4e5675>
   838dc:	9101a021 	add	x1, x1, #0x68
   838e0:	b9000022 	str	w2, [x1]
   838e4:	93407c01 	sxtw	x1, w0
   838e8:	aa0103e0 	mov	x0, x1
   838ec:	d37ef400 	lsl	x0, x0, #2
   838f0:	8b010000 	add	x0, x0, x1
   838f4:	d37be800 	lsl	x0, x0, #5
   838f8:	b0000021 	adrp	x1, 88000 <cmd_list+0x980>
   838fc:	91200021 	add	x1, x1, #0x800
   83900:	8b010000 	add	x0, x0, x1
   83904:	f90017e0 	str	x0, [sp, #40]
    else
        return 0;

    // init property of 'the_thread'
    the_thread->iszombie = 0;
   83908:	f94017e0 	ldr	x0, [sp, #40]
   8390c:	b9001c1f 	str	wzr, [x0, #28]
    the_thread->isused = 1;
   83910:	f94017e0 	ldr	x0, [sp, #40]
   83914:	52800021 	mov	w1, #0x1                   	// #1
   83918:	b9002401 	str	w1, [x0, #36]
    the_thread->user_stack_ptr = kmalloc(USTACK_SIZE);
   8391c:	52a00020 	mov	w0, #0x10000               	// #65536
   83920:	97fff8e8 	bl	81cc0 <kmalloc>
   83924:	aa0003e1 	mov	x1, x0
   83928:	f94017e0 	ldr	x0, [sp, #40]
   8392c:	f9001401 	str	x1, [x0, #40]
    // uart_sendline("ustack allocate: 0x%x\n", the_thread->user_stack_ptr);
    the_thread->kernel_stack_ptr = kmalloc(KSTACK_SIZE);
   83930:	52a00020 	mov	w0, #0x10000               	// #65536
   83934:	97fff8e3 	bl	81cc0 <kmalloc>
   83938:	aa0003e1 	mov	x1, x0
   8393c:	f94017e0 	ldr	x0, [sp, #40]
   83940:	f9001801 	str	x1, [x0, #48]
    // uart_sendline("kstack allocate: 0x%x\n", the_thread->kernel_stack_ptr);
    the_thread->context.lr = (unsigned long)funcion_start_point;
   83944:	f9400fe1 	ldr	x1, [sp, #24]
   83948:	f94017e0 	ldr	x0, [sp, #40]
   8394c:	f9004801 	str	x1, [x0, #144]
    // sp init to the top of allocated stack area
    the_thread->context.sp = (unsigned long)the_thread->user_stack_ptr + USTACK_SIZE;
   83950:	f94017e0 	ldr	x0, [sp, #40]
   83954:	f9401400 	ldr	x0, [x0, #40]
   83958:	91404001 	add	x1, x0, #0x10, lsl #12
   8395c:	f94017e0 	ldr	x0, [sp, #40]
   83960:	f9004c01 	str	x1, [x0, #152]
    the_thread->context.fp = the_thread->context.sp; // fp is the base addr, sp won't upper than fp
   83964:	f94017e0 	ldr	x0, [sp, #40]
   83968:	f9404c01 	ldr	x1, [x0, #152]
   8396c:	f94017e0 	ldr	x0, [sp, #40]
   83970:	f9004401 	str	x1, [x0, #136]

    // add it into run_queue tail
    the_thread->prev = run_queue->prev;
   83974:	b0000020 	adrp	x0, 88000 <cmd_list+0x980>
   83978:	911fe000 	add	x0, x0, #0x7f8
   8397c:	f9400000 	ldr	x0, [x0]
   83980:	f9400401 	ldr	x1, [x0, #8]
   83984:	f94017e0 	ldr	x0, [sp, #40]
   83988:	f9000401 	str	x1, [x0, #8]
    the_thread->next = run_queue;
   8398c:	b0000020 	adrp	x0, 88000 <cmd_list+0x980>
   83990:	911fe000 	add	x0, x0, #0x7f8
   83994:	f9400001 	ldr	x1, [x0]
   83998:	f94017e0 	ldr	x0, [sp, #40]
   8399c:	f9000001 	str	x1, [x0]
    the_thread->prev->next = the_thread;
   839a0:	f94017e0 	ldr	x0, [sp, #40]
   839a4:	f9400400 	ldr	x0, [x0, #8]
   839a8:	f94017e1 	ldr	x1, [sp, #40]
   839ac:	f9000001 	str	x1, [x0]
    the_thread->next->prev = the_thread;
   839b0:	f94017e0 	ldr	x0, [sp, #40]
   839b4:	f9400000 	ldr	x0, [x0]
   839b8:	f94017e1 	ldr	x1, [sp, #40]
   839bc:	f9000401 	str	x1, [x0, #8]

    unlock();
   839c0:	97fff414 	bl	80a10 <unlock>
    return the_thread;
   839c4:	f94017e0 	ldr	x0, [sp, #40]
   839c8:	14000002 	b	839d0 <thread_create+0x170>
        return 0;
   839cc:	d2800000 	mov	x0, #0x0                   	// #0
}
   839d0:	a8c37bfd 	ldp	x29, x30, [sp], #48
   839d4:	d65f03c0 	ret

00000000000839d8 <from_el1_to_el0>:

void from_el1_to_el0(thread *t) {
   839d8:	d10043ff 	sub	sp, sp, #0x10
   839dc:	f90007e0 	str	x0, [sp, #8]
    asm volatile("msr tpidr_el1, %0" ::"r"(&t->context)); // hold the kernel(el1) thread structure info
   839e0:	f94007e0 	ldr	x0, [sp, #8]
   839e4:	9100e000 	add	x0, x0, #0x38
   839e8:	d518d080 	msr	tpidr_el1, x0
    asm volatile("msr elr_el1, lr");                      // get back to caller function
   839ec:	d518403e 	msr	elr_el1, x30
    asm volatile("msr spsr_el1, %0" ::"r"(0x340));        // disable E A I F
   839f0:	52806800 	mov	w0, #0x340                 	// #832
   839f4:	d5184000 	msr	spsr_el1, x0
    asm volatile("msr sp_el0, %0" ::"r"(t->context.sp));
   839f8:	f94007e0 	ldr	x0, [sp, #8]
   839fc:	f9404c00 	ldr	x0, [x0, #152]
   83a00:	d5184100 	msr	sp_el0, x0
    asm volatile("mov sp, %0" ::"r"(t->kernel_stack_ptr + KSTACK_SIZE));
   83a04:	f94007e0 	ldr	x0, [sp, #8]
   83a08:	f9401800 	ldr	x0, [x0, #48]
   83a0c:	91404000 	add	x0, x0, #0x10, lsl #12
   83a10:	9100001f 	mov	sp, x0
    asm volatile("eret");
   83a14:	d69f03e0 	eret
}
   83a18:	d503201f 	nop
   83a1c:	910043ff 	add	sp, sp, #0x10
   83a20:	d65f03c0 	ret

0000000000083a24 <schedule>:

// find a job to schedule, otherwise spinning til found
void schedule() {
   83a24:	a9bf7bfd 	stp	x29, x30, [sp, #-16]!
   83a28:	910003fd 	mov	x29, sp
    lock();
   83a2c:	97fff3f3 	bl	809f8 <lock>
    do {
        cur_thread = cur_thread->next;
   83a30:	d0002800 	adrp	x0, 585000 <_bss_size+0x4e5675>
   83a34:	91018000 	add	x0, x0, #0x60
   83a38:	f9400000 	ldr	x0, [x0]
   83a3c:	f9400001 	ldr	x1, [x0]
   83a40:	d0002800 	adrp	x0, 585000 <_bss_size+0x4e5675>
   83a44:	91018000 	add	x0, x0, #0x60
   83a48:	f9000001 	str	x1, [x0]
    } while (cur_thread == run_queue);
   83a4c:	d0002800 	adrp	x0, 585000 <_bss_size+0x4e5675>
   83a50:	91018000 	add	x0, x0, #0x60
   83a54:	f9400001 	ldr	x1, [x0]
   83a58:	b0000020 	adrp	x0, 88000 <cmd_list+0x980>
   83a5c:	911fe000 	add	x0, x0, #0x7f8
   83a60:	f9400000 	ldr	x0, [x0]
   83a64:	eb00003f 	cmp	x1, x0
   83a68:	54fffe40 	b.eq	83a30 <schedule+0xc>  // b.none

    // context switch (defined in asm)
    // pass both thread's addr as base addr, to load/store the registers
    switch_to(get_current(), &cur_thread->context);
   83a6c:	94000a01 	bl	86270 <get_current>
   83a70:	aa0003e2 	mov	x2, x0
   83a74:	d0002800 	adrp	x0, 585000 <_bss_size+0x4e5675>
   83a78:	91018000 	add	x0, x0, #0x60
   83a7c:	f9400000 	ldr	x0, [x0]
   83a80:	9100e000 	add	x0, x0, #0x38
   83a84:	aa0003e1 	mov	x1, x0
   83a88:	aa0203e0 	mov	x0, x2
   83a8c:	940009e7 	bl	86228 <switch_to>
    unlock();
   83a90:	97fff3e0 	bl	80a10 <unlock>
}
   83a94:	d503201f 	nop
   83a98:	a8c17bfd 	ldp	x29, x30, [sp], #16
   83a9c:	d65f03c0 	ret

0000000000083aa0 <idle>:

void idle() {
   83aa0:	a9bf7bfd 	stp	x29, x30, [sp, #-16]!
   83aa4:	910003fd 	mov	x29, sp
    // TODO: program will stuck in idle
    kill_zombie();
   83aa8:	94000012 	bl	83af0 <kill_zombie>
    schedule();
   83aac:	97ffffde 	bl	83a24 <schedule>
}
   83ab0:	d503201f 	nop
   83ab4:	a8c17bfd 	ldp	x29, x30, [sp], #16
   83ab8:	d65f03c0 	ret

0000000000083abc <thread_exit>:

void thread_exit() {
   83abc:	a9bf7bfd 	stp	x29, x30, [sp, #-16]!
   83ac0:	910003fd 	mov	x29, sp
    lock();
   83ac4:	97fff3cd 	bl	809f8 <lock>
    cur_thread->iszombie = 1;
   83ac8:	d0002800 	adrp	x0, 585000 <_bss_size+0x4e5675>
   83acc:	91018000 	add	x0, x0, #0x60
   83ad0:	f9400000 	ldr	x0, [x0]
   83ad4:	52800021 	mov	w1, #0x1                   	// #1
   83ad8:	b9001c01 	str	w1, [x0, #28]
    unlock();
   83adc:	97fff3cd 	bl	80a10 <unlock>
    schedule();
   83ae0:	97ffffd1 	bl	83a24 <schedule>
}
   83ae4:	d503201f 	nop
   83ae8:	a8c17bfd 	ldp	x29, x30, [sp], #16
   83aec:	d65f03c0 	ret

0000000000083af0 <kill_zombie>:

void kill_zombie() {
   83af0:	a9be7bfd 	stp	x29, x30, [sp, #-32]!
   83af4:	910003fd 	mov	x29, sp
    lock();
   83af8:	97fff3c0 	bl	809f8 <lock>
    for (thread *cur = run_queue->next; cur != run_queue; cur = cur->next) {
   83afc:	b0000020 	adrp	x0, 88000 <cmd_list+0x980>
   83b00:	911fe000 	add	x0, x0, #0x7f8
   83b04:	f9400000 	ldr	x0, [x0]
   83b08:	f9400000 	ldr	x0, [x0]
   83b0c:	f9000fe0 	str	x0, [sp, #24]
   83b10:	1400001c 	b	83b80 <kill_zombie+0x90>
        if (cur->iszombie) {
   83b14:	f9400fe0 	ldr	x0, [sp, #24]
   83b18:	b9401c00 	ldr	w0, [x0, #28]
   83b1c:	7100001f 	cmp	w0, #0x0
   83b20:	540002a0 	b.eq	83b74 <kill_zombie+0x84>  // b.none
            // remove from list
            cur->next->prev = cur->prev;
   83b24:	f9400fe0 	ldr	x0, [sp, #24]
   83b28:	f9400000 	ldr	x0, [x0]
   83b2c:	f9400fe1 	ldr	x1, [sp, #24]
   83b30:	f9400421 	ldr	x1, [x1, #8]
   83b34:	f9000401 	str	x1, [x0, #8]
            cur->prev->next = cur->next;
   83b38:	f9400fe0 	ldr	x0, [sp, #24]
   83b3c:	f9400400 	ldr	x0, [x0, #8]
   83b40:	f9400fe1 	ldr	x1, [sp, #24]
   83b44:	f9400021 	ldr	x1, [x1]
   83b48:	f9000001 	str	x1, [x0]
            // release memory
            kfree(cur->kernel_stack_ptr);
   83b4c:	f9400fe0 	ldr	x0, [sp, #24]
   83b50:	f9401800 	ldr	x0, [x0, #48]
   83b54:	97fff86b 	bl	81d00 <kfree>
            kfree(cur->user_stack_ptr);
   83b58:	f9400fe0 	ldr	x0, [sp, #24]
   83b5c:	f9401400 	ldr	x0, [x0, #40]
   83b60:	97fff868 	bl	81d00 <kfree>
            // update thread status
            cur->isused = 0;
   83b64:	f9400fe0 	ldr	x0, [sp, #24]
   83b68:	b900241f 	str	wzr, [x0, #36]
            cur->iszombie = 0;
   83b6c:	f9400fe0 	ldr	x0, [sp, #24]
   83b70:	b9001c1f 	str	wzr, [x0, #28]
    for (thread *cur = run_queue->next; cur != run_queue; cur = cur->next) {
   83b74:	f9400fe0 	ldr	x0, [sp, #24]
   83b78:	f9400000 	ldr	x0, [x0]
   83b7c:	f9000fe0 	str	x0, [sp, #24]
   83b80:	b0000020 	adrp	x0, 88000 <cmd_list+0x980>
   83b84:	911fe000 	add	x0, x0, #0x7f8
   83b88:	f9400000 	ldr	x0, [x0]
   83b8c:	f9400fe1 	ldr	x1, [sp, #24]
   83b90:	eb00003f 	cmp	x1, x0
   83b94:	54fffc01 	b.ne	83b14 <kill_zombie+0x24>  // b.any
        }
    }
    unlock();
   83b98:	97fff39e 	bl	80a10 <unlock>
}
   83b9c:	d503201f 	nop
   83ba0:	a8c27bfd 	ldp	x29, x30, [sp], #32
   83ba4:	d65f03c0 	ret

0000000000083ba8 <thread_exec>:

// for video player
void thread_exec(char *code, char codesize) {
   83ba8:	a9bd7bfd 	stp	x29, x30, [sp, #-48]!
   83bac:	910003fd 	mov	x29, sp
   83bb0:	f9000fe0 	str	x0, [sp, #24]
   83bb4:	39005fe1 	strb	w1, [sp, #23]
    // TODO
    thread *t = thread_create(code);
   83bb8:	f9400fe0 	ldr	x0, [sp, #24]
   83bbc:	97ffff29 	bl	83860 <thread_create>
   83bc0:	f90017e0 	str	x0, [sp, #40]
    t->codesize = codesize;
   83bc4:	39405fe1 	ldrb	w1, [sp, #23]
   83bc8:	f94017e0 	ldr	x0, [sp, #40]
   83bcc:	b9001801 	str	w1, [x0, #24]
    t->code = kmalloc(codesize);
   83bd0:	39405fe0 	ldrb	w0, [sp, #23]
   83bd4:	97fff83b 	bl	81cc0 <kmalloc>
   83bd8:	aa0003e1 	mov	x1, x0
   83bdc:	f94017e0 	ldr	x0, [sp, #40]
   83be0:	f9000801 	str	x1, [x0, #16]
    memcpy(t->code, code, codesize);
   83be4:	f94017e0 	ldr	x0, [sp, #40]
   83be8:	f9400800 	ldr	x0, [x0, #16]
   83bec:	39405fe1 	ldrb	w1, [sp, #23]
   83bf0:	aa0103e2 	mov	x2, x1
   83bf4:	f9400fe1 	ldr	x1, [sp, #24]
   83bf8:	940003a8 	bl	84a98 <memcpy>
    t->context.lr = (unsigned long)t->code;
   83bfc:	f94017e0 	ldr	x0, [sp, #40]
   83c00:	f9400800 	ldr	x0, [x0, #16]
   83c04:	aa0003e1 	mov	x1, x0
   83c08:	f94017e0 	ldr	x0, [sp, #40]
   83c0c:	f9004801 	str	x1, [x0, #144]
    cur_thread = t;
   83c10:	d0002800 	adrp	x0, 585000 <_bss_size+0x4e5675>
   83c14:	91018000 	add	x0, x0, #0x60
   83c18:	f94017e1 	ldr	x1, [sp, #40]
   83c1c:	f9000001 	str	x1, [x0]
    add_timer(schedule_timer, "", getTimerFreq());
   83c20:	94000140 	bl	84120 <getTimerFreq>
   83c24:	aa0003e2 	mov	x2, x0
   83c28:	f0000000 	adrp	x0, 86000 <el1t_irq_invalid+0x78>
   83c2c:	91228001 	add	x1, x0, #0x8a0
   83c30:	90000000 	adrp	x0, 83000 <fork_test+0x10c>
   83c34:	91325000 	add	x0, x0, #0xc94
   83c38:	940000cb 	bl	83f64 <add_timer>
    uart_sendline("exec: timer set\n");
   83c3c:	f0000000 	adrp	x0, 86000 <el1t_irq_invalid+0x78>
   83c40:	9122a000 	add	x0, x0, #0x8a8
   83c44:	940004a9 	bl	84ee8 <uart_sendline>
    asm volatile("msr tpidr_el1, %0;" ::"r"(&t->context));                // hold the "kernel(el1)" thread structure info
   83c48:	f94017e0 	ldr	x0, [sp, #40]
   83c4c:	9100e000 	add	x0, x0, #0x38
   83c50:	d518d080 	msr	tpidr_el1, x0
    asm volatile("msr spsr_el1, %0;" ::"r"(0x0));                         // set state to user mode, and enable interrupt
   83c54:	52800000 	mov	w0, #0x0                   	// #0
   83c58:	d5184000 	msr	spsr_el1, x0
    asm volatile("msr elr_el1, %0;" ::"r"(t->context.lr));                // set exception return addr to 'c_filedata'
   83c5c:	f94017e0 	ldr	x0, [sp, #40]
   83c60:	f9404800 	ldr	x0, [x0, #144]
   83c64:	d5184020 	msr	elr_el1, x0
    asm volatile("msr sp_el0, %0;" ::"r"(t->context.sp));                 // set el0's sp to top of new stack
   83c68:	f94017e0 	ldr	x0, [sp, #40]
   83c6c:	f9404c00 	ldr	x0, [x0, #152]
   83c70:	d5184100 	msr	sp_el0, x0
    asm volatile("mov sp, %0;" ::"r"(t->kernel_stack_ptr + KSTACK_SIZE)); // syscall use kernel stack
   83c74:	f94017e0 	ldr	x0, [sp, #40]
   83c78:	f9401800 	ldr	x0, [x0, #48]
   83c7c:	91404000 	add	x0, x0, #0x10, lsl #12
   83c80:	9100001f 	mov	sp, x0
    asm volatile("eret;");                                                // switch EL to 0
   83c84:	d69f03e0 	eret
}
   83c88:	d503201f 	nop
   83c8c:	a8c37bfd 	ldp	x29, x30, [sp], #48
   83c90:	d65f03c0 	ret

0000000000083c94 <schedule_timer>:

void schedule_timer() {
   83c94:	a9bf7bfd 	stp	x29, x30, [sp, #-16]!
   83c98:	910003fd 	mov	x29, sp
    add_timer(schedule_timer, "re-schedule", getTimerFreq() >> 5);
   83c9c:	94000121 	bl	84120 <getTimerFreq>
   83ca0:	9345fc00 	asr	x0, x0, #5
   83ca4:	aa0003e2 	mov	x2, x0
   83ca8:	f0000000 	adrp	x0, 86000 <el1t_irq_invalid+0x78>
   83cac:	91230001 	add	x1, x0, #0x8c0
   83cb0:	90000000 	adrp	x0, 83000 <fork_test+0x10c>
   83cb4:	91325000 	add	x0, x0, #0xc94
   83cb8:	940000ab 	bl	83f64 <add_timer>
}
   83cbc:	d503201f 	nop
   83cc0:	a8c17bfd 	ldp	x29, x30, [sp], #16
   83cc4:	d65f03c0 	ret

0000000000083cc8 <foo>:

void foo() {
   83cc8:	a9be7bfd 	stp	x29, x30, [sp, #-32]!
   83ccc:	910003fd 	mov	x29, sp
    for (int i = 0; i < 10; ++i) {
   83cd0:	b9001fff 	str	wzr, [sp, #28]
   83cd4:	14000019 	b	83d38 <foo+0x70>
        uart_sendline("Thread id: %d %d\n", cur_thread->pid, i);
   83cd8:	d0002800 	adrp	x0, 585000 <_bss_size+0x4e5675>
   83cdc:	91018000 	add	x0, x0, #0x60
   83ce0:	f9400000 	ldr	x0, [x0]
   83ce4:	b9402000 	ldr	w0, [x0, #32]
   83ce8:	b9401fe2 	ldr	w2, [sp, #28]
   83cec:	2a0003e1 	mov	w1, w0
   83cf0:	f0000000 	adrp	x0, 86000 <el1t_irq_invalid+0x78>
   83cf4:	91234000 	add	x0, x0, #0x8d0
   83cf8:	9400047c 	bl	84ee8 <uart_sendline>
        for (int j = 0; j < 50000000; j++)
   83cfc:	b9001bff 	str	wzr, [sp, #24]
   83d00:	14000005 	b	83d14 <foo+0x4c>
            asm volatile("nop\n\t");
   83d04:	d503201f 	nop
        for (int j = 0; j < 50000000; j++)
   83d08:	b9401be0 	ldr	w0, [sp, #24]
   83d0c:	11000400 	add	w0, w0, #0x1
   83d10:	b9001be0 	str	w0, [sp, #24]
   83d14:	b9401be1 	ldr	w1, [sp, #24]
   83d18:	529e0fe0 	mov	w0, #0xf07f                	// #61567
   83d1c:	72a05f40 	movk	w0, #0x2fa, lsl #16
   83d20:	6b00003f 	cmp	w1, w0
   83d24:	54ffff0d 	b.le	83d04 <foo+0x3c>
        schedule();
   83d28:	97ffff3f 	bl	83a24 <schedule>
    for (int i = 0; i < 10; ++i) {
   83d2c:	b9401fe0 	ldr	w0, [sp, #28]
   83d30:	11000400 	add	w0, w0, #0x1
   83d34:	b9001fe0 	str	w0, [sp, #28]
   83d38:	b9401fe0 	ldr	w0, [sp, #28]
   83d3c:	7100241f 	cmp	w0, #0x9
   83d40:	54fffccd 	b.le	83cd8 <foo+0x10>
    }
    thread_exit();
   83d44:	97ffff5e 	bl	83abc <thread_exit>
   83d48:	d503201f 	nop
   83d4c:	a8c27bfd 	ldp	x29, x30, [sp], #32
   83d50:	d65f03c0 	ret
   83d54:	00000000 	udf	#0

0000000000083d58 <timer_list_init>:
#include "u_string.h"
#include "uart1.h"

timer_node *timer_head; // head is empty, every node come after head

void timer_list_init() {
   83d58:	a9bf7bfd 	stp	x29, x30, [sp, #-16]!
   83d5c:	910003fd 	mov	x29, sp
    timer_head = simple_malloc(sizeof(timer_node));
   83d60:	52800500 	mov	w0, #0x28                  	// #40
   83d64:	97fff4d2 	bl	810ac <simple_malloc>
   83d68:	aa0003e1 	mov	x1, x0
   83d6c:	d0002800 	adrp	x0, 585000 <_bss_size+0x4e5675>
   83d70:	9101c000 	add	x0, x0, #0x70
   83d74:	f9000001 	str	x1, [x0]
    timer_head->next = timer_head;
   83d78:	d0002800 	adrp	x0, 585000 <_bss_size+0x4e5675>
   83d7c:	9101c000 	add	x0, x0, #0x70
   83d80:	f9400000 	ldr	x0, [x0]
   83d84:	d0002801 	adrp	x1, 585000 <_bss_size+0x4e5675>
   83d88:	9101c021 	add	x1, x1, #0x70
   83d8c:	f9400021 	ldr	x1, [x1]
   83d90:	f9000001 	str	x1, [x0]
    timer_head->prev = timer_head;
   83d94:	d0002800 	adrp	x0, 585000 <_bss_size+0x4e5675>
   83d98:	9101c000 	add	x0, x0, #0x70
   83d9c:	f9400000 	ldr	x0, [x0]
   83da0:	d0002801 	adrp	x1, 585000 <_bss_size+0x4e5675>
   83da4:	9101c021 	add	x1, x1, #0x70
   83da8:	f9400021 	ldr	x1, [x1]
   83dac:	f9000401 	str	x1, [x0, #8]
}
   83db0:	d503201f 	nop
   83db4:	a8c17bfd 	ldp	x29, x30, [sp], #16
   83db8:	d65f03c0 	ret

0000000000083dbc <timer_list_insert_front>:

void timer_list_insert_front(timer_node *node, timer_node *it) {
   83dbc:	d10043ff 	sub	sp, sp, #0x10
   83dc0:	f90007e0 	str	x0, [sp, #8]
   83dc4:	f90003e1 	str	x1, [sp]
    node->prev = it->prev;
   83dc8:	f94003e0 	ldr	x0, [sp]
   83dcc:	f9400401 	ldr	x1, [x0, #8]
   83dd0:	f94007e0 	ldr	x0, [sp, #8]
   83dd4:	f9000401 	str	x1, [x0, #8]
    node->next = it;
   83dd8:	f94007e0 	ldr	x0, [sp, #8]
   83ddc:	f94003e1 	ldr	x1, [sp]
   83de0:	f9000001 	str	x1, [x0]
    it->prev->next = node;
   83de4:	f94003e0 	ldr	x0, [sp]
   83de8:	f9400400 	ldr	x0, [x0, #8]
   83dec:	f94007e1 	ldr	x1, [sp, #8]
   83df0:	f9000001 	str	x1, [x0]
    it->prev = node;
   83df4:	f94003e0 	ldr	x0, [sp]
   83df8:	f94007e1 	ldr	x1, [sp, #8]
   83dfc:	f9000401 	str	x1, [x0, #8]
}
   83e00:	d503201f 	nop
   83e04:	910043ff 	add	sp, sp, #0x10
   83e08:	d65f03c0 	ret

0000000000083e0c <timer_init_interrupt>:

void timer_init_interrupt() {
   83e0c:	d10043ff 	sub	sp, sp, #0x10
    asm volatile("mov x0, 1");
   83e10:	d2800020 	mov	x0, #0x1                   	// #1
    asm volatile("msr cntp_ctl_el0, x0");  // Enable
   83e14:	d51be220 	msr	cntp_ctl_el0, x0
    asm volatile("mrs x0, cntfrq_el0");    // get the timer frequency
   83e18:	d53be000 	mrs	x0, cntfrq_el0
    asm volatile("asr x0, x0, 5");         // lab5: shift 5 bits right(asr: Arithmetic Shift Right)
   83e1c:	9345fc00 	asr	x0, x0, #5
    asm volatile("msr cntp_tval_el0, x0"); // Set expired time
   83e20:	d51be200 	msr	cntp_tval_el0, x0
    asm volatile("mov x0, 2");             // w0 = lower half of x0
   83e24:	d2800040 	mov	x0, #0x2                   	// #2
    asm volatile("ldr x1, =0x40000040");   // CORE_TIMER_IRQ_CTRL
   83e28:	58001881 	ldr	x1, 84138 <getTimerFreq+0x18>
    asm volatile("str w0, [x1]");          // Unmask timer interrupt
   83e2c:	b9000020 	str	w0, [x1]
    unsigned long tmp;
    asm volatile("mrs %0, cntkctl_el1" : "=r"(tmp));
   83e30:	d538e100 	mrs	x0, cntkctl_el1
   83e34:	f90007e0 	str	x0, [sp, #8]
    tmp |= 1;
   83e38:	f94007e0 	ldr	x0, [sp, #8]
   83e3c:	b2400000 	orr	x0, x0, #0x1
   83e40:	f90007e0 	str	x0, [sp, #8]
    asm volatile("msr cntkctl_el1, %0" : : "r"(tmp));
   83e44:	f94007e0 	ldr	x0, [sp, #8]
   83e48:	d518e100 	msr	cntkctl_el1, x0
}
   83e4c:	d503201f 	nop
   83e50:	910043ff 	add	sp, sp, #0x10
   83e54:	d65f03c0 	ret

0000000000083e58 <timer_enable_interrupt>:

void timer_enable_interrupt() {
    asm volatile("mov x0, 1\n\t");
   83e58:	d2800020 	mov	x0, #0x1                   	// #1
    asm volatile("msr cntp_ctl_el0, x0\n\t");
   83e5c:	d51be220 	msr	cntp_ctl_el0, x0
}
   83e60:	d503201f 	nop
   83e64:	d65f03c0 	ret

0000000000083e68 <timer_disable_interrupt>:

void timer_disable_interrupt() {
    asm volatile("mov x0, 0\n\t");
   83e68:	d2800000 	mov	x0, #0x0                   	// #0
    asm volatile("msr cntp_ctl_el0, x0\n\t");
   83e6c:	d51be220 	msr	cntp_ctl_el0, x0
}
   83e70:	d503201f 	nop
   83e74:	d65f03c0 	ret

0000000000083e78 <timer_handler>:

void timer_handler() {
   83e78:	a9be7bfd 	stp	x29, x30, [sp, #-32]!
   83e7c:	910003fd 	mov	x29, sp
    timer_node *node = timer_head->next;
   83e80:	d0002800 	adrp	x0, 585000 <_bss_size+0x4e5675>
   83e84:	9101c000 	add	x0, x0, #0x70
   83e88:	f9400000 	ldr	x0, [x0]
   83e8c:	f9400000 	ldr	x0, [x0]
   83e90:	f9000fe0 	str	x0, [sp, #24]
    // list not empyt
    if (timer_head->next != timer_head) {
   83e94:	d0002800 	adrp	x0, 585000 <_bss_size+0x4e5675>
   83e98:	9101c000 	add	x0, x0, #0x70
   83e9c:	f9400000 	ldr	x0, [x0]
   83ea0:	f9400001 	ldr	x1, [x0]
   83ea4:	d0002800 	adrp	x0, 585000 <_bss_size+0x4e5675>
   83ea8:	9101c000 	add	x0, x0, #0x70
   83eac:	f9400000 	ldr	x0, [x0]
   83eb0:	eb00003f 	cmp	x1, x0
   83eb4:	540002c0 	b.eq	83f0c <timer_handler+0x94>  // b.none
        // ((ret_type (*)(arg_type)) fptr) (args);
        ((void (*)(char *))node->callback)(node->msg);
   83eb8:	f9400fe0 	ldr	x0, [sp, #24]
   83ebc:	f9400c00 	ldr	x0, [x0, #24]
   83ec0:	aa0003e1 	mov	x1, x0
   83ec4:	f9400fe0 	ldr	x0, [sp, #24]
   83ec8:	f9401000 	ldr	x0, [x0, #32]
   83ecc:	d63f0020 	blr	x1

        // remove current node
        // connect front and back, then free the space
        node->prev->next = node->next;
   83ed0:	f9400fe0 	ldr	x0, [sp, #24]
   83ed4:	f9400400 	ldr	x0, [x0, #8]
   83ed8:	f9400fe1 	ldr	x1, [sp, #24]
   83edc:	f9400021 	ldr	x1, [x1]
   83ee0:	f9000001 	str	x1, [x0]
        node->next->prev = node->prev;
   83ee4:	f9400fe0 	ldr	x0, [sp, #24]
   83ee8:	f9400000 	ldr	x0, [x0]
   83eec:	f9400fe1 	ldr	x1, [sp, #24]
   83ef0:	f9400421 	ldr	x1, [x1, #8]
   83ef4:	f9000401 	str	x1, [x0, #8]
        free(node->msg);
   83ef8:	f9400fe0 	ldr	x0, [sp, #24]
   83efc:	f9401000 	ldr	x0, [x0, #32]
   83f00:	97fff485 	bl	81114 <free>
        free(node);
   83f04:	f9400fe0 	ldr	x0, [sp, #24]
   83f08:	97fff483 	bl	81114 <free>
    }
    // if list is empty, postpond the timer
    if (timer_head->next != timer_head)
   83f0c:	d0002800 	adrp	x0, 585000 <_bss_size+0x4e5675>
   83f10:	9101c000 	add	x0, x0, #0x70
   83f14:	f9400000 	ldr	x0, [x0]
   83f18:	f9400001 	ldr	x1, [x0]
   83f1c:	d0002800 	adrp	x0, 585000 <_bss_size+0x4e5675>
   83f20:	9101c000 	add	x0, x0, #0x70
   83f24:	f9400000 	ldr	x0, [x0]
   83f28:	eb00003f 	cmp	x1, x0
   83f2c:	54000100 	b.eq	83f4c <timer_handler+0xd4>  // b.none
        set_timer_interrupt_by_tick(timer_head->next->interrupt_time);
   83f30:	d0002800 	adrp	x0, 585000 <_bss_size+0x4e5675>
   83f34:	9101c000 	add	x0, x0, #0x70
   83f38:	f9400000 	ldr	x0, [x0]
   83f3c:	f9400000 	ldr	x0, [x0]
   83f40:	f9400800 	ldr	x0, [x0, #16]
   83f44:	94000070 	bl	84104 <set_timer_interrupt_by_tick>
    else
        set_timer_interrupt(99999);
}
   83f48:	14000004 	b	83f58 <timer_handler+0xe0>
        set_timer_interrupt(99999);
   83f4c:	d290d3e0 	mov	x0, #0x869f                	// #34463
   83f50:	f2a00020 	movk	x0, #0x1, lsl #16
   83f54:	94000063 	bl	840e0 <set_timer_interrupt>
}
   83f58:	d503201f 	nop
   83f5c:	a8c27bfd 	ldp	x29, x30, [sp], #32
   83f60:	d65f03c0 	ret

0000000000083f64 <add_timer>:

// timeout: set next [timeout] cycles for times up
void add_timer(void *callback, char *msg, unsigned long long timeout) {
   83f64:	a9bb7bfd 	stp	x29, x30, [sp, #-80]!
   83f68:	910003fd 	mov	x29, sp
   83f6c:	f90017e0 	str	x0, [sp, #40]
   83f70:	f90013e1 	str	x1, [sp, #32]
   83f74:	f9000fe2 	str	x2, [sp, #24]
    // init node
    timer_node *node = simple_malloc(sizeof(timer_node));
   83f78:	52800500 	mov	w0, #0x28                  	// #40
   83f7c:	97fff44c 	bl	810ac <simple_malloc>
   83f80:	f90023e0 	str	x0, [sp, #64]
    node->next = timer_head;
   83f84:	d0002800 	adrp	x0, 585000 <_bss_size+0x4e5675>
   83f88:	9101c000 	add	x0, x0, #0x70
   83f8c:	f9400001 	ldr	x1, [x0]
   83f90:	f94023e0 	ldr	x0, [sp, #64]
   83f94:	f9000001 	str	x1, [x0]
    node->prev = timer_head;
   83f98:	d0002800 	adrp	x0, 585000 <_bss_size+0x4e5675>
   83f9c:	9101c000 	add	x0, x0, #0x70
   83fa0:	f9400001 	ldr	x1, [x0]
   83fa4:	f94023e0 	ldr	x0, [sp, #64]
   83fa8:	f9000401 	str	x1, [x0, #8]
    node->callback = callback;
   83fac:	f94023e0 	ldr	x0, [sp, #64]
   83fb0:	f94017e1 	ldr	x1, [sp, #40]
   83fb4:	f9000c01 	str	x1, [x0, #24]
    unsigned long long tick;
    asm volatile("mrs %0, cntpct_el0" : "=r"(tick));
   83fb8:	d53be020 	mrs	x0, cntpct_el0
   83fbc:	f9001fe0 	str	x0, [sp, #56]
    node->interrupt_time = timeout + tick;
   83fc0:	f9400fe1 	ldr	x1, [sp, #24]
   83fc4:	f9401fe0 	ldr	x0, [sp, #56]
   83fc8:	8b000021 	add	x1, x1, x0
   83fcc:	f94023e0 	ldr	x0, [sp, #64]
   83fd0:	f9000801 	str	x1, [x0, #16]
    node->msg = simple_malloc(strlen(msg) + 1); // need to free when times up(in timer_handler)
   83fd4:	f94013e0 	ldr	x0, [sp, #32]
   83fd8:	940001f5 	bl	847ac <strlen>
   83fdc:	11000400 	add	w0, w0, #0x1
   83fe0:	97fff433 	bl	810ac <simple_malloc>
   83fe4:	aa0003e1 	mov	x1, x0
   83fe8:	f94023e0 	ldr	x0, [sp, #64]
   83fec:	f9001001 	str	x1, [x0, #32]
    strcpy(node->msg, msg);
   83ff0:	f94023e0 	ldr	x0, [sp, #64]
   83ff4:	f9401000 	ldr	x0, [x0, #32]
   83ff8:	f94013e1 	ldr	x1, [sp, #32]
   83ffc:	940002c0 	bl	84afc <strcpy>

    // insert node into list
    timer_node *it = timer_head->next;
   84000:	b0002800 	adrp	x0, 585000 <_bss_size+0x4e5675>
   84004:	9101c000 	add	x0, x0, #0x70
   84008:	f9400000 	ldr	x0, [x0]
   8400c:	f9400000 	ldr	x0, [x0]
   84010:	f90027e0 	str	x0, [sp, #72]
    for (; it != timer_head; it = it->next) {
   84014:	1400000e 	b	8404c <add_timer+0xe8>
        if (node->interrupt_time < it->interrupt_time) {
   84018:	f94023e0 	ldr	x0, [sp, #64]
   8401c:	f9400801 	ldr	x1, [x0, #16]
   84020:	f94027e0 	ldr	x0, [sp, #72]
   84024:	f9400800 	ldr	x0, [x0, #16]
   84028:	eb00003f 	cmp	x1, x0
   8402c:	540000a2 	b.cs	84040 <add_timer+0xdc>  // b.hs, b.nlast
            timer_list_insert_front(node, it);
   84030:	f94027e1 	ldr	x1, [sp, #72]
   84034:	f94023e0 	ldr	x0, [sp, #64]
   84038:	97ffff61 	bl	83dbc <timer_list_insert_front>
            break;
   8403c:	1400000a 	b	84064 <add_timer+0x100>
    for (; it != timer_head; it = it->next) {
   84040:	f94027e0 	ldr	x0, [sp, #72]
   84044:	f9400000 	ldr	x0, [x0]
   84048:	f90027e0 	str	x0, [sp, #72]
   8404c:	b0002800 	adrp	x0, 585000 <_bss_size+0x4e5675>
   84050:	9101c000 	add	x0, x0, #0x70
   84054:	f9400000 	ldr	x0, [x0]
   84058:	f94027e1 	ldr	x1, [sp, #72]
   8405c:	eb00003f 	cmp	x1, x0
   84060:	54fffdc1 	b.ne	84018 <add_timer+0xb4>  // b.any
        }
    }
    // if node time is longest, put it in last pos
    if (it == timer_head)
   84064:	b0002800 	adrp	x0, 585000 <_bss_size+0x4e5675>
   84068:	9101c000 	add	x0, x0, #0x70
   8406c:	f9400000 	ldr	x0, [x0]
   84070:	f94027e1 	ldr	x1, [sp, #72]
   84074:	eb00003f 	cmp	x1, x0
   84078:	540000e1 	b.ne	84094 <add_timer+0x130>  // b.any
        timer_list_insert_front(node, timer_head);
   8407c:	b0002800 	adrp	x0, 585000 <_bss_size+0x4e5675>
   84080:	9101c000 	add	x0, x0, #0x70
   84084:	f9400000 	ldr	x0, [x0]
   84088:	aa0003e1 	mov	x1, x0
   8408c:	f94023e0 	ldr	x0, [sp, #64]
   84090:	97ffff4b 	bl	83dbc <timer_list_insert_front>

    // set tick
    set_timer_interrupt_by_tick(timer_head->next->interrupt_time);
   84094:	b0002800 	adrp	x0, 585000 <_bss_size+0x4e5675>
   84098:	9101c000 	add	x0, x0, #0x70
   8409c:	f9400000 	ldr	x0, [x0]
   840a0:	f9400000 	ldr	x0, [x0]
   840a4:	f9400800 	ldr	x0, [x0, #16]
   840a8:	94000017 	bl	84104 <set_timer_interrupt_by_tick>
}
   840ac:	d503201f 	nop
   840b0:	a8c57bfd 	ldp	x29, x30, [sp], #80
   840b4:	d65f03c0 	ret

00000000000840b8 <timer_print_msg>:

void timer_print_msg(char *msg) {
   840b8:	a9be7bfd 	stp	x29, x30, [sp, #-32]!
   840bc:	910003fd 	mov	x29, sp
   840c0:	f9000fe0 	str	x0, [sp, #24]
    uart_sendline("%s\n", msg);
   840c4:	f9400fe1 	ldr	x1, [sp, #24]
   840c8:	d0000000 	adrp	x0, 86000 <el1t_irq_invalid+0x78>
   840cc:	9123a000 	add	x0, x0, #0x8e8
   840d0:	94000386 	bl	84ee8 <uart_sendline>
}
   840d4:	d503201f 	nop
   840d8:	a8c27bfd 	ldp	x29, x30, [sp], #32
   840dc:	d65f03c0 	ret

00000000000840e0 <set_timer_interrupt>:

// set timer [expire_time] from now (abs)
void set_timer_interrupt(unsigned long long expire_time) {
   840e0:	d10043ff 	sub	sp, sp, #0x10
   840e4:	f90007e0 	str	x0, [sp, #8]
    asm volatile("mrs x1, cntfrq_el0\n\t");
   840e8:	d53be001 	mrs	x1, cntfrq_el0
    asm volatile("mul x1, x1, %0\n\t" ::"r"(expire_time));
   840ec:	f94007e0 	ldr	x0, [sp, #8]
   840f0:	9b007c21 	mul	x1, x1, x0
    asm volatile("msr cntp_cval_el0, x1\n\t");
   840f4:	d51be241 	msr	cntp_cval_el0, x1
}
   840f8:	d503201f 	nop
   840fc:	910043ff 	add	sp, sp, #0x10
   84100:	d65f03c0 	ret

0000000000084104 <set_timer_interrupt_by_tick>:

void set_timer_interrupt_by_tick(unsigned long long time) {
   84104:	d10043ff 	sub	sp, sp, #0x10
   84108:	f90007e0 	str	x0, [sp, #8]
    asm volatile("msr cntp_cval_el0, %0" ::"r"(time));
   8410c:	f94007e0 	ldr	x0, [sp, #8]
   84110:	d51be240 	msr	cntp_cval_el0, x0
}
   84114:	d503201f 	nop
   84118:	910043ff 	add	sp, sp, #0x10
   8411c:	d65f03c0 	ret

0000000000084120 <getTimerFreq>:

long long int getTimerFreq() {
   84120:	d10043ff 	sub	sp, sp, #0x10
    long long int tick;
    asm volatile("mrs %0, cntfrq_el0" : "=r"(tick));
   84124:	d53be000 	mrs	x0, cntfrq_el0
   84128:	f90007e0 	str	x0, [sp, #8]
    return tick;
   8412c:	f94007e0 	ldr	x0, [sp, #8]
   84130:	910043ff 	add	sp, sp, #0x10
   84134:	d65f03c0 	ret
   84138:	40000040 	.word	0x40000040
   8413c:	00000000 	.word	0x00000000

0000000000084140 <vsprintf>:
#include "u_string.h"
#include <stddef.h>

// this function writes formatted string into reg, and returns its size
unsigned int vsprintf(char *dst, char *fmt, __builtin_va_list args) {
   84140:	f81a0ff3 	str	x19, [sp, #-96]!
   84144:	f9000fe0 	str	x0, [sp, #24]
   84148:	f9000be1 	str	x1, [sp, #16]
   8414c:	aa0203f3 	mov	x19, x2
    // dst: input args buffer
    // fmt: input formatted string
    long int arg;
    int len, sign, i;
    char *p, *orig = dst, tmpstr[19];
   84150:	f9400fe0 	ldr	x0, [sp, #24]
   84154:	f9001fe0 	str	x0, [sp, #56]

    // failsafes
    if (dst == (void *)0 || fmt == (void *)0) {
   84158:	f9400fe0 	ldr	x0, [sp, #24]
   8415c:	f100001f 	cmp	x0, #0x0
   84160:	54000080 	b.eq	84170 <vsprintf+0x30>  // b.none
   84164:	f9400be0 	ldr	x0, [sp, #16]
   84168:	f100001f 	cmp	x0, #0x0
   8416c:	54000061 	b.ne	84178 <vsprintf+0x38>  // b.any
        return 0;
   84170:	52800000 	mov	w0, #0x0                   	// #0
   84174:	1400016a 	b	8471c <vsprintf+0x5dc>
    }

    // main loop
    arg = 0;
   84178:	f9002fff 	str	xzr, [sp, #88]
    while (*fmt) {
   8417c:	1400015f 	b	846f8 <vsprintf+0x5b8>
        if (dst - orig > VSPRINT_MAX_BUF_SIZE - 0x10) {
   84180:	f9400fe1 	ldr	x1, [sp, #24]
   84184:	f9401fe0 	ldr	x0, [sp, #56]
   84188:	cb000020 	sub	x0, x1, x0
   8418c:	f103c01f 	cmp	x0, #0xf0
   84190:	5400006d 	b.le	8419c <vsprintf+0x5c>
            return -1;
   84194:	12800000 	mov	w0, #0xffffffff            	// #-1
   84198:	14000161 	b	8471c <vsprintf+0x5dc>
        }

        // argument access
        if (*fmt == '%') {
   8419c:	f9400be0 	ldr	x0, [sp, #16]
   841a0:	39400000 	ldrb	w0, [x0]
   841a4:	7100941f 	cmp	w0, #0x25
   841a8:	54002901 	b.ne	846c8 <vsprintf+0x588>  // b.any
            fmt++;
   841ac:	f9400be0 	ldr	x0, [sp, #16]
   841b0:	91000400 	add	x0, x0, #0x1
   841b4:	f9000be0 	str	x0, [sp, #16]
            // case '%%'
            if (*fmt == '%') {
   841b8:	f9400be0 	ldr	x0, [sp, #16]
   841bc:	39400000 	ldrb	w0, [x0]
   841c0:	7100941f 	cmp	w0, #0x25
   841c4:	54002860 	b.eq	846d0 <vsprintf+0x590>  // b.none
                goto put;
            }

            len = 0; // size modifier (precision)
   841c8:	b90057ff 	str	wzr, [sp, #84]
            while (*fmt >= '0' && *fmt <= '9') {
   841cc:	14000010 	b	8420c <vsprintf+0xcc>
                len *= 10;
   841d0:	b94057e1 	ldr	w1, [sp, #84]
   841d4:	2a0103e0 	mov	w0, w1
   841d8:	531e7400 	lsl	w0, w0, #2
   841dc:	0b010000 	add	w0, w0, w1
   841e0:	531f7800 	lsl	w0, w0, #1
   841e4:	b90057e0 	str	w0, [sp, #84]
                len += *fmt - '0';
   841e8:	f9400be0 	ldr	x0, [sp, #16]
   841ec:	39400000 	ldrb	w0, [x0]
   841f0:	5100c000 	sub	w0, w0, #0x30
   841f4:	b94057e1 	ldr	w1, [sp, #84]
   841f8:	0b000020 	add	w0, w1, w0
   841fc:	b90057e0 	str	w0, [sp, #84]
                fmt++;
   84200:	f9400be0 	ldr	x0, [sp, #16]
   84204:	91000400 	add	x0, x0, #0x1
   84208:	f9000be0 	str	x0, [sp, #16]
            while (*fmt >= '0' && *fmt <= '9') {
   8420c:	f9400be0 	ldr	x0, [sp, #16]
   84210:	39400000 	ldrb	w0, [x0]
   84214:	7100bc1f 	cmp	w0, #0x2f
   84218:	540000a9 	b.ls	8422c <vsprintf+0xec>  // b.plast
   8421c:	f9400be0 	ldr	x0, [sp, #16]
   84220:	39400000 	ldrb	w0, [x0]
   84224:	7100e41f 	cmp	w0, #0x39
   84228:	54fffd49 	b.ls	841d0 <vsprintf+0x90>  // b.plast
            }

            if (*fmt == 'l') { // long
   8422c:	f9400be0 	ldr	x0, [sp, #16]
   84230:	39400000 	ldrb	w0, [x0]
   84234:	7101b01f 	cmp	w0, #0x6c
   84238:	54000081 	b.ne	84248 <vsprintf+0x108>  // b.any
                fmt++;
   8423c:	f9400be0 	ldr	x0, [sp, #16]
   84240:	91000400 	add	x0, x0, #0x1
   84244:	f9000be0 	str	x0, [sp, #16]
            }

            if (*fmt == 'c') { // char
   84248:	f9400be0 	ldr	x0, [sp, #16]
   8424c:	39400000 	ldrb	w0, [x0]
   84250:	71018c1f 	cmp	w0, #0x63
   84254:	54000441 	b.ne	842dc <vsprintf+0x19c>  // b.any
                arg = __builtin_va_arg(args, int);
   84258:	b9401a61 	ldr	w1, [x19, #24]
   8425c:	f9400260 	ldr	x0, [x19]
   84260:	7100003f 	cmp	w1, #0x0
   84264:	540000ab 	b.lt	84278 <vsprintf+0x138>  // b.tstop
   84268:	91002c01 	add	x1, x0, #0xb
   8426c:	927df021 	and	x1, x1, #0xfffffffffffffff8
   84270:	f9000261 	str	x1, [x19]
   84274:	1400000d 	b	842a8 <vsprintf+0x168>
   84278:	11002022 	add	w2, w1, #0x8
   8427c:	b9001a62 	str	w2, [x19, #24]
   84280:	b9401a62 	ldr	w2, [x19, #24]
   84284:	7100005f 	cmp	w2, #0x0
   84288:	540000ad 	b.le	8429c <vsprintf+0x15c>
   8428c:	91002c01 	add	x1, x0, #0xb
   84290:	927df021 	and	x1, x1, #0xfffffffffffffff8
   84294:	f9000261 	str	x1, [x19]
   84298:	14000004 	b	842a8 <vsprintf+0x168>
   8429c:	f9400662 	ldr	x2, [x19, #8]
   842a0:	93407c20 	sxtw	x0, w1
   842a4:	8b000040 	add	x0, x2, x0
   842a8:	b9400000 	ldr	w0, [x0]
   842ac:	93407c00 	sxtw	x0, w0
   842b0:	f9002fe0 	str	x0, [sp, #88]
                *dst++ = (char)arg;
   842b4:	f9400fe0 	ldr	x0, [sp, #24]
   842b8:	91000401 	add	x1, x0, #0x1
   842bc:	f9000fe1 	str	x1, [sp, #24]
   842c0:	f9402fe1 	ldr	x1, [sp, #88]
   842c4:	12001c21 	and	w1, w1, #0xff
   842c8:	39000001 	strb	w1, [x0]
                fmt++;
   842cc:	f9400be0 	ldr	x0, [sp, #16]
   842d0:	91000400 	add	x0, x0, #0x1
   842d4:	f9000be0 	str	x0, [sp, #16]
                continue;
   842d8:	14000108 	b	846f8 <vsprintf+0x5b8>
            }

            else if (*fmt == 'd') { // decimal
   842dc:	f9400be0 	ldr	x0, [sp, #16]
   842e0:	39400000 	ldrb	w0, [x0]
   842e4:	7101901f 	cmp	w0, #0x64
   842e8:	54000ec1 	b.ne	844c0 <vsprintf+0x380>  // b.any
                arg = __builtin_va_arg(args, int);
   842ec:	b9401a61 	ldr	w1, [x19, #24]
   842f0:	f9400260 	ldr	x0, [x19]
   842f4:	7100003f 	cmp	w1, #0x0
   842f8:	540000ab 	b.lt	8430c <vsprintf+0x1cc>  // b.tstop
   842fc:	91002c01 	add	x1, x0, #0xb
   84300:	927df021 	and	x1, x1, #0xfffffffffffffff8
   84304:	f9000261 	str	x1, [x19]
   84308:	1400000d 	b	8433c <vsprintf+0x1fc>
   8430c:	11002022 	add	w2, w1, #0x8
   84310:	b9001a62 	str	w2, [x19, #24]
   84314:	b9401a62 	ldr	w2, [x19, #24]
   84318:	7100005f 	cmp	w2, #0x0
   8431c:	540000ad 	b.le	84330 <vsprintf+0x1f0>
   84320:	91002c01 	add	x1, x0, #0xb
   84324:	927df021 	and	x1, x1, #0xfffffffffffffff8
   84328:	f9000261 	str	x1, [x19]
   8432c:	14000004 	b	8433c <vsprintf+0x1fc>
   84330:	f9400662 	ldr	x2, [x19, #8]
   84334:	93407c20 	sxtw	x0, w1
   84338:	8b000040 	add	x0, x2, x0
   8433c:	b9400000 	ldr	w0, [x0]
   84340:	93407c00 	sxtw	x0, w0
   84344:	f9002fe0 	str	x0, [sp, #88]
                sign = 0;
   84348:	b90053ff 	str	wzr, [sp, #80]
                if ((int)arg < 0) {
   8434c:	f9402fe0 	ldr	x0, [sp, #88]
   84350:	7100001f 	cmp	w0, #0x0
   84354:	540000ca 	b.ge	8436c <vsprintf+0x22c>  // b.tcont
                    arg *= -1;
   84358:	f9402fe0 	ldr	x0, [sp, #88]
   8435c:	cb0003e0 	neg	x0, x0
   84360:	f9002fe0 	str	x0, [sp, #88]
                    sign = 1; // #
   84364:	52800020 	mov	w0, #0x1                   	// #1
   84368:	b90053e0 	str	w0, [sp, #80]
                }
                if (arg > 99999999999999999L) {
   8436c:	f9402fe1 	ldr	x1, [sp, #88]
   84370:	92b44ec0 	mov	x0, #0xffffffff5d89ffff    	// #-2725642241
   84374:	f2c8af00 	movk	x0, #0x4578, lsl #32
   84378:	f2e02c60 	movk	x0, #0x163, lsl #48
   8437c:	eb00003f 	cmp	x1, x0
   84380:	540000ad 	b.le	84394 <vsprintf+0x254>
                    arg = 99999999999999999L;
   84384:	92b44ec0 	mov	x0, #0xffffffff5d89ffff    	// #-2725642241
   84388:	f2c8af00 	movk	x0, #0x4578, lsl #32
   8438c:	f2e02c60 	movk	x0, #0x163, lsl #48
   84390:	f9002fe0 	str	x0, [sp, #88]
                }

                // convert to string
                i = 18;
   84394:	52800240 	mov	w0, #0x12                  	// #18
   84398:	b9004fe0 	str	w0, [sp, #76]
                tmpstr[i] = 0;
   8439c:	b9804fe0 	ldrsw	x0, [sp, #76]
   843a0:	910083e1 	add	x1, sp, #0x20
   843a4:	3820683f 	strb	wzr, [x1, x0]
                do {
                    tmpstr[--i] = '0' + (arg % 10);
   843a8:	f9402fe1 	ldr	x1, [sp, #88]
   843ac:	b203e7e0 	mov	x0, #0x6666666666666666    	// #7378697629483820646
   843b0:	f28ccce0 	movk	x0, #0x6667
   843b4:	9b407c20 	smulh	x0, x1, x0
   843b8:	9342fc02 	asr	x2, x0, #2
   843bc:	937ffc20 	asr	x0, x1, #63
   843c0:	cb000042 	sub	x2, x2, x0
   843c4:	aa0203e0 	mov	x0, x2
   843c8:	d37ef400 	lsl	x0, x0, #2
   843cc:	8b020000 	add	x0, x0, x2
   843d0:	d37ff800 	lsl	x0, x0, #1
   843d4:	cb000022 	sub	x2, x1, x0
   843d8:	12001c40 	and	w0, w2, #0xff
   843dc:	b9404fe1 	ldr	w1, [sp, #76]
   843e0:	51000421 	sub	w1, w1, #0x1
   843e4:	b9004fe1 	str	w1, [sp, #76]
   843e8:	1100c000 	add	w0, w0, #0x30
   843ec:	12001c02 	and	w2, w0, #0xff
   843f0:	b9804fe0 	ldrsw	x0, [sp, #76]
   843f4:	910083e1 	add	x1, sp, #0x20
   843f8:	38206822 	strb	w2, [x1, x0]
                    arg /= 10;
   843fc:	f9402fe0 	ldr	x0, [sp, #88]
   84400:	b203e7e1 	mov	x1, #0x6666666666666666    	// #7378697629483820646
   84404:	f28ccce1 	movk	x1, #0x6667
   84408:	9b417c01 	smulh	x1, x0, x1
   8440c:	9342fc21 	asr	x1, x1, #2
   84410:	937ffc00 	asr	x0, x0, #63
   84414:	cb000020 	sub	x0, x1, x0
   84418:	f9002fe0 	str	x0, [sp, #88]
                } while (arg != 0 && i > 0);
   8441c:	f9402fe0 	ldr	x0, [sp, #88]
   84420:	f100001f 	cmp	x0, #0x0
   84424:	54000080 	b.eq	84434 <vsprintf+0x2f4>  // b.none
   84428:	b9404fe0 	ldr	w0, [sp, #76]
   8442c:	7100001f 	cmp	w0, #0x0
   84430:	54fffbcc 	b.gt	843a8 <vsprintf+0x268>
                if (sign) {
   84434:	b94053e0 	ldr	w0, [sp, #80]
   84438:	7100001f 	cmp	w0, #0x0
   8443c:	54000100 	b.eq	8445c <vsprintf+0x31c>  // b.none
                    tmpstr[--i] = '-';
   84440:	b9404fe0 	ldr	w0, [sp, #76]
   84444:	51000400 	sub	w0, w0, #0x1
   84448:	b9004fe0 	str	w0, [sp, #76]
   8444c:	b9804fe0 	ldrsw	x0, [sp, #76]
   84450:	910083e1 	add	x1, sp, #0x20
   84454:	528005a2 	mov	w2, #0x2d                  	// #45
   84458:	38206822 	strb	w2, [x1, x0]
                }
                if (len > 0 && len < 18) { // size modifier
   8445c:	b94057e0 	ldr	w0, [sp, #84]
   84460:	7100001f 	cmp	w0, #0x0
   84464:	5400024d 	b.le	844ac <vsprintf+0x36c>
   84468:	b94057e0 	ldr	w0, [sp, #84]
   8446c:	7100441f 	cmp	w0, #0x11
   84470:	540001ec 	b.gt	844ac <vsprintf+0x36c>
                    while (i > 18 - len) {
   84474:	14000008 	b	84494 <vsprintf+0x354>
                        tmpstr[--i] = ' ';
   84478:	b9404fe0 	ldr	w0, [sp, #76]
   8447c:	51000400 	sub	w0, w0, #0x1
   84480:	b9004fe0 	str	w0, [sp, #76]
   84484:	b9804fe0 	ldrsw	x0, [sp, #76]
   84488:	910083e1 	add	x1, sp, #0x20
   8448c:	52800402 	mov	w2, #0x20                  	// #32
   84490:	38206822 	strb	w2, [x1, x0]
                    while (i > 18 - len) {
   84494:	52800241 	mov	w1, #0x12                  	// #18
   84498:	b94057e0 	ldr	w0, [sp, #84]
   8449c:	4b000020 	sub	w0, w1, w0
   844a0:	b9404fe1 	ldr	w1, [sp, #76]
   844a4:	6b00003f 	cmp	w1, w0
   844a8:	54fffe8c 	b.gt	84478 <vsprintf+0x338>
                    }
                }

                p = &tmpstr[i]; // p = head of output string
   844ac:	910083e1 	add	x1, sp, #0x20
   844b0:	b9804fe0 	ldrsw	x0, [sp, #76]
   844b4:	8b000020 	add	x0, x1, x0
   844b8:	f90023e0 	str	x0, [sp, #64]
                goto copystring;
   844bc:	1400006f 	b	84678 <vsprintf+0x538>
            } else if (*fmt == 'x') {
   844c0:	f9400be0 	ldr	x0, [sp, #16]
   844c4:	39400000 	ldrb	w0, [x0]
   844c8:	7101e01f 	cmp	w0, #0x78
   844cc:	54000a21 	b.ne	84610 <vsprintf+0x4d0>  // b.any
                arg = __builtin_va_arg(args, long int);
   844d0:	b9401a61 	ldr	w1, [x19, #24]
   844d4:	f9400260 	ldr	x0, [x19]
   844d8:	7100003f 	cmp	w1, #0x0
   844dc:	540000ab 	b.lt	844f0 <vsprintf+0x3b0>  // b.tstop
   844e0:	91003c01 	add	x1, x0, #0xf
   844e4:	927df021 	and	x1, x1, #0xfffffffffffffff8
   844e8:	f9000261 	str	x1, [x19]
   844ec:	1400000d 	b	84520 <vsprintf+0x3e0>
   844f0:	11002022 	add	w2, w1, #0x8
   844f4:	b9001a62 	str	w2, [x19, #24]
   844f8:	b9401a62 	ldr	w2, [x19, #24]
   844fc:	7100005f 	cmp	w2, #0x0
   84500:	540000ad 	b.le	84514 <vsprintf+0x3d4>
   84504:	91003c01 	add	x1, x0, #0xf
   84508:	927df021 	and	x1, x1, #0xfffffffffffffff8
   8450c:	f9000261 	str	x1, [x19]
   84510:	14000004 	b	84520 <vsprintf+0x3e0>
   84514:	f9400662 	ldr	x2, [x19, #8]
   84518:	93407c20 	sxtw	x0, w1
   8451c:	8b000040 	add	x0, x2, x0
   84520:	f9400000 	ldr	x0, [x0]
   84524:	f9002fe0 	str	x0, [sp, #88]
                i = 16;
   84528:	52800200 	mov	w0, #0x10                  	// #16
   8452c:	b9004fe0 	str	w0, [sp, #76]
                tmpstr[i] = 0;
   84530:	b9804fe0 	ldrsw	x0, [sp, #76]
   84534:	910083e1 	add	x1, sp, #0x20
   84538:	3820683f 	strb	wzr, [x1, x0]
                do {
                    char n = arg & 0xf;
   8453c:	f9402fe0 	ldr	x0, [sp, #88]
   84540:	12001c00 	and	w0, w0, #0xff
   84544:	12000c00 	and	w0, w0, #0xf
   84548:	3900dfe0 	strb	w0, [sp, #55]
                    tmpstr[--i] = n + (n > 9 ? 0x37 : 0x30);
   8454c:	3940dfe0 	ldrb	w0, [sp, #55]
   84550:	7100241f 	cmp	w0, #0x9
   84554:	54000069 	b.ls	84560 <vsprintf+0x420>  // b.plast
   84558:	528006e0 	mov	w0, #0x37                  	// #55
   8455c:	14000002 	b	84564 <vsprintf+0x424>
   84560:	52800600 	mov	w0, #0x30                  	// #48
   84564:	b9404fe1 	ldr	w1, [sp, #76]
   84568:	51000421 	sub	w1, w1, #0x1
   8456c:	b9004fe1 	str	w1, [sp, #76]
   84570:	3940dfe1 	ldrb	w1, [sp, #55]
   84574:	0b010000 	add	w0, w0, w1
   84578:	12001c02 	and	w2, w0, #0xff
   8457c:	b9804fe0 	ldrsw	x0, [sp, #76]
   84580:	910083e1 	add	x1, sp, #0x20
   84584:	38206822 	strb	w2, [x1, x0]
                    arg >>= 4;
   84588:	f9402fe0 	ldr	x0, [sp, #88]
   8458c:	9344fc00 	asr	x0, x0, #4
   84590:	f9002fe0 	str	x0, [sp, #88]
                } while (arg != 0 && i > 0);
   84594:	f9402fe0 	ldr	x0, [sp, #88]
   84598:	f100001f 	cmp	x0, #0x0
   8459c:	54000080 	b.eq	845ac <vsprintf+0x46c>  // b.none
   845a0:	b9404fe0 	ldr	w0, [sp, #76]
   845a4:	7100001f 	cmp	w0, #0x0
   845a8:	54fffcac 	b.gt	8453c <vsprintf+0x3fc>
                if (len > 0 && len <= 16) { // size modifier
   845ac:	b94057e0 	ldr	w0, [sp, #84]
   845b0:	7100001f 	cmp	w0, #0x0
   845b4:	5400024d 	b.le	845fc <vsprintf+0x4bc>
   845b8:	b94057e0 	ldr	w0, [sp, #84]
   845bc:	7100401f 	cmp	w0, #0x10
   845c0:	540001ec 	b.gt	845fc <vsprintf+0x4bc>
                    while (i > 16 - len) {
   845c4:	14000008 	b	845e4 <vsprintf+0x4a4>
                        tmpstr[--i] = '0';
   845c8:	b9404fe0 	ldr	w0, [sp, #76]
   845cc:	51000400 	sub	w0, w0, #0x1
   845d0:	b9004fe0 	str	w0, [sp, #76]
   845d4:	b9804fe0 	ldrsw	x0, [sp, #76]
   845d8:	910083e1 	add	x1, sp, #0x20
   845dc:	52800602 	mov	w2, #0x30                  	// #48
   845e0:	38206822 	strb	w2, [x1, x0]
                    while (i > 16 - len) {
   845e4:	52800201 	mov	w1, #0x10                  	// #16
   845e8:	b94057e0 	ldr	w0, [sp, #84]
   845ec:	4b000020 	sub	w0, w1, w0
   845f0:	b9404fe1 	ldr	w1, [sp, #76]
   845f4:	6b00003f 	cmp	w1, w0
   845f8:	54fffe8c 	b.gt	845c8 <vsprintf+0x488>
                    }
                }
                p = &tmpstr[i];
   845fc:	910083e1 	add	x1, sp, #0x20
   84600:	b9804fe0 	ldrsw	x0, [sp, #76]
   84604:	8b000020 	add	x0, x1, x0
   84608:	f90023e0 	str	x0, [sp, #64]
                goto copystring;
   8460c:	1400001b 	b	84678 <vsprintf+0x538>
            } else if (*fmt == 's') {
   84610:	f9400be0 	ldr	x0, [sp, #16]
   84614:	39400000 	ldrb	w0, [x0]
   84618:	7101cc1f 	cmp	w0, #0x73
   8461c:	54000681 	b.ne	846ec <vsprintf+0x5ac>  // b.any
                p = __builtin_va_arg(args, char *);
   84620:	b9401a61 	ldr	w1, [x19, #24]
   84624:	f9400260 	ldr	x0, [x19]
   84628:	7100003f 	cmp	w1, #0x0
   8462c:	540000ab 	b.lt	84640 <vsprintf+0x500>  // b.tstop
   84630:	91003c01 	add	x1, x0, #0xf
   84634:	927df021 	and	x1, x1, #0xfffffffffffffff8
   84638:	f9000261 	str	x1, [x19]
   8463c:	1400000d 	b	84670 <vsprintf+0x530>
   84640:	11002022 	add	w2, w1, #0x8
   84644:	b9001a62 	str	w2, [x19, #24]
   84648:	b9401a62 	ldr	w2, [x19, #24]
   8464c:	7100005f 	cmp	w2, #0x0
   84650:	540000ad 	b.le	84664 <vsprintf+0x524>
   84654:	91003c01 	add	x1, x0, #0xf
   84658:	927df021 	and	x1, x1, #0xfffffffffffffff8
   8465c:	f9000261 	str	x1, [x19]
   84660:	14000004 	b	84670 <vsprintf+0x530>
   84664:	f9400662 	ldr	x2, [x19, #8]
   84668:	93407c20 	sxtw	x0, w1
   8466c:	8b000040 	add	x0, x2, x0
   84670:	f9400000 	ldr	x0, [x0]
   84674:	f90023e0 	str	x0, [sp, #64]
            copystring:
                if (p == (void *)0) {
   84678:	f94023e0 	ldr	x0, [sp, #64]
   8467c:	f100001f 	cmp	x0, #0x0
   84680:	540001a1 	b.ne	846b4 <vsprintf+0x574>  // b.any
                    p = "(null)";
   84684:	d0000000 	adrp	x0, 86000 <el1t_irq_invalid+0x78>
   84688:	9123c000 	add	x0, x0, #0x8f0
   8468c:	f90023e0 	str	x0, [sp, #64]
                }
                while (*p) {
   84690:	14000009 	b	846b4 <vsprintf+0x574>
                    *dst++ = *p++; // copy p's content into dst
   84694:	f94023e1 	ldr	x1, [sp, #64]
   84698:	91000420 	add	x0, x1, #0x1
   8469c:	f90023e0 	str	x0, [sp, #64]
   846a0:	f9400fe0 	ldr	x0, [sp, #24]
   846a4:	91000402 	add	x2, x0, #0x1
   846a8:	f9000fe2 	str	x2, [sp, #24]
   846ac:	39400021 	ldrb	w1, [x1]
   846b0:	39000001 	strb	w1, [x0]
                while (*p) {
   846b4:	f94023e0 	ldr	x0, [sp, #64]
   846b8:	39400000 	ldrb	w0, [x0]
   846bc:	7100001f 	cmp	w0, #0x0
   846c0:	54fffea1 	b.ne	84694 <vsprintf+0x554>  // b.any
   846c4:	1400000a 	b	846ec <vsprintf+0x5ac>
                }
            }
        } else {
        put:
   846c8:	d503201f 	nop
   846cc:	14000002 	b	846d4 <vsprintf+0x594>
                goto put;
   846d0:	d503201f 	nop
            *dst++ = *fmt;
   846d4:	f9400fe0 	ldr	x0, [sp, #24]
   846d8:	91000401 	add	x1, x0, #0x1
   846dc:	f9000fe1 	str	x1, [sp, #24]
   846e0:	f9400be1 	ldr	x1, [sp, #16]
   846e4:	39400021 	ldrb	w1, [x1]
   846e8:	39000001 	strb	w1, [x0]
        }
        fmt++;
   846ec:	f9400be0 	ldr	x0, [sp, #16]
   846f0:	91000400 	add	x0, x0, #0x1
   846f4:	f9000be0 	str	x0, [sp, #16]
    while (*fmt) {
   846f8:	f9400be0 	ldr	x0, [sp, #16]
   846fc:	39400000 	ldrb	w0, [x0]
   84700:	7100001f 	cmp	w0, #0x0
   84704:	54ffd3e1 	b.ne	84180 <vsprintf+0x40>  // b.any
    }
    *dst = 0; // add '0' at last pos to end string
   84708:	f9400fe0 	ldr	x0, [sp, #24]
   8470c:	3900001f 	strb	wzr, [x0]
    return dst - orig;
   84710:	f9400fe1 	ldr	x1, [sp, #24]
   84714:	f9401fe0 	ldr	x0, [sp, #56]
   84718:	cb000020 	sub	x0, x1, x0
}
   8471c:	f84607f3 	ldr	x19, [sp], #96
   84720:	d65f03c0 	ret

0000000000084724 <sprintf>:

unsigned int sprintf(char *dst, char *fmt, ...) {
   84724:	a9b67bfd 	stp	x29, x30, [sp, #-160]!
   84728:	910003fd 	mov	x29, sp
   8472c:	f9001fe0 	str	x0, [sp, #56]
   84730:	f9001be1 	str	x1, [sp, #48]
   84734:	f9003be2 	str	x2, [sp, #112]
   84738:	f9003fe3 	str	x3, [sp, #120]
   8473c:	f90043e4 	str	x4, [sp, #128]
   84740:	f90047e5 	str	x5, [sp, #136]
   84744:	f9004be6 	str	x6, [sp, #144]
   84748:	f9004fe7 	str	x7, [sp, #152]
    __builtin_va_list args;        // pack '...' variables
    __builtin_va_start(args, fmt); // store them from fmt
   8474c:	910283e0 	add	x0, sp, #0xa0
   84750:	f90027e0 	str	x0, [sp, #72]
   84754:	910283e0 	add	x0, sp, #0xa0
   84758:	f9002be0 	str	x0, [sp, #80]
   8475c:	9101c3e0 	add	x0, sp, #0x70
   84760:	f9002fe0 	str	x0, [sp, #88]
   84764:	128005e0 	mov	w0, #0xffffffd0            	// #-48
   84768:	b90063e0 	str	w0, [sp, #96]
   8476c:	b90067ff 	str	wzr, [sp, #100]
    unsigned int r = vsprintf(dst, fmt, args);
   84770:	910043e2 	add	x2, sp, #0x10
   84774:	910123e3 	add	x3, sp, #0x48
   84778:	a9400460 	ldp	x0, x1, [x3]
   8477c:	a9000440 	stp	x0, x1, [x2]
   84780:	a9410460 	ldp	x0, x1, [x3, #16]
   84784:	a9010440 	stp	x0, x1, [x2, #16]
   84788:	910043e0 	add	x0, sp, #0x10
   8478c:	aa0003e2 	mov	x2, x0
   84790:	f9401be1 	ldr	x1, [sp, #48]
   84794:	f9401fe0 	ldr	x0, [sp, #56]
   84798:	97fffe6a 	bl	84140 <vsprintf>
   8479c:	b9006fe0 	str	w0, [sp, #108]
    __builtin_va_end(args);
    return r;
   847a0:	b9406fe0 	ldr	w0, [sp, #108]
}
   847a4:	a8ca7bfd 	ldp	x29, x30, [sp], #160
   847a8:	d65f03c0 	ret

00000000000847ac <strlen>:

unsigned long long strlen(const char *str) {
   847ac:	d10083ff 	sub	sp, sp, #0x20
   847b0:	f90007e0 	str	x0, [sp, #8]
    size_t count = 0;
   847b4:	f9000fff 	str	xzr, [sp, #24]
    // stop when encounter '\0'
    while ((unsigned char)*str++) {
   847b8:	14000004 	b	847c8 <strlen+0x1c>
        count++;
   847bc:	f9400fe0 	ldr	x0, [sp, #24]
   847c0:	91000400 	add	x0, x0, #0x1
   847c4:	f9000fe0 	str	x0, [sp, #24]
    while ((unsigned char)*str++) {
   847c8:	f94007e0 	ldr	x0, [sp, #8]
   847cc:	91000401 	add	x1, x0, #0x1
   847d0:	f90007e1 	str	x1, [sp, #8]
   847d4:	39400000 	ldrb	w0, [x0]
   847d8:	7100001f 	cmp	w0, #0x0
   847dc:	54ffff01 	b.ne	847bc <strlen+0x10>  // b.any
    }
    return count;
   847e0:	f9400fe0 	ldr	x0, [sp, #24]
}
   847e4:	910083ff 	add	sp, sp, #0x20
   847e8:	d65f03c0 	ret

00000000000847ec <strcmp>:

int strcmp(const char *p1, const char *p2) {
   847ec:	d100c3ff 	sub	sp, sp, #0x30
   847f0:	f90007e0 	str	x0, [sp, #8]
   847f4:	f90003e1 	str	x1, [sp]
    const unsigned char *s1 = (const unsigned char *)p1;
   847f8:	f94007e0 	ldr	x0, [sp, #8]
   847fc:	f90017e0 	str	x0, [sp, #40]
    const unsigned char *s2 = (const unsigned char *)p2;
   84800:	f94003e0 	ldr	x0, [sp]
   84804:	f90013e0 	str	x0, [sp, #32]
    unsigned char c1, c2;

    do {
        c1 = (unsigned char)*s1++;
   84808:	f94017e0 	ldr	x0, [sp, #40]
   8480c:	91000401 	add	x1, x0, #0x1
   84810:	f90017e1 	str	x1, [sp, #40]
   84814:	39400000 	ldrb	w0, [x0]
   84818:	39007fe0 	strb	w0, [sp, #31]
        c2 = (unsigned char)*s2++;
   8481c:	f94013e0 	ldr	x0, [sp, #32]
   84820:	91000401 	add	x1, x0, #0x1
   84824:	f90013e1 	str	x1, [sp, #32]
   84828:	39400000 	ldrb	w0, [x0]
   8482c:	39007be0 	strb	w0, [sp, #30]
        if (c1 == '\0')
   84830:	39407fe0 	ldrb	w0, [sp, #31]
   84834:	7100001f 	cmp	w0, #0x0
   84838:	540000a1 	b.ne	8484c <strcmp+0x60>  // b.any
            return c1 - c2;
   8483c:	39407fe1 	ldrb	w1, [sp, #31]
   84840:	39407be0 	ldrb	w0, [sp, #30]
   84844:	4b000020 	sub	w0, w1, w0
   84848:	14000008 	b	84868 <strcmp+0x7c>
    } while (c1 == c2);
   8484c:	39407fe1 	ldrb	w1, [sp, #31]
   84850:	39407be0 	ldrb	w0, [sp, #30]
   84854:	6b00003f 	cmp	w1, w0
   84858:	54fffd80 	b.eq	84808 <strcmp+0x1c>  // b.none
    return c1 - c2;
   8485c:	39407fe1 	ldrb	w1, [sp, #31]
   84860:	39407be0 	ldrb	w0, [sp, #30]
   84864:	4b000020 	sub	w0, w1, w0
}
   84868:	9100c3ff 	add	sp, sp, #0x30
   8486c:	d65f03c0 	ret

0000000000084870 <strncmp>:

int strncmp(const char *s1, const char *s2, unsigned long long n) {
   84870:	d100c3ff 	sub	sp, sp, #0x30
   84874:	f9000fe0 	str	x0, [sp, #24]
   84878:	f9000be1 	str	x1, [sp, #16]
   8487c:	f90007e2 	str	x2, [sp, #8]
    unsigned char c1 = '\0';
   84880:	3900bfff 	strb	wzr, [sp, #47]
    unsigned char c2 = '\0';
   84884:	3900bbff 	strb	wzr, [sp, #46]
    if (n >= 4) {
   84888:	f94007e0 	ldr	x0, [sp, #8]
   8488c:	f1000c1f 	cmp	x0, #0x3
   84890:	54000f49 	b.ls	84a78 <strncmp+0x208>  // b.plast
        size_t n4 = n >> 2;
   84894:	f94007e0 	ldr	x0, [sp, #8]
   84898:	d342fc00 	lsr	x0, x0, #2
   8489c:	f90013e0 	str	x0, [sp, #32]
        do {
            // loop unroll
            c1 = (unsigned char)*s1++;
   848a0:	f9400fe0 	ldr	x0, [sp, #24]
   848a4:	91000401 	add	x1, x0, #0x1
   848a8:	f9000fe1 	str	x1, [sp, #24]
   848ac:	39400000 	ldrb	w0, [x0]
   848b0:	3900bfe0 	strb	w0, [sp, #47]
            c2 = (unsigned char)*s2++;
   848b4:	f9400be0 	ldr	x0, [sp, #16]
   848b8:	91000401 	add	x1, x0, #0x1
   848bc:	f9000be1 	str	x1, [sp, #16]
   848c0:	39400000 	ldrb	w0, [x0]
   848c4:	3900bbe0 	strb	w0, [sp, #46]
            if (c1 == '\0' || c1 != c2)
   848c8:	3940bfe0 	ldrb	w0, [sp, #47]
   848cc:	7100001f 	cmp	w0, #0x0
   848d0:	540000a0 	b.eq	848e4 <strncmp+0x74>  // b.none
   848d4:	3940bfe1 	ldrb	w1, [sp, #47]
   848d8:	3940bbe0 	ldrb	w0, [sp, #46]
   848dc:	6b00003f 	cmp	w1, w0
   848e0:	540000a0 	b.eq	848f4 <strncmp+0x84>  // b.none
                return c1 - c2;
   848e4:	3940bfe1 	ldrb	w1, [sp, #47]
   848e8:	3940bbe0 	ldrb	w0, [sp, #46]
   848ec:	4b000020 	sub	w0, w1, w0
   848f0:	14000068 	b	84a90 <strncmp+0x220>
            c1 = (unsigned char)*s1++;
   848f4:	f9400fe0 	ldr	x0, [sp, #24]
   848f8:	91000401 	add	x1, x0, #0x1
   848fc:	f9000fe1 	str	x1, [sp, #24]
   84900:	39400000 	ldrb	w0, [x0]
   84904:	3900bfe0 	strb	w0, [sp, #47]
            c2 = (unsigned char)*s2++;
   84908:	f9400be0 	ldr	x0, [sp, #16]
   8490c:	91000401 	add	x1, x0, #0x1
   84910:	f9000be1 	str	x1, [sp, #16]
   84914:	39400000 	ldrb	w0, [x0]
   84918:	3900bbe0 	strb	w0, [sp, #46]
            if (c1 == '\0' || c1 != c2)
   8491c:	3940bfe0 	ldrb	w0, [sp, #47]
   84920:	7100001f 	cmp	w0, #0x0
   84924:	540000a0 	b.eq	84938 <strncmp+0xc8>  // b.none
   84928:	3940bfe1 	ldrb	w1, [sp, #47]
   8492c:	3940bbe0 	ldrb	w0, [sp, #46]
   84930:	6b00003f 	cmp	w1, w0
   84934:	540000a0 	b.eq	84948 <strncmp+0xd8>  // b.none
                return c1 - c2;
   84938:	3940bfe1 	ldrb	w1, [sp, #47]
   8493c:	3940bbe0 	ldrb	w0, [sp, #46]
   84940:	4b000020 	sub	w0, w1, w0
   84944:	14000053 	b	84a90 <strncmp+0x220>
            c1 = (unsigned char)*s1++;
   84948:	f9400fe0 	ldr	x0, [sp, #24]
   8494c:	91000401 	add	x1, x0, #0x1
   84950:	f9000fe1 	str	x1, [sp, #24]
   84954:	39400000 	ldrb	w0, [x0]
   84958:	3900bfe0 	strb	w0, [sp, #47]
            c2 = (unsigned char)*s2++;
   8495c:	f9400be0 	ldr	x0, [sp, #16]
   84960:	91000401 	add	x1, x0, #0x1
   84964:	f9000be1 	str	x1, [sp, #16]
   84968:	39400000 	ldrb	w0, [x0]
   8496c:	3900bbe0 	strb	w0, [sp, #46]
            if (c1 == '\0' || c1 != c2)
   84970:	3940bfe0 	ldrb	w0, [sp, #47]
   84974:	7100001f 	cmp	w0, #0x0
   84978:	540000a0 	b.eq	8498c <strncmp+0x11c>  // b.none
   8497c:	3940bfe1 	ldrb	w1, [sp, #47]
   84980:	3940bbe0 	ldrb	w0, [sp, #46]
   84984:	6b00003f 	cmp	w1, w0
   84988:	540000a0 	b.eq	8499c <strncmp+0x12c>  // b.none
                return c1 - c2;
   8498c:	3940bfe1 	ldrb	w1, [sp, #47]
   84990:	3940bbe0 	ldrb	w0, [sp, #46]
   84994:	4b000020 	sub	w0, w1, w0
   84998:	1400003e 	b	84a90 <strncmp+0x220>
            c1 = (unsigned char)*s1++;
   8499c:	f9400fe0 	ldr	x0, [sp, #24]
   849a0:	91000401 	add	x1, x0, #0x1
   849a4:	f9000fe1 	str	x1, [sp, #24]
   849a8:	39400000 	ldrb	w0, [x0]
   849ac:	3900bfe0 	strb	w0, [sp, #47]
            c2 = (unsigned char)*s2++;
   849b0:	f9400be0 	ldr	x0, [sp, #16]
   849b4:	91000401 	add	x1, x0, #0x1
   849b8:	f9000be1 	str	x1, [sp, #16]
   849bc:	39400000 	ldrb	w0, [x0]
   849c0:	3900bbe0 	strb	w0, [sp, #46]
            if (c1 == '\0' || c1 != c2)
   849c4:	3940bfe0 	ldrb	w0, [sp, #47]
   849c8:	7100001f 	cmp	w0, #0x0
   849cc:	540000a0 	b.eq	849e0 <strncmp+0x170>  // b.none
   849d0:	3940bfe1 	ldrb	w1, [sp, #47]
   849d4:	3940bbe0 	ldrb	w0, [sp, #46]
   849d8:	6b00003f 	cmp	w1, w0
   849dc:	540000a0 	b.eq	849f0 <strncmp+0x180>  // b.none
                return c1 - c2;
   849e0:	3940bfe1 	ldrb	w1, [sp, #47]
   849e4:	3940bbe0 	ldrb	w0, [sp, #46]
   849e8:	4b000020 	sub	w0, w1, w0
   849ec:	14000029 	b	84a90 <strncmp+0x220>
        } while (--n4 > 0);
   849f0:	f94013e0 	ldr	x0, [sp, #32]
   849f4:	d1000400 	sub	x0, x0, #0x1
   849f8:	f90013e0 	str	x0, [sp, #32]
   849fc:	f94013e0 	ldr	x0, [sp, #32]
   84a00:	f100001f 	cmp	x0, #0x0
   84a04:	54fff4e1 	b.ne	848a0 <strncmp+0x30>  // b.any

        n &= 3;
   84a08:	f94007e0 	ldr	x0, [sp, #8]
   84a0c:	92400400 	and	x0, x0, #0x3
   84a10:	f90007e0 	str	x0, [sp, #8]
    }
    while (n > 0) {
   84a14:	14000019 	b	84a78 <strncmp+0x208>
        c1 = (unsigned char)*s1++;
   84a18:	f9400fe0 	ldr	x0, [sp, #24]
   84a1c:	91000401 	add	x1, x0, #0x1
   84a20:	f9000fe1 	str	x1, [sp, #24]
   84a24:	39400000 	ldrb	w0, [x0]
   84a28:	3900bfe0 	strb	w0, [sp, #47]
        c2 = (unsigned char)*s2++;
   84a2c:	f9400be0 	ldr	x0, [sp, #16]
   84a30:	91000401 	add	x1, x0, #0x1
   84a34:	f9000be1 	str	x1, [sp, #16]
   84a38:	39400000 	ldrb	w0, [x0]
   84a3c:	3900bbe0 	strb	w0, [sp, #46]
        if (c1 == '\0' || c1 != c2)
   84a40:	3940bfe0 	ldrb	w0, [sp, #47]
   84a44:	7100001f 	cmp	w0, #0x0
   84a48:	540000a0 	b.eq	84a5c <strncmp+0x1ec>  // b.none
   84a4c:	3940bfe1 	ldrb	w1, [sp, #47]
   84a50:	3940bbe0 	ldrb	w0, [sp, #46]
   84a54:	6b00003f 	cmp	w1, w0
   84a58:	540000a0 	b.eq	84a6c <strncmp+0x1fc>  // b.none
            return c1 - c2;
   84a5c:	3940bfe1 	ldrb	w1, [sp, #47]
   84a60:	3940bbe0 	ldrb	w0, [sp, #46]
   84a64:	4b000020 	sub	w0, w1, w0
   84a68:	1400000a 	b	84a90 <strncmp+0x220>
        n--;
   84a6c:	f94007e0 	ldr	x0, [sp, #8]
   84a70:	d1000400 	sub	x0, x0, #0x1
   84a74:	f90007e0 	str	x0, [sp, #8]
    while (n > 0) {
   84a78:	f94007e0 	ldr	x0, [sp, #8]
   84a7c:	f100001f 	cmp	x0, #0x0
   84a80:	54fffcc1 	b.ne	84a18 <strncmp+0x1a8>  // b.any
    }
    return c1 - c2;
   84a84:	3940bfe1 	ldrb	w1, [sp, #47]
   84a88:	3940bbe0 	ldrb	w0, [sp, #46]
   84a8c:	4b000020 	sub	w0, w1, w0
}
   84a90:	9100c3ff 	add	sp, sp, #0x30
   84a94:	d65f03c0 	ret

0000000000084a98 <memcpy>:

char *memcpy(void *dest, const void *src, unsigned long long len) {
   84a98:	d100c3ff 	sub	sp, sp, #0x30
   84a9c:	f9000fe0 	str	x0, [sp, #24]
   84aa0:	f9000be1 	str	x1, [sp, #16]
   84aa4:	f90007e2 	str	x2, [sp, #8]
    char *d = dest;
   84aa8:	f9400fe0 	ldr	x0, [sp, #24]
   84aac:	f90017e0 	str	x0, [sp, #40]
    const char *s = src;
   84ab0:	f9400be0 	ldr	x0, [sp, #16]
   84ab4:	f90013e0 	str	x0, [sp, #32]
    while (len--) {
   84ab8:	14000009 	b	84adc <memcpy+0x44>
        *d++ = *s++;
   84abc:	f94013e1 	ldr	x1, [sp, #32]
   84ac0:	91000420 	add	x0, x1, #0x1
   84ac4:	f90013e0 	str	x0, [sp, #32]
   84ac8:	f94017e0 	ldr	x0, [sp, #40]
   84acc:	91000402 	add	x2, x0, #0x1
   84ad0:	f90017e2 	str	x2, [sp, #40]
   84ad4:	39400021 	ldrb	w1, [x1]
   84ad8:	39000001 	strb	w1, [x0]
    while (len--) {
   84adc:	f94007e0 	ldr	x0, [sp, #8]
   84ae0:	d1000401 	sub	x1, x0, #0x1
   84ae4:	f90007e1 	str	x1, [sp, #8]
   84ae8:	f100001f 	cmp	x0, #0x0
   84aec:	54fffe81 	b.ne	84abc <memcpy+0x24>  // b.any
    }
    return dest;
   84af0:	f9400fe0 	ldr	x0, [sp, #24]
}
   84af4:	9100c3ff 	add	sp, sp, #0x30
   84af8:	d65f03c0 	ret

0000000000084afc <strcpy>:

char *strcpy(char *dest, const char *src) {
   84afc:	a9be7bfd 	stp	x29, x30, [sp, #-32]!
   84b00:	910003fd 	mov	x29, sp
   84b04:	f9000fe0 	str	x0, [sp, #24]
   84b08:	f9000be1 	str	x1, [sp, #16]
    return memcpy(dest, src, strlen(src) + 1);
   84b0c:	f9400be0 	ldr	x0, [sp, #16]
   84b10:	97ffff27 	bl	847ac <strlen>
   84b14:	91000400 	add	x0, x0, #0x1
   84b18:	aa0003e2 	mov	x2, x0
   84b1c:	f9400be1 	ldr	x1, [sp, #16]
   84b20:	f9400fe0 	ldr	x0, [sp, #24]
   84b24:	97ffffdd 	bl	84a98 <memcpy>
}
   84b28:	a8c27bfd 	ldp	x29, x30, [sp], #32
   84b2c:	d65f03c0 	ret

0000000000084b30 <str_SepbySpace>:

char *str_SepbySpace(char *head) {
   84b30:	d10083ff 	sub	sp, sp, #0x20
   84b34:	f90007e0 	str	x0, [sp, #8]
    char *end;
    while (1) {
        if (*head == '\0') {
   84b38:	f94007e0 	ldr	x0, [sp, #8]
   84b3c:	39400000 	ldrb	w0, [x0]
   84b40:	7100001f 	cmp	w0, #0x0
   84b44:	54000081 	b.ne	84b54 <str_SepbySpace+0x24>  // b.any
            end = head;
   84b48:	f94007e0 	ldr	x0, [sp, #8]
   84b4c:	f9000fe0 	str	x0, [sp, #24]
            break;
   84b50:	1400000f 	b	84b8c <str_SepbySpace+0x5c>
        }
        if (*head == ' ') {
   84b54:	f94007e0 	ldr	x0, [sp, #8]
   84b58:	39400000 	ldrb	w0, [x0]
   84b5c:	7100801f 	cmp	w0, #0x20
   84b60:	540000e1 	b.ne	84b7c <str_SepbySpace+0x4c>  // b.any
            *head = '\0';
   84b64:	f94007e0 	ldr	x0, [sp, #8]
   84b68:	3900001f 	strb	wzr, [x0]
            end = head + 1;
   84b6c:	f94007e0 	ldr	x0, [sp, #8]
   84b70:	91000400 	add	x0, x0, #0x1
   84b74:	f9000fe0 	str	x0, [sp, #24]
            break;
   84b78:	14000005 	b	84b8c <str_SepbySpace+0x5c>
        }
        head++;
   84b7c:	f94007e0 	ldr	x0, [sp, #8]
   84b80:	91000400 	add	x0, x0, #0x1
   84b84:	f90007e0 	str	x0, [sp, #8]
        if (*head == '\0') {
   84b88:	17ffffec 	b	84b38 <str_SepbySpace+0x8>
    }
    return end;
   84b8c:	f9400fe0 	ldr	x0, [sp, #24]
}
   84b90:	910083ff 	add	sp, sp, #0x20
   84b94:	d65f03c0 	ret

0000000000084b98 <atoi>:

int atoi(char *str) {
   84b98:	d10083ff 	sub	sp, sp, #0x20
   84b9c:	f90007e0 	str	x0, [sp, #8]
    int val = 0;
   84ba0:	b9001fff 	str	wzr, [sp, #28]
    for (int i = 0; str[i] != 0; i++) {
   84ba4:	b9001bff 	str	wzr, [sp, #24]
   84ba8:	14000019 	b	84c0c <atoi+0x74>
        if (*str < '0' || *str > '9')
   84bac:	f94007e0 	ldr	x0, [sp, #8]
   84bb0:	39400000 	ldrb	w0, [x0]
   84bb4:	7100bc1f 	cmp	w0, #0x2f
   84bb8:	540000a9 	b.ls	84bcc <atoi+0x34>  // b.plast
   84bbc:	f94007e0 	ldr	x0, [sp, #8]
   84bc0:	39400000 	ldrb	w0, [x0]
   84bc4:	7100e41f 	cmp	w0, #0x39
   84bc8:	54000069 	b.ls	84bd4 <atoi+0x3c>  // b.plast
            return val;
   84bcc:	b9401fe0 	ldr	w0, [sp, #28]
   84bd0:	14000016 	b	84c28 <atoi+0x90>
        val = val * 10 + *str - '0';
   84bd4:	b9401fe1 	ldr	w1, [sp, #28]
   84bd8:	2a0103e0 	mov	w0, w1
   84bdc:	531e7400 	lsl	w0, w0, #2
   84be0:	0b010000 	add	w0, w0, w1
   84be4:	531f7800 	lsl	w0, w0, #1
   84be8:	2a0003e1 	mov	w1, w0
   84bec:	f94007e0 	ldr	x0, [sp, #8]
   84bf0:	39400000 	ldrb	w0, [x0]
   84bf4:	0b000020 	add	w0, w1, w0
   84bf8:	5100c000 	sub	w0, w0, #0x30
   84bfc:	b9001fe0 	str	w0, [sp, #28]
    for (int i = 0; str[i] != 0; i++) {
   84c00:	b9401be0 	ldr	w0, [sp, #24]
   84c04:	11000400 	add	w0, w0, #0x1
   84c08:	b9001be0 	str	w0, [sp, #24]
   84c0c:	b9801be0 	ldrsw	x0, [sp, #24]
   84c10:	f94007e1 	ldr	x1, [sp, #8]
   84c14:	8b000020 	add	x0, x1, x0
   84c18:	39400000 	ldrb	w0, [x0]
   84c1c:	7100001f 	cmp	w0, #0x0
   84c20:	54fffc61 	b.ne	84bac <atoi+0x14>  // b.any
    }
    return val;
   84c24:	b9401fe0 	ldr	w0, [sp, #28]
   84c28:	910083ff 	add	sp, sp, #0x20
   84c2c:	d65f03c0 	ret

0000000000084c30 <uart_init>:
unsigned int uart_tx_write = 0;
unsigned int uart_rx_read = 0;
unsigned int uart_rx_write = 0;
int uart_recv_echo_flag = 1;

void uart_init() {
   84c30:	f81f0ff3 	str	x19, [sp, #-16]!
    register unsigned int r;

    /* initialize UART */
    *AUX_ENABLES |= 1;    // enable UART1
   84c34:	d28a0080 	mov	x0, #0x5004                	// #20484
   84c38:	f2a7e420 	movk	x0, #0x3f21, lsl #16
   84c3c:	b9400001 	ldr	w1, [x0]
   84c40:	d28a0080 	mov	x0, #0x5004                	// #20484
   84c44:	f2a7e420 	movk	x0, #0x3f21, lsl #16
   84c48:	32000021 	orr	w1, w1, #0x1
   84c4c:	b9000001 	str	w1, [x0]
    *AUX_MU_CNTL_REG = 0; // disable TX/RX
   84c50:	d28a0c00 	mov	x0, #0x5060                	// #20576
   84c54:	f2a7e420 	movk	x0, #0x3f21, lsl #16
   84c58:	b900001f 	str	wzr, [x0]

    /* configure UART */
    *AUX_MU_IER_REG = 0;    // disable interrupt
   84c5c:	d28a0880 	mov	x0, #0x5044                	// #20548
   84c60:	f2a7e420 	movk	x0, #0x3f21, lsl #16
   84c64:	b900001f 	str	wzr, [x0]
    *AUX_MU_LCR_REG = 3;    // 8 bit data size
   84c68:	d28a0980 	mov	x0, #0x504c                	// #20556
   84c6c:	f2a7e420 	movk	x0, #0x3f21, lsl #16
   84c70:	52800061 	mov	w1, #0x3                   	// #3
   84c74:	b9000001 	str	w1, [x0]
    *AUX_MU_MCR_REG = 0;    // disable flow control
   84c78:	d28a0a00 	mov	x0, #0x5050                	// #20560
   84c7c:	f2a7e420 	movk	x0, #0x3f21, lsl #16
   84c80:	b900001f 	str	wzr, [x0]
    *AUX_MU_BAUD_REG = 270; // 115200 baud rate
   84c84:	d28a0d00 	mov	x0, #0x5068                	// #20584
   84c88:	f2a7e420 	movk	x0, #0x3f21, lsl #16
   84c8c:	528021c1 	mov	w1, #0x10e                 	// #270
   84c90:	b9000001 	str	w1, [x0]
    *AUX_MU_IIR_REG = 0x6;  // disable FIFO
   84c94:	d28a0900 	mov	x0, #0x5048                	// #20552
   84c98:	f2a7e420 	movk	x0, #0x3f21, lsl #16
   84c9c:	528000c1 	mov	w1, #0x6                   	// #6
   84ca0:	b9000001 	str	w1, [x0]

    /* map UART1 to GPIO pins */
    r = *GPFSEL1;    // load GPFSEL1(register) to r
   84ca4:	d2800080 	mov	x0, #0x4                   	// #4
   84ca8:	f2a7e400 	movk	x0, #0x3f20, lsl #16
   84cac:	b9400013 	ldr	w19, [x0]
    r &= ~(7 << 12); // clean gpio14
   84cb0:	12117273 	and	w19, w19, #0xffff8fff
    r |= 2 << 12;    // set gpio14 to alt5
   84cb4:	32130273 	orr	w19, w19, #0x2000
    r &= ~(7 << 15); // clean gpio15
   84cb8:	120e7273 	and	w19, w19, #0xfffc7fff
    r |= 2 << 15;    // set gpio15 to alt5
   84cbc:	32100273 	orr	w19, w19, #0x10000
    *GPFSEL1 = r;
   84cc0:	d2800080 	mov	x0, #0x4                   	// #4
   84cc4:	f2a7e400 	movk	x0, #0x3f20, lsl #16
   84cc8:	b9000013 	str	w19, [x0]

    /* enable pin 14, 15 - ref: Page 101 */
    *GPPUD = 0; // gpio pull-up/down, enable/disable gpio /
   84ccc:	d2801280 	mov	x0, #0x94                  	// #148
   84cd0:	f2a7e400 	movk	x0, #0x3f20, lsl #16
   84cd4:	b900001f 	str	wzr, [x0]
    r = 150;    // wait
   84cd8:	528012d3 	mov	w19, #0x96                  	// #150
    while (r--) {
   84cdc:	14000002 	b	84ce4 <uart_init+0xb4>
        asm volatile("nop");
   84ce0:	d503201f 	nop
    while (r--) {
   84ce4:	2a1303e0 	mov	w0, w19
   84ce8:	51000413 	sub	w19, w0, #0x1
   84cec:	7100001f 	cmp	w0, #0x0
   84cf0:	54ffff81 	b.ne	84ce0 <uart_init+0xb0>  // b.any
    }
    *GPPUDCLK0 = (1 << 14) | (1 << 15); //  pull-up/down 
   84cf4:	d2801300 	mov	x0, #0x98                  	// #152
   84cf8:	f2a7e400 	movk	x0, #0x3f20, lsl #16
   84cfc:	52980001 	mov	w1, #0xc000                	// #49152
   84d00:	b9000001 	str	w1, [x0]
    r = 150;
   84d04:	528012d3 	mov	w19, #0x96                  	// #150
    while (r--) {
   84d08:	14000002 	b	84d10 <uart_init+0xe0>
        asm volatile("nop");
   84d0c:	d503201f 	nop
    while (r--) {
   84d10:	2a1303e0 	mov	w0, w19
   84d14:	51000413 	sub	w19, w0, #0x1
   84d18:	7100001f 	cmp	w0, #0x0
   84d1c:	54ffff81 	b.ne	84d0c <uart_init+0xdc>  // b.any
    }
    *GPPUDCLK0 = 0; // clear register
   84d20:	d2801300 	mov	x0, #0x98                  	// #152
   84d24:	f2a7e400 	movk	x0, #0x3f20, lsl #16
   84d28:	b900001f 	str	wzr, [x0]

    *AUX_MU_CNTL_REG = 3;      // Enable transmitter and receiver
   84d2c:	d28a0c00 	mov	x0, #0x5060                	// #20576
   84d30:	f2a7e420 	movk	x0, #0x3f21, lsl #16
   84d34:	52800061 	mov	w1, #0x3                   	// #3
   84d38:	b9000001 	str	w1, [x0]
    *ENABLE_IRQS_1 |= 1 << 29; // Enable uart interrupt
   84d3c:	d2964200 	mov	x0, #0xb210                	// #45584
   84d40:	f2a7e000 	movk	x0, #0x3f00, lsl #16
   84d44:	b9400001 	ldr	w1, [x0]
   84d48:	d2964200 	mov	x0, #0xb210                	// #45584
   84d4c:	f2a7e000 	movk	x0, #0x3f00, lsl #16
   84d50:	32030021 	orr	w1, w1, #0x20000000
   84d54:	b9000001 	str	w1, [x0]
}
   84d58:	d503201f 	nop
   84d5c:	f84107f3 	ldr	x19, [sp], #16
   84d60:	d65f03c0 	ret

0000000000084d64 <uart_getc>:

// read big file usage(no output when read)
char uart_getc() {
   84d64:	d10043ff 	sub	sp, sp, #0x10
    char r;
    while (!(*AUX_MU_LSR_REG & 0x01)) {};
   84d68:	d503201f 	nop
   84d6c:	d28a0a80 	mov	x0, #0x5054                	// #20564
   84d70:	f2a7e420 	movk	x0, #0x3f21, lsl #16
   84d74:	b9400000 	ldr	w0, [x0]
   84d78:	12000000 	and	w0, w0, #0x1
   84d7c:	7100001f 	cmp	w0, #0x0
   84d80:	54ffff60 	b.eq	84d6c <uart_getc+0x8>  // b.none
    r = (char)(*AUX_MU_IO_REG);
   84d84:	d28a0800 	mov	x0, #0x5040                	// #20544
   84d88:	f2a7e420 	movk	x0, #0x3f21, lsl #16
   84d8c:	b9400000 	ldr	w0, [x0]
   84d90:	39003fe0 	strb	w0, [sp, #15]
    return r;
   84d94:	39403fe0 	ldrb	w0, [sp, #15]
}
   84d98:	910043ff 	add	sp, sp, #0x10
   84d9c:	d65f03c0 	ret

0000000000084da0 <uart_recv>:

char uart_recv() {
   84da0:	a9be7bfd 	stp	x29, x30, [sp, #-32]!
   84da4:	910003fd 	mov	x29, sp
    char r;
    // wait until LSR(fifo receiver) receive data
    while (!(*AUX_MU_LSR_REG & 0x01)) {};
   84da8:	d503201f 	nop
   84dac:	d28a0a80 	mov	x0, #0x5054                	// #20564
   84db0:	f2a7e420 	movk	x0, #0x3f21, lsl #16
   84db4:	b9400000 	ldr	w0, [x0]
   84db8:	12000000 	and	w0, w0, #0x1
   84dbc:	7100001f 	cmp	w0, #0x0
   84dc0:	54ffff60 	b.eq	84dac <uart_recv+0xc>  // b.none
    r = (char)(*AUX_MU_IO_REG); // save data in 'r'
   84dc4:	d28a0800 	mov	x0, #0x5040                	// #20544
   84dc8:	f2a7e420 	movk	x0, #0x3f21, lsl #16
   84dcc:	b9400000 	ldr	w0, [x0]
   84dd0:	39007fe0 	strb	w0, [sp, #31]
    if (uart_recv_echo_flag) {
   84dd4:	90000020 	adrp	x0, 88000 <cmd_list+0x980>
   84dd8:	91160000 	add	x0, x0, #0x580
   84ddc:	b9400000 	ldr	w0, [x0]
   84de0:	7100001f 	cmp	w0, #0x0
   84de4:	54000100 	b.eq	84e04 <uart_recv+0x64>  // b.none
        uart_send(r);
   84de8:	39407fe0 	ldrb	w0, [sp, #31]
   84dec:	9400000e 	bl	84e24 <uart_send>
        if (r == '\r') {
   84df0:	39407fe0 	ldrb	w0, [sp, #31]
   84df4:	7100341f 	cmp	w0, #0xd
   84df8:	54000061 	b.ne	84e04 <uart_recv+0x64>  // b.any
            uart_send('\n');
   84dfc:	52800140 	mov	w0, #0xa                   	// #10
   84e00:	94000009 	bl	84e24 <uart_send>
        }
    }
    return r == '\r' ? '\n' : r;
   84e04:	39407fe0 	ldrb	w0, [sp, #31]
   84e08:	7100341f 	cmp	w0, #0xd
   84e0c:	54000060 	b.eq	84e18 <uart_recv+0x78>  // b.none
   84e10:	39407fe0 	ldrb	w0, [sp, #31]
   84e14:	14000002 	b	84e1c <uart_recv+0x7c>
   84e18:	52800140 	mov	w0, #0xa                   	// #10
}
   84e1c:	a8c27bfd 	ldp	x29, x30, [sp], #32
   84e20:	d65f03c0 	ret

0000000000084e24 <uart_send>:

void uart_send(char c) {
   84e24:	d10043ff 	sub	sp, sp, #0x10
   84e28:	39003fe0 	strb	w0, [sp, #15]
    while (!(*AUX_MU_LSR_REG & 0x20)) {};
   84e2c:	d503201f 	nop
   84e30:	d28a0a80 	mov	x0, #0x5054                	// #20564
   84e34:	f2a7e420 	movk	x0, #0x3f21, lsl #16
   84e38:	b9400000 	ldr	w0, [x0]
   84e3c:	121b0000 	and	w0, w0, #0x20
   84e40:	7100001f 	cmp	w0, #0x0
   84e44:	54ffff60 	b.eq	84e30 <uart_send+0xc>  // b.none
    *AUX_MU_IO_REG = c;
   84e48:	d28a0800 	mov	x0, #0x5040                	// #20544
   84e4c:	f2a7e420 	movk	x0, #0x3f21, lsl #16
   84e50:	39403fe1 	ldrb	w1, [sp, #15]
   84e54:	b9000001 	str	w1, [x0]
}
   84e58:	d503201f 	nop
   84e5c:	910043ff 	add	sp, sp, #0x10
   84e60:	d65f03c0 	ret

0000000000084e64 <uart_2hex>:

void uart_2hex(unsigned int d) {
   84e64:	a9bd7bfd 	stp	x29, x30, [sp, #-48]!
   84e68:	910003fd 	mov	x29, sp
   84e6c:	b9001fe0 	str	w0, [sp, #28]
    unsigned int n;
    int c;
    for (c = 28; c >= 0; c -= 4) {
   84e70:	52800380 	mov	w0, #0x1c                  	// #28
   84e74:	b9002fe0 	str	w0, [sp, #44]
   84e78:	14000015 	b	84ecc <uart_2hex+0x68>
        n = (d >> c) & 0xF;       // get 4 bits
   84e7c:	b9402fe0 	ldr	w0, [sp, #44]
   84e80:	b9401fe1 	ldr	w1, [sp, #28]
   84e84:	1ac02420 	lsr	w0, w1, w0
   84e88:	12000c00 	and	w0, w0, #0xf
   84e8c:	b9002be0 	str	w0, [sp, #40]
        n += n > 9 ? 0x37 : 0x30; // if > 10, trans it to 'A'
   84e90:	b9402be0 	ldr	w0, [sp, #40]
   84e94:	7100241f 	cmp	w0, #0x9
   84e98:	54000069 	b.ls	84ea4 <uart_2hex+0x40>  // b.plast
   84e9c:	528006e0 	mov	w0, #0x37                  	// #55
   84ea0:	14000002 	b	84ea8 <uart_2hex+0x44>
   84ea4:	52800600 	mov	w0, #0x30                  	// #48
   84ea8:	b9402be1 	ldr	w1, [sp, #40]
   84eac:	0b000020 	add	w0, w1, w0
   84eb0:	b9002be0 	str	w0, [sp, #40]
        uart_send(n);
   84eb4:	b9402be0 	ldr	w0, [sp, #40]
   84eb8:	12001c00 	and	w0, w0, #0xff
   84ebc:	97ffffda 	bl	84e24 <uart_send>
    for (c = 28; c >= 0; c -= 4) {
   84ec0:	b9402fe0 	ldr	w0, [sp, #44]
   84ec4:	51001000 	sub	w0, w0, #0x4
   84ec8:	b9002fe0 	str	w0, [sp, #44]
   84ecc:	b9402fe0 	ldr	w0, [sp, #44]
   84ed0:	7100001f 	cmp	w0, #0x0
   84ed4:	54fffd4a 	b.ge	84e7c <uart_2hex+0x18>  // b.tcont
    }
}
   84ed8:	d503201f 	nop
   84edc:	d503201f 	nop
   84ee0:	a8c37bfd 	ldp	x29, x30, [sp], #48
   84ee4:	d65f03c0 	ret

0000000000084ee8 <uart_sendline>:

int uart_sendline(char *fmt, ...) {
   84ee8:	a9a57bfd 	stp	x29, x30, [sp, #-432]!
   84eec:	910003fd 	mov	x29, sp
   84ef0:	f9001fe0 	str	x0, [sp, #56]
   84ef4:	f900bfe1 	str	x1, [sp, #376]
   84ef8:	f900c3e2 	str	x2, [sp, #384]
   84efc:	f900c7e3 	str	x3, [sp, #392]
   84f00:	f900cbe4 	str	x4, [sp, #400]
   84f04:	f900cfe5 	str	x5, [sp, #408]
   84f08:	f900d3e6 	str	x6, [sp, #416]
   84f0c:	f900d7e7 	str	x7, [sp, #424]
    __builtin_va_list args;
    __builtin_va_start(args, fmt);
   84f10:	9106c3e0 	add	x0, sp, #0x1b0
   84f14:	f900a3e0 	str	x0, [sp, #320]
   84f18:	9106c3e0 	add	x0, sp, #0x1b0
   84f1c:	f900a7e0 	str	x0, [sp, #328]
   84f20:	9105c3e0 	add	x0, sp, #0x170
   84f24:	f900abe0 	str	x0, [sp, #336]
   84f28:	128006e0 	mov	w0, #0xffffffc8            	// #-56
   84f2c:	b9015be0 	str	w0, [sp, #344]
   84f30:	b9015fff 	str	wzr, [sp, #348]
    char buf[VSPRINT_MAX_BUF_SIZE]; // buf to get formatted string

    char *str = (char *)buf; // trans it to a ptr
   84f34:	910103e0 	add	x0, sp, #0x40
   84f38:	f900b7e0 	str	x0, [sp, #360]
    int count = vsprintf(str, fmt, args);
   84f3c:	910043e2 	add	x2, sp, #0x10
   84f40:	910503e3 	add	x3, sp, #0x140
   84f44:	a9400460 	ldp	x0, x1, [x3]
   84f48:	a9000440 	stp	x0, x1, [x2]
   84f4c:	a9410460 	ldp	x0, x1, [x3, #16]
   84f50:	a9010440 	stp	x0, x1, [x2, #16]
   84f54:	910043e0 	add	x0, sp, #0x10
   84f58:	aa0003e2 	mov	x2, x0
   84f5c:	f9401fe1 	ldr	x1, [sp, #56]
   84f60:	f940b7e0 	ldr	x0, [sp, #360]
   84f64:	97fffc77 	bl	84140 <vsprintf>
   84f68:	b90167e0 	str	w0, [sp, #356]

    while (*str) {
   84f6c:	1400000c 	b	84f9c <uart_sendline+0xb4>
        if (*str == '\n') {
   84f70:	f940b7e0 	ldr	x0, [sp, #360]
   84f74:	39400000 	ldrb	w0, [x0]
   84f78:	7100281f 	cmp	w0, #0xa
   84f7c:	54000061 	b.ne	84f88 <uart_sendline+0xa0>  // b.any
            uart_send('\r');
   84f80:	528001a0 	mov	w0, #0xd                   	// #13
   84f84:	97ffffa8 	bl	84e24 <uart_send>
        }
        uart_send(*str++);
   84f88:	f940b7e0 	ldr	x0, [sp, #360]
   84f8c:	91000401 	add	x1, x0, #0x1
   84f90:	f900b7e1 	str	x1, [sp, #360]
   84f94:	39400000 	ldrb	w0, [x0]
   84f98:	97ffffa3 	bl	84e24 <uart_send>
    while (*str) {
   84f9c:	f940b7e0 	ldr	x0, [sp, #360]
   84fa0:	39400000 	ldrb	w0, [x0]
   84fa4:	7100001f 	cmp	w0, #0x0
   84fa8:	54fffe41 	b.ne	84f70 <uart_sendline+0x88>  // b.any
    }
    __builtin_va_end(args);
    return count;
   84fac:	b94167e0 	ldr	w0, [sp, #356]
}
   84fb0:	a8db7bfd 	ldp	x29, x30, [sp], #432
   84fb4:	d65f03c0 	ret

0000000000084fb8 <uart_tx_irq_handler>:

void uart_tx_irq_handler() {
   84fb8:	a9bf7bfd 	stp	x29, x30, [sp, #-16]!
   84fbc:	910003fd 	mov	x29, sp
    // buffer empty
    if (uart_tx_write == uart_tx_read) {
   84fc0:	b0002800 	adrp	x0, 585000 <_bss_size+0x4e5675>
   84fc4:	9109f000 	add	x0, x0, #0x27c
   84fc8:	b9400001 	ldr	w1, [x0]
   84fcc:	b0002800 	adrp	x0, 585000 <_bss_size+0x4e5675>
   84fd0:	9109e000 	add	x0, x0, #0x278
   84fd4:	b9400000 	ldr	w0, [x0]
   84fd8:	6b00003f 	cmp	w1, w0
   84fdc:	54000061 	b.ne	84fe8 <uart_tx_irq_handler+0x30>  // b.any
        uart_tx_irq_disable(); // disable wtite interrupt
   84fe0:	940000b9 	bl	852c4 <uart_tx_irq_disable>
        return;
   84fe4:	14000020 	b	85064 <uart_tx_irq_handler+0xac>
    }
    // critical
    uart_tx_irq_disable(); // disable write interrupt
   84fe8:	940000b7 	bl	852c4 <uart_tx_irq_disable>
    // print if buffer not empty
    while (uart_tx_read != uart_tx_write) {
   84fec:	14000016 	b	85044 <uart_tx_irq_handler+0x8c>
        *AUX_MU_IO_REG = uart_tx_buffer[uart_tx_read++]; // print
   84ff0:	b0002800 	adrp	x0, 585000 <_bss_size+0x4e5675>
   84ff4:	9109e000 	add	x0, x0, #0x278
   84ff8:	b9400000 	ldr	w0, [x0]
   84ffc:	11000402 	add	w2, w0, #0x1
   85000:	90002801 	adrp	x1, 585000 <_bss_size+0x4e5675>
   85004:	9109e021 	add	x1, x1, #0x278
   85008:	b9000022 	str	w2, [x1]
   8500c:	90002801 	adrp	x1, 585000 <_bss_size+0x4e5675>
   85010:	9101e021 	add	x1, x1, #0x78
   85014:	2a0003e0 	mov	w0, w0
   85018:	38606821 	ldrb	w1, [x1, x0]
   8501c:	d28a0800 	mov	x0, #0x5040                	// #20544
   85020:	f2a7e420 	movk	x0, #0x3f21, lsl #16
   85024:	b9000001 	str	w1, [x0]
        uart_tx_read %= VSPRINT_MAX_BUF_SIZE;
   85028:	90002800 	adrp	x0, 585000 <_bss_size+0x4e5675>
   8502c:	9109e000 	add	x0, x0, #0x278
   85030:	b9400000 	ldr	w0, [x0]
   85034:	12001c01 	and	w1, w0, #0xff
   85038:	90002800 	adrp	x0, 585000 <_bss_size+0x4e5675>
   8503c:	9109e000 	add	x0, x0, #0x278
   85040:	b9000001 	str	w1, [x0]
    while (uart_tx_read != uart_tx_write) {
   85044:	90002800 	adrp	x0, 585000 <_bss_size+0x4e5675>
   85048:	9109e000 	add	x0, x0, #0x278
   8504c:	b9400001 	ldr	w1, [x0]
   85050:	90002800 	adrp	x0, 585000 <_bss_size+0x4e5675>
   85054:	9109f000 	add	x0, x0, #0x27c
   85058:	b9400000 	ldr	w0, [x0]
   8505c:	6b00003f 	cmp	w1, w0
   85060:	54fffc81 	b.ne	84ff0 <uart_tx_irq_handler+0x38>  // b.any
    }
    // end critical (tx irq will be enable again in next 'async putc' call)
}
   85064:	a8c17bfd 	ldp	x29, x30, [sp], #16
   85068:	d65f03c0 	ret

000000000008506c <uart_rx_irq_handler>:

void uart_rx_irq_handler() {
   8506c:	a9be7bfd 	stp	x29, x30, [sp, #-32]!
   85070:	910003fd 	mov	x29, sp
   85074:	f9000bf3 	str	x19, [sp, #16]
    // Check if buffer is full
    if ((uart_rx_write + 1) % VSPRINT_MAX_BUF_SIZE == uart_rx_read) {
   85078:	90002800 	adrp	x0, 585000 <_bss_size+0x4e5675>
   8507c:	910a1000 	add	x0, x0, #0x284
   85080:	b9400000 	ldr	w0, [x0]
   85084:	11000400 	add	w0, w0, #0x1
   85088:	12001c01 	and	w1, w0, #0xff
   8508c:	90002800 	adrp	x0, 585000 <_bss_size+0x4e5675>
   85090:	910a0000 	add	x0, x0, #0x280
   85094:	b9400000 	ldr	w0, [x0]
   85098:	6b00003f 	cmp	w1, w0
   8509c:	54000061 	b.ne	850a8 <uart_rx_irq_handler+0x3c>  // b.any
        uart_rx_irq_disable();
   850a0:	94000077 	bl	8527c <uart_rx_irq_disable>
        return;
   850a4:	14000021 	b	85128 <uart_rx_irq_handler+0xbc>
    }

    // Disable read interrupt
    uart_rx_irq_disable();
   850a8:	94000075 	bl	8527c <uart_rx_irq_disable>

    // Store data in buffer
    while ((uart_rx_read + 1) % VSPRINT_MAX_BUF_SIZE != uart_rx_write) {
   850ac:	14000015 	b	85100 <uart_rx_irq_handler+0x94>
        uart_rx_buffer[uart_rx_write++] = uart_recv(); // Save data in buffer
   850b0:	90002800 	adrp	x0, 585000 <_bss_size+0x4e5675>
   850b4:	910a1000 	add	x0, x0, #0x284
   850b8:	b9400013 	ldr	w19, [x0]
   850bc:	11000661 	add	w1, w19, #0x1
   850c0:	90002800 	adrp	x0, 585000 <_bss_size+0x4e5675>
   850c4:	910a1000 	add	x0, x0, #0x284
   850c8:	b9000001 	str	w1, [x0]
   850cc:	97ffff35 	bl	84da0 <uart_recv>
   850d0:	12001c02 	and	w2, w0, #0xff
   850d4:	90002800 	adrp	x0, 585000 <_bss_size+0x4e5675>
   850d8:	9105e001 	add	x1, x0, #0x178
   850dc:	2a1303e0 	mov	w0, w19
   850e0:	38206822 	strb	w2, [x1, x0]
        uart_rx_write %= VSPRINT_MAX_BUF_SIZE;
   850e4:	90002800 	adrp	x0, 585000 <_bss_size+0x4e5675>
   850e8:	910a1000 	add	x0, x0, #0x284
   850ec:	b9400000 	ldr	w0, [x0]
   850f0:	12001c01 	and	w1, w0, #0xff
   850f4:	90002800 	adrp	x0, 585000 <_bss_size+0x4e5675>
   850f8:	910a1000 	add	x0, x0, #0x284
   850fc:	b9000001 	str	w1, [x0]
    while ((uart_rx_read + 1) % VSPRINT_MAX_BUF_SIZE != uart_rx_write) {
   85100:	90002800 	adrp	x0, 585000 <_bss_size+0x4e5675>
   85104:	910a0000 	add	x0, x0, #0x280
   85108:	b9400000 	ldr	w0, [x0]
   8510c:	11000400 	add	w0, w0, #0x1
   85110:	12001c01 	and	w1, w0, #0xff
   85114:	90002800 	adrp	x0, 585000 <_bss_size+0x4e5675>
   85118:	910a1000 	add	x0, x0, #0x284
   8511c:	b9400000 	ldr	w0, [x0]
   85120:	6b00003f 	cmp	w1, w0
   85124:	54fffc61 	b.ne	850b0 <uart_rx_irq_handler+0x44>  // b.any
    }
    // end critical (rx irq will be enable again in next 'async getc' call)
}
   85128:	f9400bf3 	ldr	x19, [sp, #16]
   8512c:	a8c27bfd 	ldp	x29, x30, [sp], #32
   85130:	d65f03c0 	ret

0000000000085134 <uart_async_putc>:

void uart_async_putc(char c) {
   85134:	a9be7bfd 	stp	x29, x30, [sp, #-32]!
   85138:	910003fd 	mov	x29, sp
   8513c:	39007fe0 	strb	w0, [sp, #31]
    // hold when buffer full
    while (((uart_tx_write + 1) % VSPRINT_MAX_BUF_SIZE) == uart_tx_read) {};
   85140:	d503201f 	nop
   85144:	90002800 	adrp	x0, 585000 <_bss_size+0x4e5675>
   85148:	9109f000 	add	x0, x0, #0x27c
   8514c:	b9400000 	ldr	w0, [x0]
   85150:	11000400 	add	w0, w0, #0x1
   85154:	12001c01 	and	w1, w0, #0xff
   85158:	90002800 	adrp	x0, 585000 <_bss_size+0x4e5675>
   8515c:	9109e000 	add	x0, x0, #0x278
   85160:	b9400000 	ldr	w0, [x0]
   85164:	6b00003f 	cmp	w1, w0
   85168:	54fffee0 	b.eq	85144 <uart_async_putc+0x10>  // b.none
    uart_tx_irq_disable(); // disable write interrupt
   8516c:	94000056 	bl	852c4 <uart_tx_irq_disable>
    uart_tx_buffer[uart_tx_write++] = c;
   85170:	90002800 	adrp	x0, 585000 <_bss_size+0x4e5675>
   85174:	9109f000 	add	x0, x0, #0x27c
   85178:	b9400000 	ldr	w0, [x0]
   8517c:	11000402 	add	w2, w0, #0x1
   85180:	90002801 	adrp	x1, 585000 <_bss_size+0x4e5675>
   85184:	9109f021 	add	x1, x1, #0x27c
   85188:	b9000022 	str	w2, [x1]
   8518c:	90002801 	adrp	x1, 585000 <_bss_size+0x4e5675>
   85190:	9101e021 	add	x1, x1, #0x78
   85194:	2a0003e0 	mov	w0, w0
   85198:	39407fe2 	ldrb	w2, [sp, #31]
   8519c:	38206822 	strb	w2, [x1, x0]
    uart_tx_write %= VSPRINT_MAX_BUF_SIZE;
   851a0:	90002800 	adrp	x0, 585000 <_bss_size+0x4e5675>
   851a4:	9109f000 	add	x0, x0, #0x27c
   851a8:	b9400000 	ldr	w0, [x0]
   851ac:	12001c01 	and	w1, w0, #0xff
   851b0:	90002800 	adrp	x0, 585000 <_bss_size+0x4e5675>
   851b4:	9109f000 	add	x0, x0, #0x27c
   851b8:	b9000001 	str	w1, [x0]
    uart_tx_irq_enable(); // enable write interrupt
   851bc:	94000039 	bl	852a0 <uart_tx_irq_enable>
}
   851c0:	d503201f 	nop
   851c4:	a8c27bfd 	ldp	x29, x30, [sp], #32
   851c8:	d65f03c0 	ret

00000000000851cc <uart_async_getc>:

char uart_async_getc() {
   851cc:	a9be7bfd 	stp	x29, x30, [sp, #-32]!
   851d0:	910003fd 	mov	x29, sp
    // empty
    uart_rx_irq_enable();
   851d4:	94000021 	bl	85258 <uart_rx_irq_enable>
    while (uart_rx_read == uart_rx_write) {};
   851d8:	d503201f 	nop
   851dc:	90002800 	adrp	x0, 585000 <_bss_size+0x4e5675>
   851e0:	910a0000 	add	x0, x0, #0x280
   851e4:	b9400001 	ldr	w1, [x0]
   851e8:	90002800 	adrp	x0, 585000 <_bss_size+0x4e5675>
   851ec:	910a1000 	add	x0, x0, #0x284
   851f0:	b9400000 	ldr	w0, [x0]
   851f4:	6b00003f 	cmp	w1, w0
   851f8:	54ffff20 	b.eq	851dc <uart_async_getc+0x10>  // b.none
    // delay here?
    uart_rx_irq_disable(); // disable read interrupt
   851fc:	94000020 	bl	8527c <uart_rx_irq_disable>
    char c = uart_rx_buffer[uart_rx_read++];
   85200:	90002800 	adrp	x0, 585000 <_bss_size+0x4e5675>
   85204:	910a0000 	add	x0, x0, #0x280
   85208:	b9400000 	ldr	w0, [x0]
   8520c:	11000402 	add	w2, w0, #0x1
   85210:	90002801 	adrp	x1, 585000 <_bss_size+0x4e5675>
   85214:	910a0021 	add	x1, x1, #0x280
   85218:	b9000022 	str	w2, [x1]
   8521c:	90002801 	adrp	x1, 585000 <_bss_size+0x4e5675>
   85220:	9105e021 	add	x1, x1, #0x178
   85224:	2a0003e0 	mov	w0, w0
   85228:	38606820 	ldrb	w0, [x1, x0]
   8522c:	39007fe0 	strb	w0, [sp, #31]
    uart_rx_read %= VSPRINT_MAX_BUF_SIZE;
   85230:	90002800 	adrp	x0, 585000 <_bss_size+0x4e5675>
   85234:	910a0000 	add	x0, x0, #0x280
   85238:	b9400000 	ldr	w0, [x0]
   8523c:	12001c01 	and	w1, w0, #0xff
   85240:	90002800 	adrp	x0, 585000 <_bss_size+0x4e5675>
   85244:	910a0000 	add	x0, x0, #0x280
   85248:	b9000001 	str	w1, [x0]
    return c;
   8524c:	39407fe0 	ldrb	w0, [sp, #31]
}
   85250:	a8c27bfd 	ldp	x29, x30, [sp], #32
   85254:	d65f03c0 	ret

0000000000085258 <uart_rx_irq_enable>:

void uart_rx_irq_enable() {
    *AUX_MU_IER_REG |= 1; // enable read interrupt
   85258:	d28a0880 	mov	x0, #0x5044                	// #20548
   8525c:	f2a7e420 	movk	x0, #0x3f21, lsl #16
   85260:	b9400001 	ldr	w1, [x0]
   85264:	d28a0880 	mov	x0, #0x5044                	// #20548
   85268:	f2a7e420 	movk	x0, #0x3f21, lsl #16
   8526c:	32000021 	orr	w1, w1, #0x1
   85270:	b9000001 	str	w1, [x0]
}
   85274:	d503201f 	nop
   85278:	d65f03c0 	ret

000000000008527c <uart_rx_irq_disable>:

void uart_rx_irq_disable() {
    *AUX_MU_IER_REG &= ~(1); // disable read interrupt
   8527c:	d28a0880 	mov	x0, #0x5044                	// #20548
   85280:	f2a7e420 	movk	x0, #0x3f21, lsl #16
   85284:	b9400001 	ldr	w1, [x0]
   85288:	d28a0880 	mov	x0, #0x5044                	// #20548
   8528c:	f2a7e420 	movk	x0, #0x3f21, lsl #16
   85290:	121f7821 	and	w1, w1, #0xfffffffe
   85294:	b9000001 	str	w1, [x0]
}
   85298:	d503201f 	nop
   8529c:	d65f03c0 	ret

00000000000852a0 <uart_tx_irq_enable>:

void uart_tx_irq_enable() {
    *AUX_MU_IER_REG |= 2; // enable write interrupt
   852a0:	d28a0880 	mov	x0, #0x5044                	// #20548
   852a4:	f2a7e420 	movk	x0, #0x3f21, lsl #16
   852a8:	b9400001 	ldr	w1, [x0]
   852ac:	d28a0880 	mov	x0, #0x5044                	// #20548
   852b0:	f2a7e420 	movk	x0, #0x3f21, lsl #16
   852b4:	321f0021 	orr	w1, w1, #0x2
   852b8:	b9000001 	str	w1, [x0]
}
   852bc:	d503201f 	nop
   852c0:	d65f03c0 	ret

00000000000852c4 <uart_tx_irq_disable>:

void uart_tx_irq_disable() {
    *AUX_MU_IER_REG &= ~(2); // disable write interrupt
   852c4:	d28a0880 	mov	x0, #0x5044                	// #20548
   852c8:	f2a7e420 	movk	x0, #0x3f21, lsl #16
   852cc:	b9400001 	ldr	w1, [x0]
   852d0:	d28a0880 	mov	x0, #0x5044                	// #20548
   852d4:	f2a7e420 	movk	x0, #0x3f21, lsl #16
   852d8:	121e7821 	and	w1, w1, #0xfffffffd
   852dc:	b9000001 	str	w1, [x0]
   852e0:	d503201f 	nop
   852e4:	d65f03c0 	ret
	...

0000000000085800 <exception_vector_table>:
   85800:	140001e1 	b	85f84 <el1t_sync_invalid>
   85804:	d503201f 	nop
   85808:	d503201f 	nop
   8580c:	d503201f 	nop
   85810:	d503201f 	nop
   85814:	d503201f 	nop
   85818:	d503201f 	nop
   8581c:	d503201f 	nop
   85820:	d503201f 	nop
   85824:	d503201f 	nop
   85828:	d503201f 	nop
   8582c:	d503201f 	nop
   85830:	d503201f 	nop
   85834:	d503201f 	nop
   85838:	d503201f 	nop
   8583c:	d503201f 	nop
   85840:	d503201f 	nop
   85844:	d503201f 	nop
   85848:	d503201f 	nop
   8584c:	d503201f 	nop
   85850:	d503201f 	nop
   85854:	d503201f 	nop
   85858:	d503201f 	nop
   8585c:	d503201f 	nop
   85860:	d503201f 	nop
   85864:	d503201f 	nop
   85868:	d503201f 	nop
   8586c:	d503201f 	nop
   85870:	d503201f 	nop
   85874:	d503201f 	nop
   85878:	d503201f 	nop
   8587c:	d503201f 	nop
   85880:	140001c2 	b	85f88 <el1t_irq_invalid>
   85884:	d503201f 	nop
   85888:	d503201f 	nop
   8588c:	d503201f 	nop
   85890:	d503201f 	nop
   85894:	d503201f 	nop
   85898:	d503201f 	nop
   8589c:	d503201f 	nop
   858a0:	d503201f 	nop
   858a4:	d503201f 	nop
   858a8:	d503201f 	nop
   858ac:	d503201f 	nop
   858b0:	d503201f 	nop
   858b4:	d503201f 	nop
   858b8:	d503201f 	nop
   858bc:	d503201f 	nop
   858c0:	d503201f 	nop
   858c4:	d503201f 	nop
   858c8:	d503201f 	nop
   858cc:	d503201f 	nop
   858d0:	d503201f 	nop
   858d4:	d503201f 	nop
   858d8:	d503201f 	nop
   858dc:	d503201f 	nop
   858e0:	d503201f 	nop
   858e4:	d503201f 	nop
   858e8:	d503201f 	nop
   858ec:	d503201f 	nop
   858f0:	d503201f 	nop
   858f4:	d503201f 	nop
   858f8:	d503201f 	nop
   858fc:	d503201f 	nop
   85900:	140001d6 	b	86058 <el1t_fiq_invalid>
   85904:	d503201f 	nop
   85908:	d503201f 	nop
   8590c:	d503201f 	nop
   85910:	d503201f 	nop
   85914:	d503201f 	nop
   85918:	d503201f 	nop
   8591c:	d503201f 	nop
   85920:	d503201f 	nop
   85924:	d503201f 	nop
   85928:	d503201f 	nop
   8592c:	d503201f 	nop
   85930:	d503201f 	nop
   85934:	d503201f 	nop
   85938:	d503201f 	nop
   8593c:	d503201f 	nop
   85940:	d503201f 	nop
   85944:	d503201f 	nop
   85948:	d503201f 	nop
   8594c:	d503201f 	nop
   85950:	d503201f 	nop
   85954:	d503201f 	nop
   85958:	d503201f 	nop
   8595c:	d503201f 	nop
   85960:	d503201f 	nop
   85964:	d503201f 	nop
   85968:	d503201f 	nop
   8596c:	d503201f 	nop
   85970:	d503201f 	nop
   85974:	d503201f 	nop
   85978:	d503201f 	nop
   8597c:	d503201f 	nop
   85980:	140001b7 	b	8605c <el1t_error_invalid>
   85984:	d503201f 	nop
   85988:	d503201f 	nop
   8598c:	d503201f 	nop
   85990:	d503201f 	nop
   85994:	d503201f 	nop
   85998:	d503201f 	nop
   8599c:	d503201f 	nop
   859a0:	d503201f 	nop
   859a4:	d503201f 	nop
   859a8:	d503201f 	nop
   859ac:	d503201f 	nop
   859b0:	d503201f 	nop
   859b4:	d503201f 	nop
   859b8:	d503201f 	nop
   859bc:	d503201f 	nop
   859c0:	d503201f 	nop
   859c4:	d503201f 	nop
   859c8:	d503201f 	nop
   859cc:	d503201f 	nop
   859d0:	d503201f 	nop
   859d4:	d503201f 	nop
   859d8:	d503201f 	nop
   859dc:	d503201f 	nop
   859e0:	d503201f 	nop
   859e4:	d503201f 	nop
   859e8:	d503201f 	nop
   859ec:	d503201f 	nop
   859f0:	d503201f 	nop
   859f4:	d503201f 	nop
   859f8:	d503201f 	nop
   859fc:	d503201f 	nop
   85a00:	14000198 	b	86060 <el1h_sync>
   85a04:	d503201f 	nop
   85a08:	d503201f 	nop
   85a0c:	d503201f 	nop
   85a10:	d503201f 	nop
   85a14:	d503201f 	nop
   85a18:	d503201f 	nop
   85a1c:	d503201f 	nop
   85a20:	d503201f 	nop
   85a24:	d503201f 	nop
   85a28:	d503201f 	nop
   85a2c:	d503201f 	nop
   85a30:	d503201f 	nop
   85a34:	d503201f 	nop
   85a38:	d503201f 	nop
   85a3c:	d503201f 	nop
   85a40:	d503201f 	nop
   85a44:	d503201f 	nop
   85a48:	d503201f 	nop
   85a4c:	d503201f 	nop
   85a50:	d503201f 	nop
   85a54:	d503201f 	nop
   85a58:	d503201f 	nop
   85a5c:	d503201f 	nop
   85a60:	d503201f 	nop
   85a64:	d503201f 	nop
   85a68:	d503201f 	nop
   85a6c:	d503201f 	nop
   85a70:	d503201f 	nop
   85a74:	d503201f 	nop
   85a78:	d503201f 	nop
   85a7c:	d503201f 	nop
   85a80:	14000179 	b	86064 <el1h_irq>
   85a84:	d503201f 	nop
   85a88:	d503201f 	nop
   85a8c:	d503201f 	nop
   85a90:	d503201f 	nop
   85a94:	d503201f 	nop
   85a98:	d503201f 	nop
   85a9c:	d503201f 	nop
   85aa0:	d503201f 	nop
   85aa4:	d503201f 	nop
   85aa8:	d503201f 	nop
   85aac:	d503201f 	nop
   85ab0:	d503201f 	nop
   85ab4:	d503201f 	nop
   85ab8:	d503201f 	nop
   85abc:	d503201f 	nop
   85ac0:	d503201f 	nop
   85ac4:	d503201f 	nop
   85ac8:	d503201f 	nop
   85acc:	d503201f 	nop
   85ad0:	d503201f 	nop
   85ad4:	d503201f 	nop
   85ad8:	d503201f 	nop
   85adc:	d503201f 	nop
   85ae0:	d503201f 	nop
   85ae4:	d503201f 	nop
   85ae8:	d503201f 	nop
   85aec:	d503201f 	nop
   85af0:	d503201f 	nop
   85af4:	d503201f 	nop
   85af8:	d503201f 	nop
   85afc:	d503201f 	nop
   85b00:	1400018d 	b	86134 <el1h_fiq_invalid>
   85b04:	d503201f 	nop
   85b08:	d503201f 	nop
   85b0c:	d503201f 	nop
   85b10:	d503201f 	nop
   85b14:	d503201f 	nop
   85b18:	d503201f 	nop
   85b1c:	d503201f 	nop
   85b20:	d503201f 	nop
   85b24:	d503201f 	nop
   85b28:	d503201f 	nop
   85b2c:	d503201f 	nop
   85b30:	d503201f 	nop
   85b34:	d503201f 	nop
   85b38:	d503201f 	nop
   85b3c:	d503201f 	nop
   85b40:	d503201f 	nop
   85b44:	d503201f 	nop
   85b48:	d503201f 	nop
   85b4c:	d503201f 	nop
   85b50:	d503201f 	nop
   85b54:	d503201f 	nop
   85b58:	d503201f 	nop
   85b5c:	d503201f 	nop
   85b60:	d503201f 	nop
   85b64:	d503201f 	nop
   85b68:	d503201f 	nop
   85b6c:	d503201f 	nop
   85b70:	d503201f 	nop
   85b74:	d503201f 	nop
   85b78:	d503201f 	nop
   85b7c:	d503201f 	nop
   85b80:	1400016e 	b	86138 <el1h_error_invalid>
   85b84:	d503201f 	nop
   85b88:	d503201f 	nop
   85b8c:	d503201f 	nop
   85b90:	d503201f 	nop
   85b94:	d503201f 	nop
   85b98:	d503201f 	nop
   85b9c:	d503201f 	nop
   85ba0:	d503201f 	nop
   85ba4:	d503201f 	nop
   85ba8:	d503201f 	nop
   85bac:	d503201f 	nop
   85bb0:	d503201f 	nop
   85bb4:	d503201f 	nop
   85bb8:	d503201f 	nop
   85bbc:	d503201f 	nop
   85bc0:	d503201f 	nop
   85bc4:	d503201f 	nop
   85bc8:	d503201f 	nop
   85bcc:	d503201f 	nop
   85bd0:	d503201f 	nop
   85bd4:	d503201f 	nop
   85bd8:	d503201f 	nop
   85bdc:	d503201f 	nop
   85be0:	d503201f 	nop
   85be4:	d503201f 	nop
   85be8:	d503201f 	nop
   85bec:	d503201f 	nop
   85bf0:	d503201f 	nop
   85bf4:	d503201f 	nop
   85bf8:	d503201f 	nop
   85bfc:	d503201f 	nop
   85c00:	1400014f 	b	8613c <el0_sync_64>
   85c04:	d503201f 	nop
   85c08:	d503201f 	nop
   85c0c:	d503201f 	nop
   85c10:	d503201f 	nop
   85c14:	d503201f 	nop
   85c18:	d503201f 	nop
   85c1c:	d503201f 	nop
   85c20:	d503201f 	nop
   85c24:	d503201f 	nop
   85c28:	d503201f 	nop
   85c2c:	d503201f 	nop
   85c30:	d503201f 	nop
   85c34:	d503201f 	nop
   85c38:	d503201f 	nop
   85c3c:	d503201f 	nop
   85c40:	d503201f 	nop
   85c44:	d503201f 	nop
   85c48:	d503201f 	nop
   85c4c:	d503201f 	nop
   85c50:	d503201f 	nop
   85c54:	d503201f 	nop
   85c58:	d503201f 	nop
   85c5c:	d503201f 	nop
   85c60:	d503201f 	nop
   85c64:	d503201f 	nop
   85c68:	d503201f 	nop
   85c6c:	d503201f 	nop
   85c70:	d503201f 	nop
   85c74:	d503201f 	nop
   85c78:	d503201f 	nop
   85c7c:	d503201f 	nop
   85c80:	14000163 	b	8620c <el0_irq_64>
   85c84:	d503201f 	nop
   85c88:	d503201f 	nop
   85c8c:	d503201f 	nop
   85c90:	d503201f 	nop
   85c94:	d503201f 	nop
   85c98:	d503201f 	nop
   85c9c:	d503201f 	nop
   85ca0:	d503201f 	nop
   85ca4:	d503201f 	nop
   85ca8:	d503201f 	nop
   85cac:	d503201f 	nop
   85cb0:	d503201f 	nop
   85cb4:	d503201f 	nop
   85cb8:	d503201f 	nop
   85cbc:	d503201f 	nop
   85cc0:	d503201f 	nop
   85cc4:	d503201f 	nop
   85cc8:	d503201f 	nop
   85ccc:	d503201f 	nop
   85cd0:	d503201f 	nop
   85cd4:	d503201f 	nop
   85cd8:	d503201f 	nop
   85cdc:	d503201f 	nop
   85ce0:	d503201f 	nop
   85ce4:	d503201f 	nop
   85ce8:	d503201f 	nop
   85cec:	d503201f 	nop
   85cf0:	d503201f 	nop
   85cf4:	d503201f 	nop
   85cf8:	d503201f 	nop
   85cfc:	d503201f 	nop
   85d00:	14000144 	b	86210 <el0_fiq_invalid_64>
   85d04:	d503201f 	nop
   85d08:	d503201f 	nop
   85d0c:	d503201f 	nop
   85d10:	d503201f 	nop
   85d14:	d503201f 	nop
   85d18:	d503201f 	nop
   85d1c:	d503201f 	nop
   85d20:	d503201f 	nop
   85d24:	d503201f 	nop
   85d28:	d503201f 	nop
   85d2c:	d503201f 	nop
   85d30:	d503201f 	nop
   85d34:	d503201f 	nop
   85d38:	d503201f 	nop
   85d3c:	d503201f 	nop
   85d40:	d503201f 	nop
   85d44:	d503201f 	nop
   85d48:	d503201f 	nop
   85d4c:	d503201f 	nop
   85d50:	d503201f 	nop
   85d54:	d503201f 	nop
   85d58:	d503201f 	nop
   85d5c:	d503201f 	nop
   85d60:	d503201f 	nop
   85d64:	d503201f 	nop
   85d68:	d503201f 	nop
   85d6c:	d503201f 	nop
   85d70:	d503201f 	nop
   85d74:	d503201f 	nop
   85d78:	d503201f 	nop
   85d7c:	d503201f 	nop
   85d80:	14000125 	b	86214 <el0_error_invalid_64>
   85d84:	d503201f 	nop
   85d88:	d503201f 	nop
   85d8c:	d503201f 	nop
   85d90:	d503201f 	nop
   85d94:	d503201f 	nop
   85d98:	d503201f 	nop
   85d9c:	d503201f 	nop
   85da0:	d503201f 	nop
   85da4:	d503201f 	nop
   85da8:	d503201f 	nop
   85dac:	d503201f 	nop
   85db0:	d503201f 	nop
   85db4:	d503201f 	nop
   85db8:	d503201f 	nop
   85dbc:	d503201f 	nop
   85dc0:	d503201f 	nop
   85dc4:	d503201f 	nop
   85dc8:	d503201f 	nop
   85dcc:	d503201f 	nop
   85dd0:	d503201f 	nop
   85dd4:	d503201f 	nop
   85dd8:	d503201f 	nop
   85ddc:	d503201f 	nop
   85de0:	d503201f 	nop
   85de4:	d503201f 	nop
   85de8:	d503201f 	nop
   85dec:	d503201f 	nop
   85df0:	d503201f 	nop
   85df4:	d503201f 	nop
   85df8:	d503201f 	nop
   85dfc:	d503201f 	nop
   85e00:	14000106 	b	86218 <el0_sync_invalid_32>
   85e04:	d503201f 	nop
   85e08:	d503201f 	nop
   85e0c:	d503201f 	nop
   85e10:	d503201f 	nop
   85e14:	d503201f 	nop
   85e18:	d503201f 	nop
   85e1c:	d503201f 	nop
   85e20:	d503201f 	nop
   85e24:	d503201f 	nop
   85e28:	d503201f 	nop
   85e2c:	d503201f 	nop
   85e30:	d503201f 	nop
   85e34:	d503201f 	nop
   85e38:	d503201f 	nop
   85e3c:	d503201f 	nop
   85e40:	d503201f 	nop
   85e44:	d503201f 	nop
   85e48:	d503201f 	nop
   85e4c:	d503201f 	nop
   85e50:	d503201f 	nop
   85e54:	d503201f 	nop
   85e58:	d503201f 	nop
   85e5c:	d503201f 	nop
   85e60:	d503201f 	nop
   85e64:	d503201f 	nop
   85e68:	d503201f 	nop
   85e6c:	d503201f 	nop
   85e70:	d503201f 	nop
   85e74:	d503201f 	nop
   85e78:	d503201f 	nop
   85e7c:	d503201f 	nop
   85e80:	140000e7 	b	8621c <el0_irq_invalid_32>
   85e84:	d503201f 	nop
   85e88:	d503201f 	nop
   85e8c:	d503201f 	nop
   85e90:	d503201f 	nop
   85e94:	d503201f 	nop
   85e98:	d503201f 	nop
   85e9c:	d503201f 	nop
   85ea0:	d503201f 	nop
   85ea4:	d503201f 	nop
   85ea8:	d503201f 	nop
   85eac:	d503201f 	nop
   85eb0:	d503201f 	nop
   85eb4:	d503201f 	nop
   85eb8:	d503201f 	nop
   85ebc:	d503201f 	nop
   85ec0:	d503201f 	nop
   85ec4:	d503201f 	nop
   85ec8:	d503201f 	nop
   85ecc:	d503201f 	nop
   85ed0:	d503201f 	nop
   85ed4:	d503201f 	nop
   85ed8:	d503201f 	nop
   85edc:	d503201f 	nop
   85ee0:	d503201f 	nop
   85ee4:	d503201f 	nop
   85ee8:	d503201f 	nop
   85eec:	d503201f 	nop
   85ef0:	d503201f 	nop
   85ef4:	d503201f 	nop
   85ef8:	d503201f 	nop
   85efc:	d503201f 	nop
   85f00:	140000c8 	b	86220 <el0_fiq_invalid_32>
   85f04:	d503201f 	nop
   85f08:	d503201f 	nop
   85f0c:	d503201f 	nop
   85f10:	d503201f 	nop
   85f14:	d503201f 	nop
   85f18:	d503201f 	nop
   85f1c:	d503201f 	nop
   85f20:	d503201f 	nop
   85f24:	d503201f 	nop
   85f28:	d503201f 	nop
   85f2c:	d503201f 	nop
   85f30:	d503201f 	nop
   85f34:	d503201f 	nop
   85f38:	d503201f 	nop
   85f3c:	d503201f 	nop
   85f40:	d503201f 	nop
   85f44:	d503201f 	nop
   85f48:	d503201f 	nop
   85f4c:	d503201f 	nop
   85f50:	d503201f 	nop
   85f54:	d503201f 	nop
   85f58:	d503201f 	nop
   85f5c:	d503201f 	nop
   85f60:	d503201f 	nop
   85f64:	d503201f 	nop
   85f68:	d503201f 	nop
   85f6c:	d503201f 	nop
   85f70:	d503201f 	nop
   85f74:	d503201f 	nop
   85f78:	d503201f 	nop
   85f7c:	d503201f 	nop
   85f80:	140000a9 	b	86224 <el0_error_invalid_32>

0000000000085f84 <el1t_sync_invalid>:
   85f84:	97ffeb50 	bl	80cc4 <invalid_exception_router>

0000000000085f88 <el1t_irq_invalid>:
   85f88:	d10483ff 	sub	sp, sp, #0x120
   85f8c:	a90007e0 	stp	x0, x1, [sp]
   85f90:	a9010fe2 	stp	x2, x3, [sp, #16]
   85f94:	a90217e4 	stp	x4, x5, [sp, #32]
   85f98:	a9031fe6 	stp	x6, x7, [sp, #48]
   85f9c:	a90427e8 	stp	x8, x9, [sp, #64]
   85fa0:	a9052fea 	stp	x10, x11, [sp, #80]
   85fa4:	a90637ec 	stp	x12, x13, [sp, #96]
   85fa8:	a9073fee 	stp	x14, x15, [sp, #112]
   85fac:	a90847f0 	stp	x16, x17, [sp, #128]
   85fb0:	a9094ff2 	stp	x18, x19, [sp, #144]
   85fb4:	a90a57f4 	stp	x20, x21, [sp, #160]
   85fb8:	a90b5ff6 	stp	x22, x23, [sp, #176]
   85fbc:	a90c67f8 	stp	x24, x25, [sp, #192]
   85fc0:	a90d6ffa 	stp	x26, x27, [sp, #208]
   85fc4:	a90e77fc 	stp	x28, x29, [sp, #224]
   85fc8:	f9007bfe 	str	x30, [sp, #240]
   85fcc:	d5384000 	mrs	x0, spsr_el1
   85fd0:	f9007fe0 	str	x0, [sp, #248]
   85fd4:	d5384020 	mrs	x0, elr_el1
   85fd8:	f90083e0 	str	x0, [sp, #256]
   85fdc:	d5384100 	mrs	x0, sp_el0
   85fe0:	f90087e0 	str	x0, [sp, #264]
   85fe4:	a94007e0 	ldp	x0, x1, [sp]
   85fe8:	d2800020 	mov	x0, #0x1                   	// #1
   85fec:	97ffeb36 	bl	80cc4 <invalid_exception_router>
   85ff0:	a94007e0 	ldp	x0, x1, [sp]
   85ff4:	a9410fe2 	ldp	x2, x3, [sp, #16]
   85ff8:	a94217e4 	ldp	x4, x5, [sp, #32]
   85ffc:	a9431fe6 	ldp	x6, x7, [sp, #48]
   86000:	a94427e8 	ldp	x8, x9, [sp, #64]
   86004:	a9452fea 	ldp	x10, x11, [sp, #80]
   86008:	a94637ec 	ldp	x12, x13, [sp, #96]
   8600c:	a9473fee 	ldp	x14, x15, [sp, #112]
   86010:	a94847f0 	ldp	x16, x17, [sp, #128]
   86014:	a9494ff2 	ldp	x18, x19, [sp, #144]
   86018:	a94a57f4 	ldp	x20, x21, [sp, #160]
   8601c:	a94b5ff6 	ldp	x22, x23, [sp, #176]
   86020:	a94c67f8 	ldp	x24, x25, [sp, #192]
   86024:	a94d6ffa 	ldp	x26, x27, [sp, #208]
   86028:	a94e77fc 	ldp	x28, x29, [sp, #224]
   8602c:	f9407bfe 	ldr	x30, [sp, #240]
   86030:	f9407fe0 	ldr	x0, [sp, #248]
   86034:	d5184000 	msr	spsr_el1, x0
   86038:	f94083e0 	ldr	x0, [sp, #256]
   8603c:	d5184020 	msr	elr_el1, x0
   86040:	f94087e0 	ldr	x0, [sp, #264]
   86044:	d5184100 	msr	sp_el0, x0
   86048:	a94007e0 	ldp	x0, x1, [sp]
   8604c:	a94007e0 	ldp	x0, x1, [sp]
   86050:	910483ff 	add	sp, sp, #0x120
   86054:	d69f03e0 	eret

0000000000086058 <el1t_fiq_invalid>:
   86058:	97ffeb1b 	bl	80cc4 <invalid_exception_router>

000000000008605c <el1t_error_invalid>:
   8605c:	97ffeb1a 	bl	80cc4 <invalid_exception_router>

0000000000086060 <el1h_sync>:
   86060:	97ffeb19 	bl	80cc4 <invalid_exception_router>

0000000000086064 <el1h_irq>:
   86064:	d10483ff 	sub	sp, sp, #0x120
   86068:	a90007e0 	stp	x0, x1, [sp]
   8606c:	a9010fe2 	stp	x2, x3, [sp, #16]
   86070:	a90217e4 	stp	x4, x5, [sp, #32]
   86074:	a9031fe6 	stp	x6, x7, [sp, #48]
   86078:	a90427e8 	stp	x8, x9, [sp, #64]
   8607c:	a9052fea 	stp	x10, x11, [sp, #80]
   86080:	a90637ec 	stp	x12, x13, [sp, #96]
   86084:	a9073fee 	stp	x14, x15, [sp, #112]
   86088:	a90847f0 	stp	x16, x17, [sp, #128]
   8608c:	a9094ff2 	stp	x18, x19, [sp, #144]
   86090:	a90a57f4 	stp	x20, x21, [sp, #160]
   86094:	a90b5ff6 	stp	x22, x23, [sp, #176]
   86098:	a90c67f8 	stp	x24, x25, [sp, #192]
   8609c:	a90d6ffa 	stp	x26, x27, [sp, #208]
   860a0:	a90e77fc 	stp	x28, x29, [sp, #224]
   860a4:	f9007bfe 	str	x30, [sp, #240]
   860a8:	d5384000 	mrs	x0, spsr_el1
   860ac:	f9007fe0 	str	x0, [sp, #248]
   860b0:	d5384020 	mrs	x0, elr_el1
   860b4:	f90083e0 	str	x0, [sp, #256]
   860b8:	d5384100 	mrs	x0, sp_el0
   860bc:	f90087e0 	str	x0, [sp, #264]
   860c0:	a94007e0 	ldp	x0, x1, [sp]
   860c4:	910003e0 	mov	x0, sp
   860c8:	97ffeac7 	bl	80be4 <el1h_irq_router>
   860cc:	a94007e0 	ldp	x0, x1, [sp]
   860d0:	a9410fe2 	ldp	x2, x3, [sp, #16]
   860d4:	a94217e4 	ldp	x4, x5, [sp, #32]
   860d8:	a9431fe6 	ldp	x6, x7, [sp, #48]
   860dc:	a94427e8 	ldp	x8, x9, [sp, #64]
   860e0:	a9452fea 	ldp	x10, x11, [sp, #80]
   860e4:	a94637ec 	ldp	x12, x13, [sp, #96]
   860e8:	a9473fee 	ldp	x14, x15, [sp, #112]
   860ec:	a94847f0 	ldp	x16, x17, [sp, #128]
   860f0:	a9494ff2 	ldp	x18, x19, [sp, #144]
   860f4:	a94a57f4 	ldp	x20, x21, [sp, #160]
   860f8:	a94b5ff6 	ldp	x22, x23, [sp, #176]
   860fc:	a94c67f8 	ldp	x24, x25, [sp, #192]
   86100:	a94d6ffa 	ldp	x26, x27, [sp, #208]
   86104:	a94e77fc 	ldp	x28, x29, [sp, #224]
   86108:	f9407bfe 	ldr	x30, [sp, #240]
   8610c:	f9407fe0 	ldr	x0, [sp, #248]
   86110:	d5184000 	msr	spsr_el1, x0
   86114:	f94083e0 	ldr	x0, [sp, #256]
   86118:	d5184020 	msr	elr_el1, x0
   8611c:	f94087e0 	ldr	x0, [sp, #264]
   86120:	d5184100 	msr	sp_el0, x0
   86124:	a94007e0 	ldp	x0, x1, [sp]
   86128:	a94007e0 	ldp	x0, x1, [sp]
   8612c:	910483ff 	add	sp, sp, #0x120
   86130:	d69f03e0 	eret

0000000000086134 <el1h_fiq_invalid>:
   86134:	97ffeae4 	bl	80cc4 <invalid_exception_router>

0000000000086138 <el1h_error_invalid>:
   86138:	97ffeae3 	bl	80cc4 <invalid_exception_router>

000000000008613c <el0_sync_64>:
   8613c:	d10483ff 	sub	sp, sp, #0x120
   86140:	a90007e0 	stp	x0, x1, [sp]
   86144:	a9010fe2 	stp	x2, x3, [sp, #16]
   86148:	a90217e4 	stp	x4, x5, [sp, #32]
   8614c:	a9031fe6 	stp	x6, x7, [sp, #48]
   86150:	a90427e8 	stp	x8, x9, [sp, #64]
   86154:	a9052fea 	stp	x10, x11, [sp, #80]
   86158:	a90637ec 	stp	x12, x13, [sp, #96]
   8615c:	a9073fee 	stp	x14, x15, [sp, #112]
   86160:	a90847f0 	stp	x16, x17, [sp, #128]
   86164:	a9094ff2 	stp	x18, x19, [sp, #144]
   86168:	a90a57f4 	stp	x20, x21, [sp, #160]
   8616c:	a90b5ff6 	stp	x22, x23, [sp, #176]
   86170:	a90c67f8 	stp	x24, x25, [sp, #192]
   86174:	a90d6ffa 	stp	x26, x27, [sp, #208]
   86178:	a90e77fc 	stp	x28, x29, [sp, #224]
   8617c:	f9007bfe 	str	x30, [sp, #240]
   86180:	d5384000 	mrs	x0, spsr_el1
   86184:	f9007fe0 	str	x0, [sp, #248]
   86188:	d5384020 	mrs	x0, elr_el1
   8618c:	f90083e0 	str	x0, [sp, #256]
   86190:	d5384100 	mrs	x0, sp_el0
   86194:	f90087e0 	str	x0, [sp, #264]
   86198:	a94007e0 	ldp	x0, x1, [sp]
   8619c:	910003e0 	mov	x0, sp
   861a0:	97ffea22 	bl	80a28 <el0_sync_router>
   861a4:	a94007e0 	ldp	x0, x1, [sp]
   861a8:	a9410fe2 	ldp	x2, x3, [sp, #16]
   861ac:	a94217e4 	ldp	x4, x5, [sp, #32]
   861b0:	a9431fe6 	ldp	x6, x7, [sp, #48]
   861b4:	a94427e8 	ldp	x8, x9, [sp, #64]
   861b8:	a9452fea 	ldp	x10, x11, [sp, #80]
   861bc:	a94637ec 	ldp	x12, x13, [sp, #96]
   861c0:	a9473fee 	ldp	x14, x15, [sp, #112]
   861c4:	a94847f0 	ldp	x16, x17, [sp, #128]
   861c8:	a9494ff2 	ldp	x18, x19, [sp, #144]
   861cc:	a94a57f4 	ldp	x20, x21, [sp, #160]
   861d0:	a94b5ff6 	ldp	x22, x23, [sp, #176]
   861d4:	a94c67f8 	ldp	x24, x25, [sp, #192]
   861d8:	a94d6ffa 	ldp	x26, x27, [sp, #208]
   861dc:	a94e77fc 	ldp	x28, x29, [sp, #224]
   861e0:	f9407bfe 	ldr	x30, [sp, #240]
   861e4:	f9407fe0 	ldr	x0, [sp, #248]
   861e8:	d5184000 	msr	spsr_el1, x0
   861ec:	f94083e0 	ldr	x0, [sp, #256]
   861f0:	d5184020 	msr	elr_el1, x0
   861f4:	f94087e0 	ldr	x0, [sp, #264]
   861f8:	d5184100 	msr	sp_el0, x0
   861fc:	a94007e0 	ldp	x0, x1, [sp]
   86200:	a94007e0 	ldp	x0, x1, [sp]
   86204:	910483ff 	add	sp, sp, #0x120
   86208:	d69f03e0 	eret

000000000008620c <el0_irq_64>:
   8620c:	97ffeaae 	bl	80cc4 <invalid_exception_router>

0000000000086210 <el0_fiq_invalid_64>:
   86210:	97ffeaad 	bl	80cc4 <invalid_exception_router>

0000000000086214 <el0_error_invalid_64>:
   86214:	97ffeaac 	bl	80cc4 <invalid_exception_router>

0000000000086218 <el0_sync_invalid_32>:
   86218:	97ffeaab 	bl	80cc4 <invalid_exception_router>

000000000008621c <el0_irq_invalid_32>:
   8621c:	97ffeaaa 	bl	80cc4 <invalid_exception_router>

0000000000086220 <el0_fiq_invalid_32>:
   86220:	97ffeaa9 	bl	80cc4 <invalid_exception_router>

0000000000086224 <el0_error_invalid_32>:
   86224:	97ffeaa8 	bl	80cc4 <invalid_exception_router>

0000000000086228 <switch_to>:
   86228:	a9005013 	stp	x19, x20, [x0]
   8622c:	a9015815 	stp	x21, x22, [x0, #16]
   86230:	a9026017 	stp	x23, x24, [x0, #32]
   86234:	a9036819 	stp	x25, x26, [x0, #48]
   86238:	a904701b 	stp	x27, x28, [x0, #64]
   8623c:	a905781d 	stp	x29, x30, [x0, #80]
   86240:	910003e9 	mov	x9, sp
   86244:	f9003009 	str	x9, [x0, #96]
   86248:	a9405033 	ldp	x19, x20, [x1]
   8624c:	a9415835 	ldp	x21, x22, [x1, #16]
   86250:	a9426037 	ldp	x23, x24, [x1, #32]
   86254:	a9436839 	ldp	x25, x26, [x1, #48]
   86258:	a944703b 	ldp	x27, x28, [x1, #64]
   8625c:	a945783d 	ldp	x29, x30, [x1, #80]
   86260:	f9403029 	ldr	x9, [x1, #96]
   86264:	9100013f 	mov	sp, x9
   86268:	d51bd041 	msr	tpidr_el0, x1
   8626c:	d65f03c0 	ret

0000000000086270 <get_current>:
   86270:	d53bd040 	mrs	x0, tpidr_el0
   86274:	d65f03c0 	ret

0000000000086278 <store_context>:
   86278:	a9005013 	stp	x19, x20, [x0]
   8627c:	a9015815 	stp	x21, x22, [x0, #16]
   86280:	a9026017 	stp	x23, x24, [x0, #32]
   86284:	a9036819 	stp	x25, x26, [x0, #48]
   86288:	a904701b 	stp	x27, x28, [x0, #64]
   8628c:	a905781d 	stp	x29, x30, [x0, #80]
   86290:	910003e9 	mov	x9, sp
   86294:	f9003009 	str	x9, [x0, #96]
   86298:	d65f03c0 	ret

000000000008629c <hang>:
   8629c:	14000000 	b	8629c <hang>
